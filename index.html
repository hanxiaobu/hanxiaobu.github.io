<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Linux网络编程-libevent框架开发" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/" class="article-date">
  <time class="dt-published" datetime="2021-05-18T13:56:35.476Z" itemprop="datePublished">2021-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/">Linux网络编程-libevent框架开发</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="libevent框架开发"><a href="#libevent框架开发" class="headerlink" title="libevent框架开发"></a>libevent框架开发</h2><ol>
<li>编写一个基于event实现的tcp服务器：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket---socket()</span><br><span class="line"><span class="number">2</span> 设置端口复用---setsocketopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br><span class="line"><span class="number">3</span> 绑定---bind()</span><br><span class="line"><span class="number">4</span> 设置监听---listen()</span><br><span class="line"><span class="number">5</span> 创建地基</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> *<span class="title">base</span> =</span> event_base_new();</span><br><span class="line"><span class="number">6</span> 创建lfd对应的事件</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> =</span> event_new(base, lfd, EV_READ | EV_PERSIST, conncb, base);</span><br><span class="line"><span class="number">7</span> 上event_base地基</span><br><span class="line">   event_add(ev, <span class="literal">NULL</span>);</span><br><span class="line"><span class="number">8</span> 进入事件循环   event_base_dispatch里边一定调用epoll_wait </span><br><span class="line">   event_base_dispatch(base);</span><br><span class="line"><span class="number">9</span> 释放资源</span><br><span class="line">   event_base_free(base);</span><br><span class="line">   event_free(ev);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*event_callback_fn)</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="comment">//监听文件描述符对应的事件回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">conncb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">event_base</span> * <span class="title">base</span> =</span> (struct event_base *)arg;</span><br><span class="line">   <span class="comment">//接收新的连接</span></span><br><span class="line">   <span class="keyword">int</span> cfd = accept(fd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">if</span>(cfd&gt;<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//创建一个新的事件</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">event</span> *<span class="title">ev</span> =</span>event_new(base, cfd, EV_READ|EV_PERSIST, readcb, <span class="literal">NULL</span>);</span><br><span class="line">      event_add(ev, <span class="literal">NULL</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//读取客户端数据对应的回调函数  为什么没有写在while中是因为 read是阻塞函数 </span></span><br><span class="line"><span class="comment">//一直写的话其他事件得不到响应</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readcb</span><span class="params">(<span class="keyword">evutil_socket_t</span> fd, <span class="keyword">short</span> event, <span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//读数据</span></span><br><span class="line">   n = read(fd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="comment">//从base地基上删除该事件</span></span><br><span class="line">      close(fd);</span><br><span class="line">      event_del(ev);</span><br><span class="line">      event_free(ev);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//发送数据给对方</span></span><br><span class="line">   write(fd, buf, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!signal_event || event_add(signal_event, <span class="literal">NULL</span>)&lt;<span class="number">0</span>) </span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Could not create/add a signal event!\n&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="comment">//这个条件的意思是先执行 event_add(signal_event, NULL)，然后再判断</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="comment">//函数前加static表示只能本机使用</span></span><br><span class="line">listener_cb(struct evconnlistener *listener, <span class="keyword">evutil_socket_t</span> fd,</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">conn_writecb(struct bufferevent *bev, <span class="keyword">void</span> *user_data)</span><br><span class="line">&#123;</span><br><span class="line">	struct evbuffer *output = bufferevent_get_output(bev);</span><br><span class="line">	<span class="keyword">if</span> (evbuffer_get_length(output) == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;flushed answer\n&quot;</span>);</span><br><span class="line">		<span class="comment">//bufferevent_free(bev);</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;<span class="comment">//不应该在写回调事件里往buffer事件里写，由于往bufferevent中写才会触发写回调</span></span><br><span class="line"><span class="comment">//写事件回调在后，写bufferevent在前</span></span><br></pre></td></tr></table></figure></li>
<li>bufferevent的读事件回调触发时机:<br>当数据由内核的读缓冲区到bufferevent的读缓冲区的时候, 会触发bufferevent的<br>读事件回调.需要注意的是: 数据有内核到bufferevent的过程不是用户程序执行的,<br>是有bufferevent内部操作的.<br>bufferevent的写事件回调触发时机:<br>当用户程序将数据写到bufferevent的写缓冲区之后, bufferevent会自动将数据<br>写到内核的写缓冲区,最终有内核程序将数据发送出去.<br>事件回调:<br>当bufferevent绑定的socket连接, 断开或者异常的时候触发事件回调.<br>bufferevent绑定文件描述符一般是cfd，evconnlistenter_new函数绑定的lfd，然后将lfd隐藏<br>bufferevent_socket_connect函数内部已经将buffer缓冲区和通信描述符进行绑定</li>
<li>框架和库的区别：框架提供了一整套的开发流程，按照流程来就可以。但是库仅仅是函数怎么用，怎么用取决于自己。<br>但是想用框架必须按照框架的流程来，框架也提供很多函数，那些也是库<br>使用libevent库编写代码在编译程序的时候需要指定库名:-levent;<br>read write send 都是操作内存缓冲区，不是发送数据，发送数据是内核行为<br>一关闭文件描述符就会刷新缓冲区<br>libevent源码安装需要编译</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> **p=event_get_supported_methods();</span><br><span class="line">  <span class="keyword">while</span>(p[i]!=<span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s \t&quot;</span>,p[i++]);     </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);<span class="comment">//其中p[i]代表*p，由于函数名就是函数地址</span></span><br></pre></td></tr></table></figure></li>
<li>bufferevent和链接监听器代码流程图<br><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/libevent.png" alt="avatar"><h2 id="web服务器开发"><a href="#web服务器开发" class="headerlink" title="web服务器开发"></a>web服务器开发</h2></li>
<li>web服务器开发流程：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket，得到监听文件描述符lfd---socket()</span><br><span class="line"><span class="number">2</span> 设置端口复用-----setsockopt()</span><br><span class="line"><span class="number">3</span> 绑定-----bind()</span><br><span class="line"><span class="number">4</span> 设置监听----listen()</span><br><span class="line"><span class="number">5</span> 创建epoll树，得到树根文件描述符---epfd --epoll_create()</span><br><span class="line"><span class="number">6</span> 将监听文件描述符lfd上树----epoll_ctl(epfd, EPOLL_CTL_ADD...)</span><br><span class="line"><span class="number">7</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">      <span class="comment">//等待事件发生</span></span><br><span class="line">      nready = epoll_wait();</span><br><span class="line">      <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(errno==EINTR)</span><br><span class="line">         &#123;<span class="keyword">continue</span>;&#125;<span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//下面是有事件发生，循环处理每一个文件描述符</span></span><br><span class="line">      <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">      &#123;</span><br><span class="line">         socked = event[i].data.fd;</span><br><span class="line">         <span class="comment">//有客户端链接请求到来</span></span><br><span class="line">         <span class="keyword">if</span>(socked ==lfd)</span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//接收新的客户端连接请求</span></span><br><span class="line">             cfd = accept();</span><br><span class="line">             <span class="comment">//将新的cfd上epoll树</span></span><br><span class="line">             epoll_ctl(epfd, EPOLL_CTL_ADD...);</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">         &#123;</span><br><span class="line">             <span class="comment">//接受数据并处理</span></span><br><span class="line">             http_request(cfd);</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">http_request</span><span class="params">(<span class="keyword">int</span> cfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="comment">//读取请求行</span></span><br><span class="line">   ReadLine();</span><br><span class="line">   <span class="comment">//分析请求行，得到要请求的资源文件file</span></span><br><span class="line">       如：GET /hanzi.c /HTTP1<span class="number">.1</span></span><br><span class="line">   <span class="comment">//循环读完剩余的内核缓冲区的数据</span></span><br><span class="line">     <span class="keyword">while</span>((ReadLine())&gt;<span class="number">0</span>)</span><br><span class="line">   <span class="comment">//判断文件释放存在</span></span><br><span class="line">   stat();</span><br><span class="line">   <span class="number">1</span> 文件不存在 返回错误页：</span><br><span class="line">      组织应答消息：http响应格式消息+错误页正文内容</span><br><span class="line">   <span class="number">2</span> 文件存在：判断文件类型：</span><br><span class="line">      <span class="number">2.1</span>普通文件：http响应格式消息+消息正文</span><br><span class="line">      <span class="number">2.2</span>目录文件：http响应格式消息+html格式文件内容</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>***字符和数字之间可以转换 根据ASCII码<br>***字符char最大就是255<br>%E8%8B%A6%E7%93%9C是字符串 “苦瓜”<br>一个汉字在utf-8中占三个字节<br>E8 8B A6是字符串，其中6个字符占6个字节 需要转成3个字符16进制存到内存中<br>E8是两个字符占两个字节,但是E8两个字符却表示一个十六进制<br>首先把两个字符表示的16进制转成1个十进制数字，在把这个数字转成16进制  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e8 = <span class="number">14</span>*<span class="number">16</span>+<span class="number">8</span>*<span class="number">1</span></span><br><span class="line">  = （<span class="string">&#x27;e&#x27;</span>-<span class="string">&#x27;a&#x27;</span>+<span class="number">10</span>）*<span class="number">16</span>+<span class="string">&#x27;8&#x27;</span>-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">  =   <span class="number">232</span>  </span><br><span class="line"><span class="comment">//转换汉字编码   ：strdecode(pFile, pFile);</span></span><br></pre></td></tr></table></figure></li>
<li>http请求消息格式说明：<ol>
<li>请求头：如GET /aaa.txt HTTP/1.1</li>
<li>请求行：键值对</li>
<li>空行：\r\n</li>
<li>请求内容</li>
</ol>
get 和 post的区别：<br>请求头get 和 post 请求都是请求资源,而且都会提交数据,如果提交密码信息用get请求,<br>就会明文显示,而post则不会显示出涉密信息.<br>http响应消息格式说明：<ol>
<li>响应头：HTTP/1.1 200 OK</li>
<li>响应行：键值对<br>content-type<br>Content-Length：要有就必须是正确的文件大小，要么写0</li>
<li>空行：\r\n</li>
<li>响应消息正文<br>//C++中查找文件类型的函数 map C语言中的结构体  根据jpg找 image/jpeg<br>//switch 后边不能是字符串 可以是整型 字节<br><img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/libevent1.png" alt="avatar"></li>
</ol>
</li>
<li>案例整体功能介绍：<br>先打开浏览器，然后输入<a target="_blank" rel="noopener" href="http://192.168.10.143:9999/hanzi.c">http://192.168.10.143:9999/hanzi.c</a><br>通过案例演示联想到的知识点：<ol>
<li>开发网络服务器：  <ul>
<li>多IO复用技术：epoll poll select</li>
<li>多进程或者多线程</li>
<li>第三方库：libevent库</li>
</ul>
</li>
<li>熟悉http协议：<ul>
<li>请求协议</li>
<li>应答协议</li>
</ul>
</li>
<li>使用的协议有http协议+TCP协议<ul>
<li>TCP协议：建立连接的三次握手，连接建立完成后接着是数据传输</li>
<li>web服务器：首先解析浏览器发来的请求视频，得到请求的文件名</li>
<li>若文件存在，<ul>
<li>判断文件类型：若是普通文件：则发送文件内容给浏览器；</li>
<li>若是目录文件，则发送文件列表</li>
<li>若文件不存在，则发送一个错误页给浏览器</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="number">1000</span>);</span><br><span class="line"><span class="built_in">sprintf</span>(buf,<span class="string">&quot;POST&quot;</span>);<span class="comment">//buf==&quot;POST&quot;  指针移动到数组的第四个字符</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;page&quot;</span>);<span class="comment">//buf==&quot;POSTpage&quot; 指针移动到数组的第八个字符</span></span><br><span class="line"><span class="built_in">sprintf</span>(buf+<span class="built_in">strlen</span>(buf),<span class="string">&quot;HTTP/1.0\r\n&quot;</span>);<span class="comment">//buf==&quot;POSTpageHTTP/1.0\r\n&quot;</span></span><br><span class="line"><span class="built_in">sscanf</span>(buf, <span class="string">&quot;%[^ ] %[^ ] %[^ \r\n]&quot;</span>,reqType, fileName, protocal);</span><br><span class="line"><span class="comment">//从buf中取指定长度的字符串到reqType fileName protocal中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">( <span class="keyword">char</span> *buffer, <span class="keyword">const</span> <span class="keyword">char</span> *format [, argument] … )</span></span>;</span><br><span class="line"><span class="comment">//把格式化的数据写入某个字符串</span></span><br><span class="line">超链接链表中</span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;&lt;li&gt;&lt;a href=%s&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>, </span><br><span class="line">namelist[num]-&gt;d_name, namelist[num]-&gt;d_name);</span><br><span class="line"><span class="comment">//这个是获取文件   如果拼的是目录需要在%s后边加&quot;/&quot;</span></span><br><span class="line"><span class="built_in">sprintf</span>(buffer, <span class="string">&quot;&lt;li&gt;&lt;a href=%s/&gt; %s &lt;/a&gt;&lt;/li&gt;&quot;</span>, </span><br><span class="line">namelist[num]-&gt;d_name, namelist[num]-&gt;d_name);</span><br></pre></td></tr></table></figure>
<img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/libevent2.png" alt="avatar"></li>
<li>守护进程讲了 切换目录  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//改变当前进程的工作目录</span></span><br><span class="line">	<span class="keyword">char</span> path[<span class="number">255</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">sprintf</span>(path,<span class="string">&quot;%s/%s&quot;</span>,getenv(<span class="string">&quot;HOME&quot;</span>),<span class="string">&quot;webpath&quot;</span>);</span><br><span class="line">	chdir(path);</span><br><span class="line">   echo $HOME 获取环境变量  getenv()函数 /home/xiaobu</span><br><span class="line">   env 表示环境变量 其中PWD=/home/xiaobu 等号左边叫名字右边叫值</span><br><span class="line">   <span class="comment">//其中HOME在linux和unix中都用 表示用户的家目录</span></span><br><span class="line">   ```  </span><br><span class="line">   访问目录有三个函数就是  opendir closedir readdir ***scandir</span><br><span class="line"><span class="number">7.</span> 实际开发中 要先搞通整个流程 再有时间抠细节  </span><br><span class="line">   xml和html区别就是xml可以自己定义  </span><br><span class="line">   json键值对格式 ，<span class="built_in">map</span>键值对格式，其中键不能重复  </span><br><span class="line">   \r\n 表示换行  \r表示移到这一行的末尾， \n表示换行  </span><br><span class="line">   DNS域名服务器是用来解析外网域名的，IE先解析域名找到对应ip然后操作  </span><br><span class="line">   应用层协议：ssh协议 ftp协议 telnet协议 邮件协议 http协议  </span><br><span class="line">   ``serv_addr.sin_addr.s_addr = INADDR_ANY;``  </span><br><span class="line">   其中INADDR_ANY宏的值是<span class="number">0</span>，做不做大小端转换都是<span class="number">0</span>  </span><br><span class="line">   stat函数参数第一个是路径 第二个是一个输出参数 变化的东西都需要传入参数  </span><br><span class="line">   %s 可以代表字符串首地址  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="keyword">for</span>循环中<span class="keyword">if</span>中如果有<span class="keyword">continue</span>，等价于<span class="keyword">if</span> <span class="keyword">else</span></span><br><span class="line">   <span class="keyword">for</span>()</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>()&#123;<span class="keyword">continue</span>;&#125;</span><br><span class="line">      <span class="keyword">if</span>()&#123;<span class="string">&quot;文件内容&quot;</span>&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>()</span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">if</span>()&#123;&#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;<span class="string">&quot;文件内容&quot;</span>&#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">va_start(ap, outfmt);</span><br><span class="line">     <span class="built_in">vfprintf</span>(msgfile, outfmt, ap);</span><br><span class="line">     va_end(ap);</span><br><span class="line"><span class="comment">//处理可变参数</span></span><br></pre></td></tr></table></figure></li>
<li>知识点归纳:  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 网络通信.</span><br><span class="line">	socket API函数: socket bind listen accept read | recv send write</span><br><span class="line">	三次握手和四次挥手</span><br><span class="line">	TCP协议</span><br><span class="line">	服务端开发: </span><br><span class="line">		服务端的基本开发流程:</span><br><span class="line">			<span class="number">1</span> socket</span><br><span class="line">			<span class="number">2</span> setsockopt</span><br><span class="line">			<span class="number">3</span> bind</span><br><span class="line">			<span class="number">4</span> listen</span><br><span class="line">			<span class="number">5</span> <span class="keyword">while</span>(<span class="number">1</span>) &#123;	 &#125;</span><br><span class="line">		客户端的基本开发流程:</span><br><span class="line">			<span class="number">1</span> socket</span><br><span class="line">			<span class="number">2</span> connect</span><br><span class="line">			<span class="number">3</span> <span class="keyword">while</span>(<span class="number">1</span>) &#123;write();read();&#125;	     </span><br><span class="line">		多进程</span><br><span class="line">		多线程</span><br><span class="line">		多路复用技术: select poll epoll</span><br><span class="line">		多路IO复用与多线程或者多进程结合使用</span><br><span class="line">		第三方库: libevent</span><br><span class="line"><span class="number">2</span> 报文编解码</span><br><span class="line"><span class="number">3</span> 进程间通信    pipe fifo mmap 本地套接字  网络套接字  共享内存</span><br><span class="line"><span class="number">4</span> 数据库操作相关知识点    oracle的occi库</span><br><span class="line"><span class="number">5</span> QT相关</span><br><span class="line"><span class="number">6</span> 守护进程的创建步骤</span><br><span class="line"><span class="number">7</span> 信号相关知识点    SIGUSR1 SIGUSR2    signal   sigaction </span><br><span class="line"><span class="number">8</span> shell编程相关</span><br><span class="line"><span class="number">9</span> 加密算法相关</span><br><span class="line"><span class="number">10</span> 多线程开发</span><br><span class="line"><span class="number">11</span> c++基础的概念    封装 继承  多态</span><br><span class="line">     多态的三个条件：父类的虚方法 子类得继承  父类的指针或者引用指向子类对象</span><br><span class="line">-------------------------------------</span><br><span class="line">子系统划分:</span><br><span class="line"><span class="number">1</span> 秘钥协商客户端子系统</span><br><span class="line"><span class="number">2</span> 秘钥协商服务端子系统</span><br><span class="line"><span class="number">3</span> 客户端信息注册报备图形化界面系统</span><br><span class="line">模块划分:</span><br><span class="line"><span class="number">1</span> 报文编解码模块</span><br><span class="line"><span class="number">2</span> 网络通信模块</span><br><span class="line"><span class="number">3</span> 共享内存操作模块</span><br><span class="line"><span class="number">4</span> 数据库操作模块</span><br><span class="line"><span class="number">5</span> 外联接口</span><br></pre></td></tr></table></figure></li>
<li>加密三要素:<br>(秘钥+加密算法)+明文==&gt;密文  (秘钥+解码算法)+密文==&gt;明文<br>加密<br>明文: 123456<br>算法: a+秘钥<br>秘钥是: 222222<br>密文: 345678<br>解密:<br>密文: 345678<br>算法: a-秘钥<br>秘钥是: 222222<br>明文: 123456<br>加密算法:  <pre><code class="c">1 对称加密算法
    DES 3DES AES
2 非对称加密
    RSA
3 哈希算法
    哈希算法不是用来加密的, 因为不可逆
    SHA1 SHA2  MD4 MD5 HMAC      
</code></pre>
33b3bc8e05b4fcc16bd531dd9adac166<br>所谓的加密算法就是为了防止客户端发送到服务端的数据被中途篡改</li>
<li>源码的安装一般由有这三个步骤：<br>配置(configure)、编译(make)、安装(make install)<br>./config   //生成makefile还可以检查文件<br>make    //把源码编译成库文件和可执行文件<br>make test       （可选）<br>make install     (使用管理员权限执行该命令)<br>报错：  <ol>
<li>解决openssl: error while loading shared libraries: libssl.so.1.1: cannot open shared object file: No such file or directory错误<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xyb930826/p/6077348.html">https://www.cnblogs.com/xyb930826/p/6077348.html</a>  </li>
<li>关于执行locate时报错“locate: can not stat () `/var/lib/mlocate/mlocate.db’: No such file or directory”的处理<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/hzlwoshifanren/article/details/53381103">https://blog.csdn.net/hzlwoshifanren/article/details/53381103</a>  </li>
<li>错误：只允许在 C99 模式下使用‘for’循环初始化声明 用gcc编译出现<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/wojiuguowei/article/details/82788535">https://blog.csdn.net/wojiuguowei/article/details/82788535</a></li>
</ol>
</li>
<li>1 该项目的使用场合?<br>涉及到网络数据传输的对数据传输安全有需求的, 就需要对数据进行加密;<br>加密就需要用到秘钥, 秘钥如何产生? —-&gt; 就用到了秘钥协商系统.<br>秘钥协商服务系统就是用来生成秘钥的, 该秘钥是对称秘钥.<br>2 大的项目需要划分成几个小的子系统, 子系统可以进一步划分成模块,<br>每个模块可以实现多种功能, 各个模块之间也有相互协作.<br>3 秘钥协商服务系统总体流程说明:  <ul>
<li>客户端发起秘钥协商的请求, 发送给服务端的随机字符串为abc</li>
<li>服务端收到客户端的随机字符串之后, 自己也生成一个随机字符串123, 且将123发送给客户端;</li>
<li>服务端将abc123作为生成秘密的原材料, 通过使用某种算法生成一个新的秘钥</li>
<li>客户端收到服务端发送的123之后, 也进行组合abc123, 也使用与服务端相同的算法, 也生成新的秘钥(这个秘钥应该与服务端生成的秘钥一样)</li>
<li>当客户端和服务端都生成秘钥之后, 可以通过秘钥校验验证客户端和服务端生成的秘钥是否一致.</li>
<li>客户端将秘钥写入共享内存, 服务端将秘钥写入共享内存.</li>
</ul>
</li>
<li>为什么要用客户端和服务器之间协商生成密钥？ 原理：两者的对称加密<br>那么：直接随机生成一个固定的数字然后加密给不同的两个站点也可以<br>但是：1 主要是这个平台支持多端，相当于不同的客户端，所以用客户端和服务端协商密钥<br>2 不同站点对应不同的端。每两个站点组合生成密钥，分别把相同密钥存在两端<br>这个密钥系统会提供一个接口给第三方 防止内存误操作</li>
<li>windows环境下测试openssl库函数:<br>1 包含库函数所在头文件路径  相当于linux下添加库文件 -I （大i）<br>2 包含库文件所在路径            相当于linux下添加库文件 -L<br>3 具体包含的库文件的名字      相当于linux下添加库文件 -l（小L）<br>添加方法：项目上右键(不是解决方案上)属性-&gt;VC++目录中包含目录和库目录<br>属性-&gt;链接器-&gt;输入-&gt;附加依赖项</li>
<li>free -m 看看内存大小<br>Redhat7使用CentOS7的Yum源<br><a target="_blank" rel="noopener" href="https://blog.51cto.com/sky9896/2312007">https://blog.51cto.com/sky9896/2312007</a><br>bash代表一个进程 bashrc代表一个配置文件<br>！！！整个系统最重要的就是客户端给服务端发送的哈希值不被篡改就可以<br>因为即便获取到了也没用，因为客户端给服务端发送的是一半，服务端也给我服务端发自己的一半<br>即便两者都被获取到了 我们用的也不是哈希值，用的是哈希的头部<br>接口：就是按照我的规定去执行 访问我指定的数据和我指定的方法</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/" data-id="ckp3biliq00084suefg8k8hwi" data-title="Linux网络编程-libevent框架开发" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux网络编程-高并发服务器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T16:51:53.298Z" itemprop="datePublished">2021-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">Linux网络编程-高并发服务器</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux网络编程-高并发服务器"><a href="#Linux网络编程-高并发服务器" class="headerlink" title="Linux网络编程-高并发服务器"></a>Linux网络编程-高并发服务器</h2><ol>
<li><p>三次握手：<br>三次握手：建立连接需要三次握手过程<br>四次挥手：断开连接需要四次挥手过程<br>win 4096表示我这边接收缓冲区可用4096，<br>mss 1460 告诉对方我这边一次性可以接收数据长度最大为1460<br>函数封装思想：<br>阻塞函数在阻塞期间若收到信号，会被信号中断，errno设置为EINTR，<br>这个错误不应该看成一个错误<br><code>const void * vptr</code> vptr代表缓冲区 指针</p>
</li>
<li><p>解决粘包问题：</p>
<ol>
<li>报头+数据<br>报头可以用四个字节长度：例如：0010(四个字符的字符串) 四个字节长度+数据部分<br>0010 0123456789<br>0007 abcdefg</li>
<li>添加结尾标记</li>
<li>数据包定长<br>事先协商好：相当于协议的意思，底层称之为协议，数据部分协议我们称之为接口，接口简单文档看懂了就可以写，业务逻辑比较难<br>如：发送20个字节的定长数据： 0010xiaozhaobeijing027<br>注意：如果发送的数据是整型需要转换 大端转换 发送是字符串不需要转换</li>
</ol>
</li>
<li><p>重大报错：<br>gcc编译多线程服务器时<br><code>gcc -o thread 02-mult-thread.c wrap.c</code><br>出现报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">   /tmp/ccQ5k9fI.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line">   <span class="number">02</span>-mult-thread.c:(.text+<span class="number">0x1e7</span>): undefined reference to `pthread_create<span class="number">&#x27;</span></span><br><span class="line">   <span class="number">02</span>-mult-thread.c:(.text+<span class="number">0x1f3</span>): undefined reference to `pthread_detach<span class="number">&#x27;</span></span><br><span class="line">   collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">   ```  </span><br><span class="line">   解决办法：  </span><br><span class="line">   故在使用gcc编译的时候应该是：``gcc xxx -pthread``  </span><br><span class="line">   一定要加上“-lpthread”,这样才可以编译通过   </span><br><span class="line">   ``gcc -o thread <span class="number">02</span>-mult-thread.c wrap.c -pthread``</span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\&quot;续行符，写代码的时候一行写不下，写两行  </span></span><br><span class="line"><span class="string">   ``int lfd = Socket(AF_INET, SOCK_STREAM, 0);\``  </span></span><br><span class="line"><span class="string">   可以改成这样：  </span></span><br><span class="line"><span class="string">   ``int lfd = Socket(AF_INET,``  </span></span><br><span class="line"><span class="string">   ``SOCK_STREAM, 0);``  </span></span><br><span class="line"><span class="string">   当read读文件描述符为非阻塞状态的时候,   </span></span><br><span class="line"><span class="string">   若对方没有发送数据, 会立刻返回, errno设置为EAGAIN, 这个错误我们要忽略.</span></span><br><span class="line"><span class="string">5. len写在循环里 是因为len每次都会改.因为端口会改，所以client会变  </span></span><br><span class="line"><span class="string">   len是输入输出参数  </span></span><br><span class="line"><span class="string">   read函数遇到出错cfd返回-1，对方关闭连接返回0  </span></span><br><span class="line"><span class="string">   bind error :Address already in use报错  </span></span><br><span class="line"><span class="string">   int opt = 1;  </span></span><br><span class="line"><span class="string">   setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));  </span></span><br><span class="line"><span class="string">   ![avatar](/Linux网络编程-高并发服务器/高并发1.png)</span></span><br><span class="line"><span class="string">   return是返回调用者的位置，  </span></span><br><span class="line"><span class="string">   return和exit还有break都在线程中效果一样，但是在函数中exit函数才是退出进程或者线程  </span></span><br><span class="line"><span class="string">   父子进程可以共享的：</span></span><br><span class="line"><span class="string">   1. 文件描述符 </span></span><br><span class="line"><span class="string">   2. mmap共享映射区</span></span><br><span class="line"><span class="string">   3. 每个子进程中的变量是互不影响的</span></span><br><span class="line"><span class="string">   4. 在fork之前的变量、函数都会被复制，但是函数不会执行，fork前的函数被父进程调用时还没有子进程。</span></span><br><span class="line"><span class="string">      1. ![avatar](/Linux网络编程-高并发服务器/高并发2.png)</span></span><br><span class="line"><span class="string">      2. ![avatar](/Linux网络编程-高并发服务器/高并发3.png)</span></span><br><span class="line"><span class="string">6. if语句括号中的表达式需要先执行在判断  </span></span><br><span class="line"><span class="string">   所以这个函数的理解是，  </span></span><br><span class="line"><span class="string">   在while中，先执行if语句括号中的表达式得到nread，然后判断nread&lt;0，或者nread==0，最后默认是nread&gt;0的操作  </span></span><br><span class="line"><span class="string">   if的用法是先判断错误的，默认走正确的代码  </span></span><br><span class="line"><span class="string">   my_read函数每次读取一个字符，并将字符地址指向后方  </span></span><br><span class="line"><span class="string">   readline 函数每次读取一行，并且读完将执指针指向行首  </span></span><br><span class="line"><span class="string">      1. ![avatar](/Linux网络编程-高并发服务器/高并发4.png)</span></span><br><span class="line"><span class="string">      2. ![avatar](/Linux网络编程-高并发服务器/高并发5.png)</span></span><br><span class="line"><span class="string">      3. ![avatar](/Linux网络编程-高并发服务器/高并发6.png)</span></span><br><span class="line"><span class="string">7. 多进程服务器版本思路  </span></span><br><span class="line"><span class="string">   ```c</span></span><br><span class="line"><span class="string">   while(1)</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">      	cfd = accept();</span></span><br><span class="line"><span class="string">      	</span></span><br><span class="line"><span class="string">      	while(1)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		n = read(cfd, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">      		if(n&lt;=0)</span></span><br><span class="line"><span class="string">      		&#123;</span></span><br><span class="line"><span class="string">      			break;</span></span><br><span class="line"><span class="string">      		&#125;</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   ```  </span></span><br><span class="line"><span class="string">   解决办法1:  </span></span><br><span class="line"><span class="string">   将cfd设置为非阻塞: fcntl  </span></span><br><span class="line"><span class="string">   假如有多个客户端连接请求, cfd只会保留最后一个文件描述符的值  </span></span><br><span class="line"><span class="string">   解决方法2:  </span></span><br><span class="line"><span class="string">   使用多进程: 让父进程监听接受新的连接, 子进程处理新的连接(接收和发送数据);  </span></span><br><span class="line"><span class="string">   父进程还负责回收子进程  </span></span><br><span class="line"><span class="string">   还需要添加的功能: 父进程使用SIGCHLD信号完成对子进程的回收  </span></span><br><span class="line"><span class="string">   注意点: accept或者read函数是阻塞函数, 会被信号打断, 此时不应该视为一个错误.errno=EINTR</span></span><br><span class="line"><span class="string">8. 处理流程:</span></span><br><span class="line"><span class="string">	1. 创建socket, 得到一个监听的文件描述符lfd---socket()</span></span><br><span class="line"><span class="string">	2. 将lfd和IP和端口port进行绑定-----bind();</span></span><br><span class="line"><span class="string">	3. 设置监听----listen()</span></span><br><span class="line"><span class="string">    ```c</span></span><br><span class="line"><span class="string">    进入while(1)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">      	//等待有新的客户端连接到来</span></span><br><span class="line"><span class="string">        //子程序不执行这个函数（父进程执行一次），因为fork在后边，但是cfd和lfd值，</span></span><br><span class="line"><span class="string">        //父子进程是一样的</span></span><br><span class="line"><span class="string">      	cfd = accept();	  </span></span><br><span class="line"><span class="string">      	//fork一个子进程, 让子进程去处理数据</span></span><br><span class="line"><span class="string">      	pid = fork();</span></span><br><span class="line"><span class="string">      	if(pid&lt;0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		exit(-1);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">      	else if(pid&gt;0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		//关闭通信文件描述符cfd</span></span><br><span class="line"><span class="string">      		close(cfd);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">      	else if(pid==0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		//关闭监听文件描述符</span></span><br><span class="line"><span class="string">      		close(lfd);	  		</span></span><br><span class="line"><span class="string">      		//收发数据</span></span><br><span class="line"><span class="string">      		while(1)</span></span><br><span class="line"><span class="string">      		&#123;</span></span><br><span class="line"><span class="string">      			//读数据</span></span><br><span class="line"><span class="string">      			n = read(cfd, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">      			if(n&lt;=0)</span></span><br><span class="line"><span class="string">      			&#123;</span></span><br><span class="line"><span class="string">      				break;</span></span><br><span class="line"><span class="string">      			&#125;</span></span><br><span class="line"><span class="string">      			//发送数据给对方</span></span><br><span class="line"><span class="string">      			write(cfd, buf, n);</span></span><br><span class="line"><span class="string">      		&#125;</span></span><br><span class="line"><span class="string">      		close(cfd);	  		</span></span><br><span class="line"><span class="string">      		//下面的exit必须有, 防止子进程再去创建子进程</span></span><br><span class="line"><span class="string">      		exit(0);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	close(lfd);</span></span><br></pre></td></tr></table></figure></li>
<li><p>多线程版本的服务器开发流程:</p>
<ol>
<li>创建socket，得到一个监听的文件描述符lfd—socket()</li>
<li>将lfd和IP和端口port进行绑定—–bind();</li>
<li>设置监听—–listen()</li>
<li>```c<br>while(1)<br>{<br>  //接收新的客户端连接请求<br>  cfd = accept();<br>  //创建一个子线程<br>  pthread_create(&amp;threadID, NULL, thread_work, &amp;cdf);<br>  //设置分离属性 也可以设置pthread_create函数的第二个参数<br>  pthread_detach(threadID);<br>}<br>close(lfd);  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">      子线程执行函数：  </span><br><span class="line">      &#96;&#96;&#96;c</span><br><span class="line">      void *thread_work(void *arg)</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F;获得参数：通讯文件描述符</span><br><span class="line">        int cfd &#x3D; *(int *)arg;</span><br><span class="line">        sleep(1);</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F;读数据</span><br><span class="line">          n&#x3D;read(cfd, buf, sizeof(buf)); </span><br><span class="line">          if(n&lt;&#x3D;0)</span><br><span class="line">          &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;发送数据</span><br><span class="line">          write(cfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      close(cfd);</span><br><span class="line">      &#96;&#96;&#96;  </span><br><span class="line">      注意：  </span><br><span class="line">      如果同时五个线程连过来，由于创建子线程有先有后（谁先抢到cpu时间片谁先执行）  </span><br><span class="line">      sleep写在“int cfd &#x3D; *(int *)arg;”下边，cfd会在sleep(1)这一秒中，变成最终值  </span><br><span class="line">      但是sleep加在上边时，由于创建子线程有先有后，就会分开12345秒  </span><br><span class="line">10. 多线程版本的服务器开发问题:</span><br><span class="line">	1. 子线程能否关闭lfd?</span><br><span class="line">		子线程不能关闭监听文件描述符lfd,原因是子线程和主线程共享文件描述符</span><br><span class="line">		而不是复制的.</span><br><span class="line">	2. 主线程能否关闭cfd?</span><br><span class="line">		主线程不能关闭cfd, 主线程和子线程共享一个cfd, 而不是复制的, close之后cfd就会</span><br><span class="line">		被真正关闭.</span><br><span class="line">	3. 多个子线程共享cfd, 会有什么问题发生?  </span><br><span class="line">    &#96;&#96;&#96;c</span><br><span class="line">    struct INFO</span><br><span class="line">    &#123;</span><br><span class="line">    	int cfd;</span><br><span class="line">    	pthread_t threadID;</span><br><span class="line">    	struct sockaddr_in client;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct INFO info[100];</span><br><span class="line">    struct INFO</span><br><span class="line">    &#123;</span><br><span class="line">    	int cfd;</span><br><span class="line">    	pthread_t threadID;</span><br><span class="line">    	struct sockaddr_in client;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct INFO info[100];</span><br><span class="line">    &#x2F;&#x2F;初始化INFO数组</span><br><span class="line">    for(i&#x3D;0; i&lt;100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	info[i].cfd&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i&#x3D;0; i&lt;100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(info[i].cfd&#x3D;&#x3D;-1)</span><br><span class="line">    	&#123;</span><br><span class="line">    		&#x2F;&#x2F;这块内存可以使用</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&#x3D;&#x3D;100)</span><br><span class="line">    &#123;</span><br><span class="line">    	&#x2F;&#x2F;拒绝接受新的连接</span><br><span class="line">    	close(cfd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>心跳包：<br>什么是心跳包?<br>用于监测长连接是否正常的字符串.<br>在什么情况下使用心跳包?<br>主要用于监测长连接是否正常.<br>如何使用心跳包?<br>通信双方需要协商规则(协议), 如4个字节长度+数据部分<br>发送心跳包的过程：<br>服务A给B发送数据AAAA(这个是协议)，服务B收到AAAA之后，给A回复BBBB，此时A收到BBBB之后，链接正常。<br>假如A连续发送多次(如3-5次)之后，仍然没有收到B的回复，则认为连接异常；<br>异常之后，A应该重新建立连接：<br>先close原来的链接(这样不会粘包)，然后再重新connect连接就可以了<br>如何让心跳数据和正常的业务数据不混淆？<br>双方可以协商协议，如4个字节长度+具体数据<br>如果发送心跳数据应该：0004AAAA<br>如果发送业务数据：00100123456789<br>对方收数据的时候先收4个字节的报头数据，然后计算长度，若最后计算长度为4，且数据为AAAA，则认为是心跳数据，则B服务会组织应答数据给A：0004BBBB</p>
</li>
<li><p>TCP状态转换图：  </p>
<ol>
<li>三次捂手过程：<br>客户端：SYN_SENT—connect()<br>服务端：LISTEN–listen() SYN_RCVD<br>当三次握手完成后，都处于ESTABLISHED状态  </li>
<li>数据传输过程中状态不发生变化， 都是ESTABLISHED状态  </li>
<li>四次挥手过程：  </li>
</ol>
<p>主动关闭方：FIN_WAIT_T, FIN_WAIT_2, TIME_WAIT<br>被动关闭方： CLOSE_WAIT  LAST_ACK<br>思考题?</p>
<ol>
<li>SYN_SENT状态出现在哪一方? 客户端</li>
<li>SYN_RCVD状态出现在哪一方? 服务端</li>
<li>TIME_WAIT状态出现在哪一方?  主动关闭方</li>
<li>在数据传输的时候没有状态变化.  </li>
</ol>
<p>TIME_WAIT是如何出现的:<br>启动服务端, 启动客户端, 连接建好, 而且也可以正常发送数据;<br>然后先关闭服务端, 服务端就会出现TIME_WAIT状态.<br>为什么需要2MSL：</p>
<ol>
<li>留点时间 让四次挥手的过程更可靠, 确保最后一个发送给对方的ACK到达;</li>
<li>为了保证在2MSL时间内, 不能启动相同的SOCKET-PAIR，如果启动相同的会产生粘包问题  </li>
</ol>
<p>***客户端不绑定端口可以避免2MSL，因为端口不固定 不同的socket-pair<br>相同的socket-pair代表 相同的ip和端口</p>
</li>
<li><p>设置端口复用：<br><code>int opt = 1；</code><br><code>setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));</code><br>半关闭的概念:<br>如果一方close, 另一方没有close, 则认为是半关闭状态, 处于半关闭状态的时候, 可以接收数据, 但是不能发送数据. 相当于把文件描述符的写缓冲区操作关闭了.<br>注意: 半关闭一定是出现在主动关闭的一方. —–半关闭是向下关闭<br>shutdown和close的区别：  </p>
<ol>
<li>shutdown可以实现半关闭，close不行  </li>
<li>2 shutdown关闭的时候，不考虑文件描述符的引用计数，是直接彻底关闭  </li>
</ol>
<p>close考虑文件描述符的引用计数，调用一次close只是将引用数减1，<br>只有减少到0的时候才会真正的关闭<br>注意：当关闭一方，内核操作的ack确认信号还是能发回去的，只不过用户层面不发回去<br>长连接和端连接的概念:<br>长连接: 连接建立好之后,一直保持连接不关闭<br>短连接: 连接使用完之后就立刻关闭.</p>
</li>
<li><p>阻塞有点像qt中的模态对话框<br>阻塞就是在等待一个条件的成立，比如read在等待输入<br>ulimit -a 查看各个内存大小<br>FD_SETSIZE=1024  fd_set使用了该宏, 当然可以修改内核, 然后再重新编译内核, 一般不建议这么做.<br>errno==ECONNABORTED   连接异常<br>errno==EINTR               被信号打断</p>
</li>
<li><p>多路IO复用技术：select函数介绍<br><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>函数作用：<br>委托内核监控可读，可写，异常事件<br>函数参数：<br>nfds：输入参数，告诉内核要监控文件描述符的范围，一般取值为最大文件描述符+1<br>readfds：<br>-输入参数：告诉内核要监控哪些文件描述符<br>-输出参数：内核告诉应用程序哪些文件描述符有变化<br>writefds：<br>-输入参数：告诉内核要监控哪些文件描述符<br>-输出参数：内核告诉应用程序哪些文件描述符有变化<br>Exceptfds：<br>-输入输出参数，一般表示异常事件<br>Timeout：<br>超时时间：<br>NULL：表示永久堵塞，直到有事件发生<br>0：表示不阻塞，不管有没有事件发生，都会立刻返回<br>0：表示阻塞的时长，若没有超过时长，则一直堵塞<br>若在时间内，有事情发生，则立刻返回，<br>若超过时长，则立刻返回<br>返回值：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">///成功返回发生变化的文件描述符</span></span><br><span class="line">       fd_set <span class="built_in">set</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：从set集合中清除fd</span></span><br><span class="line">       <span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：判断fd是否在set集合中</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：将fd添加到set集合中</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：清空文件描述符集</span></span><br><span class="line">    ```  </span><br><span class="line">    注意：select主要用于服务端，客户端也可以用比如让select监控标准输入，  </span><br><span class="line">    只是文件文件描述符都可以监控，管道也行  </span><br><span class="line">    数据类型fd_set: 文件描述符集合--本质是位图(关于集合可联想一个信号集<span class="keyword">sigset_t</span>)其中位图类似未决信号集</span><br><span class="line"><span class="number">16.</span> 使用select的开发服务端流程：   </span><br><span class="line">    <span class="number">1.</span> 创建socket，得到监听文件描述符lfd----socket()</span><br><span class="line">    <span class="number">2.</span> 设置端口复用----setsockopt()</span><br><span class="line">    <span class="number">3.</span> 将lfd和IP  PORT绑定----bind()</span><br><span class="line">    <span class="number">4.</span> 设置监听--- listen()</span><br><span class="line">    <span class="number">5.</span> 需要内核监听 客户端发的链接或者发的数据  </span><br><span class="line">   <span class="comment">//readfds: 读集合, 是一个传入传出参数  </span></span><br><span class="line">   <span class="comment">//传入: 指的是告诉内核哪些文件描述符需要监控  </span></span><br><span class="line">   <span class="comment">//传出: 指的是内核告诉应用程序哪些文件描述符发生了变化  </span></span><br><span class="line">   fd_set readfds；<span class="comment">//定义文件描述符集变量  </span></span><br><span class="line">   fd_set tmpfds; <span class="comment">//对于传入传出变量我们需要定义一个中间变量  </span></span><br><span class="line">   FD_ZERO(&amp;readfds); <span class="comment">//清空文件描述符集变量  </span></span><br><span class="line">   FD_SET(lfd, &amp;readfds); <span class="comment">//将lfd加入到readfds集合中</span></span><br><span class="line">   ```c</span><br><span class="line">   maxfd = lfd; </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">          <span class="comment">//这样传入的是readfds，传出变化的是tmpfds </span></span><br><span class="line">          <span class="comment">//如果select中用readfds，那么上边的FD_SET(lfd, &amp;readfds);中readfds就变了</span></span><br><span class="line">          tmpfds=readfds;         </span><br><span class="line">          <span class="comment">//readfds是传入传出参数，tmpfds每次都改，只要select返回，tmpfds就改。</span></span><br><span class="line">          <span class="comment">//假如有3个客户端请求和2个客户端发来数据，nready=5，</span></span><br><span class="line">          <span class="comment">//所以说只要内核监听到连接(nready！=0)，select函数有返回，tmpfds比变化</span></span><br><span class="line">          nready = select(maxfd+<span class="number">1</span>, &amp;tmpfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(error==EINTR) <span class="comment">//被信号中断</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;  </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//发生变化的文件描述符有两类，一类是监听的，一类是用于数据通信的</span></span><br><span class="line">          <span class="comment">//监听文件描述符有变化，有新的连接到来，则accept新的连接</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//有客户端连接请求到来  tmpfds是内核返回的值，才可以知道有没有可读事件发生</span></span><br><span class="line">          <span class="comment">//FD_ISSET判断有lfd才会有accept生成cfd，下边FD_ISSET有cfd才会通信</span></span><br><span class="line">          <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmpfds))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//接受新的客户端连接请求</span></span><br><span class="line">              cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//将cfd加入到readfds集合中</span></span><br><span class="line">              FD_SET(cfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(max&lt;cfd)</span><br><span class="line">              &#123;</span><br><span class="line">                  maxfd = cfd;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//有客户端数据发来 可能多个客户端需要用for</span></span><br><span class="line">          <span class="keyword">for</span>(i=lfd+<span class="number">1</span>; i&lt;=maxfd; i++)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span>(FD_ISSET(i, &amp;tmpfds))</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">//read数据  </span></span><br><span class="line">                  <span class="comment">//***只要是内核告诉你有数据可读 就不会阻塞 还有accept也不会阻塞</span></span><br><span class="line">                  n=read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      close(i);</span><br><span class="line">                      <span class="comment">//将文件描述符i从内核中除去</span></span><br><span class="line">                      FD_CLR(i, &amp;readfds);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//write应答数据给客户端</span></span><br><span class="line">                  write(i, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">   close(lfd);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码优化方向：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> client [<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>()</span><br><span class="line">    &#123;</span><br><span class="line">       client[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">1</span>将<span class="string">&quot;通信&quot;</span>文件描述符保存到一个整型的数组中，使用一个变量记录数组中最大元素的下标maxi</span><br><span class="line">    <span class="number">2</span>如果数组中有无效的文件描述符，直接跳过</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先找位置，然后将新的连接的文件描述符保存到connfd数组中</span></span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(connfd[i]==<span class="number">-1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            connfd[i] = cfd;</span><br><span class="line">    	      <span class="comment">//不加break会一直找到最后一个</span></span><br><span class="line">    	      <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     ```  </span><br><span class="line">     ***为什么没在read函数里边加<span class="keyword">while</span>循环？如果加入<span class="keyword">while</span>循环可能进入阻塞，对方数据量比较大，可能没有一次行读完，希望读完，读完之后对方关闭，然后read阻塞，阻塞之后select函数不能执行到</span><br><span class="line"><span class="number">18.</span> 使用epoll模型开发服务器流程:  </span><br><span class="line">    ```c</span><br><span class="line">    <span class="number">1</span> 创建scoket，得到监听文件描述符lfd----socket()</span><br><span class="line">    <span class="number">2</span> 设置端口复用----setsockopt()</span><br><span class="line">    <span class="number">3</span> 绑定----bind()</span><br><span class="line">    <span class="number">4</span> 监听----listen()</span><br><span class="line">    <span class="number">5</span> 创建一棵epoll树</span><br><span class="line">      <span class="keyword">int</span> epfd = epoll_create();</span><br><span class="line">    <span class="comment">//将监听文件描述符lfd对应的事件节点上树</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">      ev.events = EPOLLIN; <span class="comment">//可读事件</span></span><br><span class="line">      ev.data.fd = lfd;</span><br><span class="line">      epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//循环等待事件的发生   </span></span><br><span class="line">         <span class="comment">//函数执行完内核就会把客户端的请求或者传送数据信息存到events数组中</span></span><br><span class="line">         nready = epoll_wait(epfd, events, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">         <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(error == EINTR)<span class="comment">//信号被中断</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            sockfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">//有客户端连接请求到来</span></span><br><span class="line">            <span class="keyword">if</span>(sockfd ==lfd)</span><br><span class="line">            &#123;</span><br><span class="line">               cfd==accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">               <span class="comment">//将cfd对应的读事件上epoll树</span></span><br><span class="line">               ev.data.fd = lfd;</span><br><span class="line">               ev.events = EPOLLIN;</span><br><span class="line">               epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有客户端发送数据来</span></span><br><span class="line">            n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               close(sockfd);</span><br><span class="line">               <span class="comment">//将socket对应的事件节点从epoll树上删除</span></span><br><span class="line">               epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">               perror(<span class="string">&quot;read erroe or client closed&quot;</span>);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//printf(&quot;n==[%d],buf==[%s]\n&quot;, n,buf)</span></span><br><span class="line">               <span class="comment">//回车也算一个字符</span></span><br><span class="line">               write(sockfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Close(epfd);</span><br><span class="line">      close(lfd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure></li>
<li><p>使用poll模型开发服务端流程:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket, 得到监听文件描述符lfd----socket()</span><br><span class="line"><span class="number">2</span> 设置端口复用----setsockopt()</span><br><span class="line"><span class="number">3</span> 绑定----bind()</span><br><span class="line"><span class="number">4</span> 监听----listen()</span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[1024];</span></span><br><span class="line">  client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">  client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">  <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	client[i].fd = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将要监控的文件描述符拷贝到内核中，</span></span><br><span class="line">    <span class="comment">//并且内核那些程序文件描述符变化也要拷贝到参数中</span></span><br><span class="line">  	nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  	<span class="comment">//异常情况</span></span><br><span class="line">  	<span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="keyword">if</span>(errno==EINTR)  <span class="comment">// 被信号中断</span></span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">//有客户端连接请求到来</span></span><br><span class="line">  	<span class="keyword">if</span>(client[<span class="number">0</span>].revents==POLLIN)</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="comment">//接受新的客户端连接</span></span><br><span class="line">  		cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	</span><br><span class="line">  		<span class="comment">//寻找在client数组中可用位置</span></span><br><span class="line">        <span class="comment">//***寻找client数组中的可用位置 由于if条件已经确定client[0]是lfd，  </span></span><br><span class="line">        <span class="comment">//所以循环从1开始</span></span><br><span class="line">  		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">if</span>(client[i].fd==<span class="number">-1</span>)</span><br><span class="line">  			&#123;</span><br><span class="line">  				client[i].fd = cfd;</span><br><span class="line">  				client[i].events = POLLIN;</span><br><span class="line">  				<span class="keyword">break</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//客户端连接数达到最大值</span></span><br><span class="line">  		<span class="keyword">if</span>(i==<span class="number">1024</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			close(cfd);</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//修改client数组下标最大值</span></span><br><span class="line">  		<span class="keyword">if</span>(maxi&lt;i)</span><br><span class="line">  		&#123;</span><br><span class="line">  			maxi = i;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">//下面是有客户端发送数据的情况  0是监听文件描述符</span></span><br><span class="line">  	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=maxi; i++)</span><br><span class="line">  	&#123;</span><br><span class="line">  		sockfd = client[i].fd;</span><br><span class="line">  		<span class="comment">//如果client数组中fd为-1, 表示已经不再让你内核监控了, 已经close了</span></span><br><span class="line">  		<span class="keyword">if</span>(client[i].fd==<span class="number">-1</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;	</span><br><span class="line">  		<span class="keyword">if</span>(client[i].revents==POLLIN)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="comment">//read 数据</span></span><br><span class="line">  			n = read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  			<span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">  			&#123;</span><br><span class="line">  				close(sockfd);</span><br><span class="line">  				client[i].fd = <span class="number">-1</span>;		</span><br><span class="line">  			&#125;</span><br><span class="line">  			<span class="keyword">else</span> </span><br><span class="line">  			&#123;</span><br><span class="line">  				<span class="comment">//发送数据给客户端</span></span><br><span class="line">  				write(sockfd, buf, n);</span><br><span class="line">  			&#125; 			</span><br><span class="line">	  		<span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">	  		&#123;</span><br><span class="line">	  			<span class="keyword">break</span>;</span><br><span class="line">	  		&#125;	</span><br><span class="line">  		&#125;  		</span><br><span class="line">  	&#125;  	</span><br><span class="line">  &#125;</span><br><span class="line">  close(lfd); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><br>函数说明: 跟select类似, 委托内核监控可读, 可写, 异常事件<br>函数参数:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">	 fds: 一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>结构体数组的首地址</span></span><br><span class="line"><span class="class">	   <span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	      <span class="keyword">int</span>   fd;    <span class="comment">//要监控的文件描述符,如果fd为-1, 表示内核不再监控</span></span><br><span class="line">	      <span class="keyword">short</span> events; <span class="comment">//输入参数, 表示告诉内核要监控的事件,   </span></span><br><span class="line">          <span class="comment">//读事件, 写事件, 异常事件  </span></span><br><span class="line">	      <span class="keyword">short</span> revents;<span class="comment">//输出参数, 表示内核告诉应用程序有哪些文件描述符有事件发生    </span></span><br><span class="line">	   &#125;;</span><br><span class="line">	   events/revents:</span><br><span class="line">	   	 POLLIN:可读事件</span><br><span class="line">	   	 POLLOUT: 可写事件</span><br><span class="line">	   	 POLLERR: 异常事件</span><br><span class="line">	 nfds: 告诉内核监控的范围, 具体是: 数组下标的最大值+<span class="number">1</span> </span><br><span class="line">	 timeout: </span><br><span class="line">		=<span class="number">0</span>: 不阻塞, 立刻返回</span><br><span class="line">		<span class="number">-1</span>: 表示一直阻塞, 直到有事件发生</span><br><span class="line">		&gt;<span class="number">0</span>: 表示阻塞时长, 在时长范围内若有事件发生会立刻返回; </span><br><span class="line">			如果超过了时长也会立刻返回    </span><br><span class="line">     函数返回值:  </span><br><span class="line">      &gt;<span class="number">0</span>: 发生变化的文件描述符的个数  </span><br><span class="line">      =<span class="number">0</span>: 没有文件描述符发生变化  </span><br><span class="line">      <span class="number">-1</span>: 表示异常</span><br><span class="line">    ```  </span><br><span class="line">    ***poll和select区别就是：  </span><br><span class="line">    <span class="number">1.</span> 一个用集合位图结合具体的宏从变化中读取事件(FD_ISSET(lfd, &amp;tmpfds)确定的是读事件)，一个用结构体数组</span><br><span class="line">    <span class="number">2.</span> select需要将cfd加入到select监控的文件描述符集合中，FD_SET(cfd, &amp;rdfds);</span><br><span class="line">    <span class="number">3.</span> epoll会告诉具体哪个文件描述符发生变化</span><br><span class="line"><span class="number">21.</span> epoll模型  </span><br><span class="line">    ```c</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    函数说明：创建一棵epoll树，返回一个树根节点</span><br><span class="line">    函数参数：size：必须传一个大于<span class="number">0</span>的数</span><br><span class="line">    返回值：返回个文件描述符，这个文件描述符就表示epoll树的树根节点</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    函数说明：将fd上epoll树，从树上删除和修改</span><br><span class="line">    函数参数：epfd：epoll树的树根节点 </span><br><span class="line">       op：EPOLL_CTL_ADD: 添加事件节点到树上</span><br><span class="line">       EPOLL_CTL_DEL: 从树上删除事件节点 </span><br><span class="line">       EPOLL_CTL_MOD: 修改树上对应的事件节点</span><br><span class="line">       fd:要操作的文件描述符</span><br><span class="line">       event：</span><br><span class="line">          event.events: EPOLLIN 可读事件；EPOLLOUT 可写事件；EPOLLERR: 错误事件</span><br><span class="line">          event.fd：委托内核监控的文件描述符</span><br><span class="line">       <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">          <span class="keyword">void</span> *ptr;</span><br><span class="line">          <span class="keyword">int</span> fd;</span><br><span class="line">          <span class="keyword">uint32_t</span> u32;</span><br><span class="line">          <span class="keyword">uint64_t</span> u64;</span><br><span class="line">       &#125;<span class="keyword">epoll_data_t</span>;</span><br><span class="line">          <span class="comment">//结构体相当于一个事件节点 ，可以上树操作</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">          <span class="keyword">unit32_t</span> events; </span><br><span class="line">          <span class="keyword">epoll_data_t</span> data;</span><br><span class="line">       &#125;;</span><br><span class="line">       eg: <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">          ev.events = EPOLLIN;</span><br><span class="line">          ev.data.fd = fd;</span><br><span class="line">          epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> Timeout)</span></span>;</span><br><span class="line">    ```  </span><br><span class="line">    函数说明：委托内核监控epoll树的事件节点  </span><br><span class="line">    函数参数：epfd：epoll树根节点  </span><br><span class="line">    events：传出参数，结构体数组  传出参数, 调用epoll_ctl传递给内核什么值，  </span><br><span class="line">    当epoll_wait返回的时候, 内核就传回什么值,不会对<span class="class"><span class="keyword">struct</span> <span class="title">event</span>的结构体变量的值做任何修改但是<span class="title">select</span>和<span class="title">poll</span>会对内核中<span class="title">rdfds</span>改变 所以用临时变量<span class="title">tmpfds</span>  </span></span><br><span class="line"><span class="class">    <span class="title">maxevents</span>：<span class="title">events</span>数组大小  </span></span><br><span class="line"><span class="class">    <span class="title">Timeout</span>：-1 表示阻塞  0 表示不阻塞  &gt;</span><span class="number">0</span> 表示阻塞超时时长  </span><br><span class="line">    epoll_wait 返回的数组中的事件节点的值不会修改，是当时上epoll树的时候设置的值</span><br><span class="line"><span class="number">22.</span> epoll的LT和ET模式:</span><br><span class="line">	<span class="number">1.</span> epoll默认情况下是LT模式, 在这种模式下, 若读数据一次性没有读完,</span><br><span class="line">	  缓冲区中还有可读数据, 则epoll_wait还会再次通知</span><br><span class="line">	<span class="number">2.</span> 若将epoll设置为ET模式, 若读数据的时候一次性没有读完, 则epoll_wait不再通知,</span><br><span class="line">	  直到下次有新的数据发来.  </span><br><span class="line">     比如服务端只能读两个字节，但是客户端传<span class="number">1122334455</span>，ET模式下，第一次读<span class="number">11</span> 数据就不读了  </span><br><span class="line">     后边回车相当于发新的数据了，epoll_wait继续返回，读剩下的数据<span class="number">22</span>   </span><br><span class="line">     </span><br><span class="line">     思考:</span><br><span class="line">	<span class="number">1.</span> 在ET模式下, 如何在epoll_wait返回一次的情况下读完数据?</span><br><span class="line">		循环读数据, 直到读完数据, 但是读完数据之后会阻塞.</span><br><span class="line">	<span class="number">2.</span> 若能够一次性读完还需要设置什么? </span><br><span class="line">		将通信文件描述符设置为非阻塞模式</span><br><span class="line"><span class="number">23.</span> select支持跨平台  epoll不支持跨平台  </span><br><span class="line">    linux系统中用epoll   </span><br><span class="line">    unix环境下用select</span><br><span class="line">## 高并发服务器线程池源码分析</span><br><span class="line"><span class="number">1.</span> 调用offset函数测试结构体成员变量的偏移量  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">s</span> </span></span><br><span class="line"><span class="class">   	&#123;</span></span><br><span class="line">   		<span class="keyword">int</span> i;</span><br><span class="line">   		<span class="keyword">char</span> c;</span><br><span class="line">   		<span class="keyword">double</span> d;</span><br><span class="line">   		<span class="keyword">char</span> a[<span class="number">1</span>];</span><br><span class="line">   	&#125;;</span><br><span class="line">   	<span class="comment">/* Output is compiler dependent */</span></span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;offsets: i=%zd; c=%zd; d=%zd a=%zd\n&quot;</span>,</span><br><span class="line">   			offsetof(struct s, i), offsetof(struct s, c),</span><br><span class="line">   			offsetof(struct s, d), offsetof(struct s, a));</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct s)=%zd\n&quot;</span>, <span class="keyword">sizeof</span>(struct s));</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>udp通信服务端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">    cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 绑定-bind</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  n = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  sendto(cfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;client, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span> 关闭socket套接字</span><br><span class="line">  close(cfd);</span><br><span class="line">udp通信客户端开发流程：</span><br><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">    cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  sendto(cfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;client, len);</span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  n = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span> 关闭套接字</span><br><span class="line">    close(cfd);</span><br></pre></td></tr></table></figure></li>
<li><p>//模拟循环队列<br><code>int taskpos = (pool-&gt;job_push++)%pool -&gt;max_job_num;</code><br>addtask(thrPool);//添加任务到线程池结构体中的任务池结构体中<br>其中thrPool是共享结构体ThreadPool，需要加锁<br>if(thrPool-&gt;job_num)表示如果thrPool-&gt;job_num&gt;0满足条件<br>如果子线程设置分离属性，可以不用pthread_join函数<br>pthread_cond_wait函数的隐含操作：如果条件不满足阻塞解锁，条件满足加锁<br>用do while可以避免使用goto，而且do while可以使用break if语句不行<br>如果子线程设置非分离属性，主线程需要用pthread_join函数可以保证主线程比子线程后退出</p>
</li>
<li><p>UDP天然支持多个客户端 udp那个案例服务端只能收发 ，不能发收数据<br>本地socket通信：<br>隐含操作：当调用bind函数完成与一个文件绑定之后，会在本地创建一个文件，文件大小为0<br>本地域socket通信服务端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">  lfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 绑定</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">  bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">  serv.sun_family = AF_UNIX;</span><br><span class="line">  <span class="comment">//这个文件不要求一开始就存在，如果一开始就存在反而会报错</span></span><br><span class="line">  <span class="built_in">strcpy</span>(serv.sun_path, <span class="string">&quot;./serv.sock&quot;</span>);</span><br><span class="line">  bind(lfd, (struct sockaddr*)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"><span class="number">3</span> 监听--- listen();</span><br><span class="line"><span class="number">4</span> 接收新的客户端连接---cfd = accept()</span><br><span class="line"><span class="number">5</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//读数据---read();</span></span><br><span class="line">   <span class="keyword">if</span>(error)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//发送数据---write();</span></span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line">close(lfd);</span><br></pre></td></tr></table></figure></li>
<li><p>本地域socket通信客户端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">  lfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 连接服务端--connect</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//发送数据---write();</span></span><br><span class="line">   <span class="comment">//读数据---read();</span></span><br><span class="line">   <span class="keyword">if</span>(error)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span> close(cfd);  </span><br></pre></td></tr></table></figure></li>
<li><p>UDP通信相关函数介绍:<br><code>ssize_t recvfrom函数是阻塞函数</code><br><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</code><br><code>struct sockaddr *src_addr, socklen_t *addrlen);</code><br><code>sockfd 套接字：调用socket返回的文件描述符 不是lfd和cfd</code> </p>
</li>
<li><p>#ifndef _THREADPOOL_H<br>避免重复包含<br>线程编译的时候要用末尾要加 -lpthread<br>客户端不绑定地址，服务器不会打印地址。不同于ip和端口绑定，客户端不用绑定，服务器端可以直接打印系统默认给客户端分配的ip和端口</p>
</li>
<li><p>线程池：<img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%AB%98%E5%B9%B6%E5%8F%917.png" alt="avatar"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ckp3biliq00094sue66wd13x8" data-title="Linux网络编程-高并发服务器" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux系统编程-信号" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T00:35:25.212Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/">Linux系统编程-信号</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux系统编程-信号"><a href="#Linux系统编程-信号" class="headerlink" title="Linux系统编程-信号"></a>Linux系统编程-信号</h2><ol>
<li><p>信号相关函数：<br>一、signal函数：<br>函数作用：注册信号捕捉函数 ；给内核注册信号处理函数。<br>理解：完成信号的注册，注册一个用户自定义的函数。也就是说信号就要发生了，就会去调用信号处理函数，这个信号处理函数是用户自己写的。也就是说自己写的信号处理函数还需要signal注册，才能让信号知道执行哪个函数。<br>函数原型<br><code>typedef void (*sighandler_t)(int); //定义函数指针 可以作为回调函数</code><br><code>sighandler_t signal(int signum, sighandler_t handler);</code><br>函数参数<br>signum：信号编号 使用的时候不要用数字 用宏<br>sighandler_t handler是信号处理函数的函数名，函数名就是函数的首地址，就是指针<br>sighandler_t：函数指针  其中int类型就是信号的编号<br>handler其实也算是回调函数 ，singal函数会把这个函数拉到内核中执行， 严格上说signal是给内核注册一个信号函数<br>handler：信号处理函数<br>二、kill函数：<br>函数作用：发送指定信号给指定进程<br>kill命令：<code>kill -SIGKILL 进程PID</code><br>kill函数原型：<code>int kill(pid_t pid, int sig);</code><br>sig信号参数：不推荐直接使用数字，应使用宏名，因为不同操作系统信号编号可能不同，但名称一致。<br>pid参数：  </p>
<ul>
<li>pid &gt; 0: 发送信号给指定的进程。</li>
<li>pid = 0: 发送信号给与调用kill函数进程属于同一进程组的所有进程。</li>
<li>pid &lt; -1:  取|pid|发给对应进程组。</li>
<li>pid = -1：发送给进程有权限发送的系统中所有进程。</li>
</ul>
<p>三、raise函数：<br>函说描述：给当前进程发送指定信号(自己给自己发)<br>函数原型：<code>int raise(int sig);</code><br>函数返回值：成功：0，失败非0值<br>函数拓展：<code>raise(signo) == kill(getpid(), signo);</code><br>四、abort函数<br>函数描述：给自己发送异常终止信号  6) SIGABRT，并产生core文件<br>函数原型：<code>void abort(void);</code><br>函数拓展：<code>abort() == kill(getpid(), SIGABRT);</code><br>五、alarm函数<br>函数原型：<code>unsigned int alarm(unsigned int seconds);</code><br>函数描述：<br>设置定时器(闹钟)。在指定seconds后，内核会给当前进程发送14）SIGALRM信号。进程收到该信号，默认动作终止。  </p>
<ul>
<li>每个进程都有且只有唯一的一个定时器。如果有两个定时器，后边的会覆盖前边的</li>
<li>alarm函数的返回值：0或者是上一个alarm剩余的秒数</li>
<li>alarm(0)：取消定时器</li>
<li>alarm函数发送的是SIGALRM信号</li>
</ul>
<p>[88573]Alarm clock<br>实际执行时间 = 系统时间 + 用户时间 + 损耗时间  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[%d]\n&quot;</span>,i++);<span class="comment">//结果80000次</span></span><br><span class="line">real	<span class="number">0</span>m1<span class="number">.001</span>s</span><br><span class="line">user	<span class="number">0</span>m0<span class="number">.007</span>s</span><br><span class="line">sys	<span class="number">0</span>m0<span class="number">.269</span>s</span><br></pre></td></tr></table></figure>
<p>损耗时间=实际执行时间-（系统时间 + 用户时间）=0.8s<br>文件重定向之后</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">time ./alarm_uncle &gt;test.<span class="built_in">log</span> <span class="comment">//结果8000000次</span></span><br><span class="line">real	<span class="number">0</span>m1<span class="number">.002</span>s</span><br><span class="line">user	<span class="number">0</span>m0<span class="number">.051</span>s</span><br><span class="line">sys	<span class="number">0</span>m0<span class="number">.941</span>s</span><br></pre></td></tr></table></figure>
<p>损耗时间=实际执行时间-（系统时间 + 用户时间）=0.01s<br>损耗时间==user(用户)和sys(内核)切换的时间 比如write和sys/write之间切换<br>原因是：调用printf函数打印数字遇到\n才会打印，打印过程涉及到从用户区到内核区的切换，切换次数越多消耗的时间越长，效率越低；而使用文件重定向，由于操作的带缓冲的，所以涉及到用户区到内核区的切换次数大大减少，从而使损耗降低。</p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B71.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B73.png" alt="avatar"></li>
<li>后一个alarm会取代前面的alarm,alarm(1)，一秒钟之后会执行sighandler函数</li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B72.png" alt="avatar"></li>
</ul>
</li>
<li><p>信号的状态<br>信号的产生：<br>按键产生，<br>Ctrl+c 终止进程 只有进程阻塞在终端上，才好用   产生SIGINI 信号<br>Ctrl+z 挂起 不在终端上了 按Ctrl+c不好用<br>Ctrl+\ 使进程退出<br>系统调用产生，如：kill、raise(发送信号给当前进程)、abort(使进程终止)<br>软件条件产生(软中断)，如：定时器alarm    每个进程都有唯一的定时器<br>硬件异常产生(硬中断)，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)<br>命令产生，如：kill命令<br>未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。<br>递达：递送并且到达进程。<br>信号的处理方式<br>执行默认动作  Term<br>忽略信号(丢弃不处理)  ignore<br>捕捉信号(调用用户的自定义的处理函数)  signal<br>信号的特质<br>信号的实现手段导致信号有很强的延时性<br>文件描述符表，还包含了信号相关的信息，主要指阻塞信号集和未决信号集。<br>信号的四要素  </p>
<ul>
<li>信号的编号</li>
<li>信号的名称</li>
<li>产生信号的事件</li>
<li>信号的默认处理动作</li>
</ul>
<p>特别需要注意的是：<code>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</code><br>几个常用到的信号：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SIGINT(ctrl+c)、SIGQUIT(ctrl+\，使进程退出)、SIGKILL(进程终止，不能被捕获)、</span><br><span class="line">SIGSEGV(非法访问内存，段溢出)、SIGUSR1、SIGUSR2(系统留给我们自己的)、SIGPIPE、</span><br><span class="line">SIGALRM、SIGTERM(进程终止，可以被捕获)、SIGSTOP、SIGCONT、</span><br><span class="line">SIGCHLD(子进程退出之后给父进程发信号，父进程收到信号回收子进程)、</span><br></pre></td></tr></table></figure></li>
<li><p>setitimer函数：<br>函数原型<br><code>int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</code><br>函数参数：<br>which：指定定时方式<br>自然定时：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ITIMER_REAL → <span class="number">14</span>）SIGALRM计算自然时间</span><br><span class="line">new_value：<span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span>, 负责设定<span class="title">timeout</span>时间。</span></span><br><span class="line"><span class="class"><span class="title">itimerval</span>.<span class="title">it_value</span>:</span> 设定第一次执行function所延迟的秒数 </span><br><span class="line">itimerval.it_interval: 设定以后每几秒执行function</span><br></pre></td></tr></table></figure>

<p>old_value： 存放旧的timeout值，一般指定为NULL<br>***函数没有终止是因为SIGALRM信号被signal捕获了，捕获了的意义就是按照我的方式来，就不会执行默认Term终止动作。<br>***用结构体的好处就是可以存放更多的信息 减少声明变量<br>比如：如果2个结构体存放4个相同的变量，这样的话结构体需要声明6个变量，不用结构体需要声明8个变量<br>代码实现：    </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sighandler</span><span class="params">(<span class="keyword">int</span> signo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;signo==[%d]\n&quot;</span>,signo);</span><br><span class="line">&#125;   </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注册信号 SIGALAM信号处理函数</span></span><br><span class="line">    signal(SIGALRM,sighandler); </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">itimerval</span> <span class="title">tm</span>;</span> </span><br><span class="line">    <span class="comment">//周期性时间赋值  </span></span><br><span class="line">    tm.it_interval.tv_sec=<span class="number">1</span>;</span><br><span class="line">    tm.it_interval.tv_usec=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//第一次触发时间</span></span><br><span class="line">    tm.it_value.tv_sec=<span class="number">3</span>;</span><br><span class="line">    tm.it_value.tv_usec=<span class="number">0</span>;</span><br><span class="line">    setitimer(ITIMER_REAL,&amp;tm,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//如果没有这个while循环 signal会自动终止进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//函数没有终止是因为SIGALRM信号被signal捕获了，捕获了的意义就是按照我的方式来，就不会执行默认Term终止动作。并且函数执行完回到刚才信号发生的代码位置继续执行。也就是while(1)之前的位置<br>然后按ctrl+c终止进程，SIGINT信号没有被捕获 所以执行终止</p>
</li>
<li><p>printf中要写”\n”：printf遇到“\n”才会打印，或者缓冲区满了才打印</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line"> &#123;   </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%d]\n&quot;</span>,i++);<span class="comment">//每一个数字都需要用户和内核的切换</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;[%d]&quot;</span>,i++);<span class="comment">//缓冲区打满了才发生用户和内核的切换</span></span><br><span class="line">    <span class="comment">//下边的要比上边打印的数字多</span></span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>
<p>time ./alarm_uncle &gt; test.log 文件重定向，输出到文件 相当于第二种，因为写文件操作带缓冲（缓冲满了存到文件中）<br>如果写文件操作要用fopen fread fclose操作 不要用open read 。前者带缓冲效率高</p>
</li>
<li><p>信号都是事先约定好的<br>信号的优先级要高于普通操作<br>kill -l 查看信号的命令<br>kill发信号的时候<br>1，要说明发的哪个信号(信号的编号)<br>2，还有给哪个进程(pid)发信号<br>实现过程：进程A通过kill已经告诉内核要给谁发信号，内核就知道给谁转发信号，转给进程B  </p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B74.png" alt="avatar"></li>
</ul>
</li>
<li><p>man 7 signal 信号相关的所有信息<br>bash ：开启一个终端就会产生一个bash的进程，是默认的进程<br>如果A进程知道B进程中的pid，所以A进程可以给B进程发信号，但是必须是在同一用户下<br>man手册中的”(2)”什么意思：<br><code>alarm（2）代表man 2 alarm</code><br><code>abort（3）代表man 3 abort</code><br>***开发过程中看见参数前加coust一定是输入 因为传入的不能改<br><code>int setitimer(int which, const struct itimerval *new_value,struct itimerval *old_value);</code><br>***函数声明中看到什么old参数都是传出参数</p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B75.png" alt="avatar"></li>
</ul>
</li>
<li><p>SIGCHLD信号：！！！这个超级重点代码在备注里  </p>
<ol>
<li>SIGCHLD信号的产生条件：<br>子进程收到SIGSTOP，SIGCONT<br>子进程退出</li>
<li>SIGCHLD信号的作用：<br>子进程退出之后，内核会给其父进程发送SIGCHLD信号，父进程收到这个信号之后，<br>调用waitpid或者wait完成对子进程的回收  </li>
<li>sigchld.c：<ul>
<li>有可能还没有完成对SIGCHLD信号的注册，三个子进程就全部退出了<br>解决办法：在fork之前先将SIGCHLD信号阻塞，然后在完成对SIGCHLD信号的注册之后<br>解除对SIGCHLD信号的阻塞；  </li>
<li>有可能在SIGCHLD信号处理函数执行期间，另外的2个子进程同时全部退出，此时会出现一个僵尸进程。  </li>
<li>解决办法：在信号处理函数中应该循环回收，当waitpid返回-1的时候就已经回收完  </li>
<li>所有子进程了，此时可以break；</li>
</ul>
</li>
</ol>
</li>
<li><p>从3中知道调用哪个函数是由用户注册决定的，内核调用我们自己写的函数，怎么做我们说的算，什么时候做内核说的算，这就是回调函数<br>要想处理信号必须进入内核，用户调用系统函数，系统函数很多都可以进入内核<br>可以进系统内核的函数有哪类：<br><code>read write  sigprocmask printf</code>  I/O操作 sleep(1)里边调用alarm可以进入内核 阻塞的函数都可以进入内核<br>注意：</p>
<ol>
<li>谁调用回调函数，就回到谁的位置:比如：4运行完返回内核，5调用完返回到用户中断处</li>
<li>函数调用最终要压栈，函数完成之后要弹栈 弹到调用者的位置。</li>
<li>信号有一定延时性</li>
</ol>
<ul>
<li> <img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B76.png" alt="avatar">  </li>
</ul>
</li>
<li><p>进程间通讯不要用信号，但是信号可以实现两个进程之间通讯<br>主要是用到信号的两个函数：signal函数，sigaction函数，然后写个信号处理函数，函数中完成数据库断开链接、释放资源、收到异常信号退出进程<br>阻塞函数（sleep alarm）遇到信号之后都会被中断<br>被信号中断都会产生错误：EINTR interrupted function call<br>SIGCHLD函数中要将SIGCHLD信号阻塞写在前边，防止sigaction完成注册以前全部退出</p>
</li>
<li><p>信号集<br>数据集它的变量是sigset_t数据类型变量是用typedef定义的，可以想象成int<br>未决信号集那个框就是sigset_t变量，它里边有很多位，每个位上只有两种值0(没有)、1(有)<br>涉及到位操作只有0,1两种值<br>sigset_t类型是unsigned long int，其中int四个字节，long int 8个字节 64位，kill -l 显示正好64种信号 一位一编号<br>信号阻塞期间信号产生多次，当解开阻塞后，信号只处理一次，不支持排队<br>信号集存在内核中的PCB中。<br>信号集相关函数：  </p>
<pre><code class="c">  int sigemptyset(sigset_t *set);
  int sigfillset(sigset_t *set);    
  int sigaddset(sigset_t *set, int signum);    
  int sigdelset(sigset_t *set, int signum);    
  int sigismember(const sigset_t *set, int signum);
</code></pre>
<p>  以上函数都是在栈上操作的<br>  sigprocmask函数：  操作的内核<br>  函数说明：用来屏蔽信号、解除屏蔽也使用该函数。其本质，读取或修改进程控制块中的信号屏蔽字（阻塞信号集）<br>  函数参数：set传入参数<br>  sigpending函数：<br>  函数说明：读取当前进程的未决信号集；将内核中的未决信号集拷贝出来，拷贝到栈上的 sigset_t set中<br>  函数参数：set传出参数。<br>  要想使用信号集，第一步先定义sigset_t类型变量  </p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/%E4%BF%A1%E5%8F%B77.png" alt="avatar"></li>
</ul>
</li>
<li><p>信号捕捉函数： ***主要是用到信号的两个函数<br>signal函数：<br>sigaction函数：<br>特别需要注意的是：The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.<br>typedef void (*sighandler_t)(int); //定义函数指针 可以作为回调函数<br>函数原型：int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);<br>函数参数：<br>signum：捕捉的信号<br>act：    传入参数，新的处理方式。<br>oldact： 传出参数，旧的处理方式    </p>
<pre><code class="c">struct sigaction &#123;
    void  (*sa_handler)(int);    // 信号处理函数
    sigset_t  sa_mask; //信号处理函数执行期间需要阻塞的信号
    int      sa_flags; //通常为0，表示使用默认标识
&#125;;
</code></pre>
<p>   注意：  </p>
<ol>
<li>在xxx信号处理函数执行期间，若xxx信号再次产生多次，则信号处理函数不会被打断，当信号处理函数执行完成之后，后来产生的信号只会被处理一次，信号不支持排队</li>
<li>在xxx信号处理函数执行期间（前提是sa_mask中阻塞了yyy信号）,若收到了yyy信号，则yyy信号会被阻塞,当xxx信号处理函数执行完毕后，则yyy信号会被处理一次。</li>
<li>在xxx信号处理函数执行期间（前提是sa_mask中没有阻塞yyy信号）,若收到了yyy信号，会先执行yyy信号</li>
</ol>
</li>
<li><p>sigprocmask函数将信号添加到阻塞信号集中<br>代表进程已经阻塞掉添加的信号到未决信号集中，暂时不需要处理<br>sigaction函数通过sigemptyset或者sigaddset函数将信号存在sigset_t (64位)中<br>然后阻塞信号处理函数执行期间要阻塞的信号<br>这两种都不支持排队<br>avoid避免<br>top命令查看 cpu状态<br>定义在栈上变量不初始化就是随机值<br>定义在全局或者staitc变量默认为零<br>所以栈上定义一个值 开始不用，可以先等于NULL</p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" data-id="ckp3bili800004sueafrj269d" data-title="Linux系统编程-信号" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux系统编程-守护进程-线程-网络概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T00:35:25.212Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/">守护进程-线程-网络基本概念</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h2><ol>
<li>线程：LWP(light weight process)<ol>
<li>系统分配资源的最基本单位是：进程</li>
<li>系统调度最基本单位是：进程</li>
<li>线程的创建过程就是复制出一个PCB(文件描述符不同)，多个线程是共享文件描述符，不是复制出来的,是共享<br>文件描述符共享：主线程和子线程都打开文件，子线程可以读到主线程写的文件，因为是同一个<br>相当于在同一命名空间下，每个类中都可以共享一个static int name的全局变量，但是每个类中name不同</li>
<li>通过使用线程号来区分不同的线程</li>
<li>多个子线程和主线程共享一个地址空间 有一个PID(都在一个进程里，一块地址空间中) 一个地址空间只有一个pid</li>
<li>用户区中除了栈空间以外，其余资源都可以共享<br>特殊情况共享：<ol>
<li>这种共享是通过pthread_create函数的pthread_t参数传递指针出去的  比如 main中 int i 在子线程中可以用</li>
<li>假如在main中 “{ int arr[5]； }”这就代表arr生命周期到”}”就结束了，所以arr[5]在栈上就不能被子线程读取，<br>如果把“{ int arr[5]； }”中的括号去掉，代表arr和main一个生命周期，而且还sleep，所以可以被子线程读取</li>
<li>主要是说线程执行函数中每个子线程可以创建自己的变量，然后里边的变量是不能够被其他线程读取的 不提倡用全局变量指针</li>
<li>主要是这块内存的生存期足够长，在读取时有效就可以共享</li>
</ol>
</li>
<li>主线程和子线程谁先抢到CPU时间片，谁先执行</li>
<li>创建现成的函数不是系统调用，是C语言的库函数</li>
<li>对于内核而言有几个PCB就有几个线程</li>
<li>信号处理函数也共享<br>查看指定线程的LWP号： ps -Lf pid<br>线程非共享资源：    </li>
</ol>
   ****线程id是给程序员看的 线程号是给内核看的<br>   信号屏蔽字(很少在线程中使用信号，因为太复杂出了问题很难找到)<br>   errno变量（让别的线程共享不安全，因为一个线程改了别的线程也看到了结果，用strerror函数）<br>   一般开发中：1 做业务处理 数据库操作用进程 2 做数据通讯 网络通信用线程<br>   个人理解：可以理解为拥有不同的PCB线程在一个地址空间中，共享着进程里的资源  类似共享着全局变量<br>   也可以理解为在一个地址空间中复制出来拥有不同PCB的线程，他们的资源同步</li>
<li>线程相关函数:这一些列线程相关函数的返回值：都是成功返回0 失败返回错误号<ol>
<li>创建子线程：pthread_create函数<br>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印</li>
<li>线程退出：pthread_exit函数<br>在线程中进制调用exit函数，会将整个进程退出</li>
<li>回收子线程：pthread_join函数 阻塞的  </li>
</ol>
***写在主线程中 等待子进程退出之后再退出 保证主线程后退出。<br>&amp;p是&amp;t的二级指针 &amp;p指向&amp;t 也就是说p==&amp;t<ol start="4">
<li>设置子线程为分离属性：pthread_detach函数<br>如果子线程是分离状态，这样主线程在调用pthread_join函数就不会阻塞，立刻返回，但是不建议这么做<br>如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了</li>
</ol>
</li>
<li>在创建线程的时候设置线程属性为分离属性：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">   pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   n = number ；</span><br><span class="line">   n++；</span><br><span class="line">   number = n ；</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1：[%d]\n&quot;</span>,number)；</span><br><span class="line">   ```  </span><br><span class="line">   线程同步：  </span><br><span class="line">   互斥锁：线程A和线程B共同访问共享资源，当线程A想访问共享资源的时候，  </span><br><span class="line">   要先获得锁，如果锁被占用，则加锁不成功需要阻塞等待对方释放锁；  </span><br><span class="line">   若锁没有被占用，则获得锁成功--加锁，然后操作共享资源，操作完之后，  </span><br><span class="line">   必须解锁，同理B也是和A一样。  </span><br><span class="line">   --------&gt;也就是说，同时不能有两个线程访问共享资源，属于互斥操作  </span><br><span class="line">   注意：添加互斥锁时，两个线程中只有一个添加了锁，相当于没添加锁或者把钥匙给了另一个锁  </span><br><span class="line">   因为没添加锁的那线程默认mutex=<span class="number">1</span>，在添加锁的那个线程执行过程中还没执行完，交出cpu时间片，另一个线程也可以执行</span><br><span class="line"><span class="number">4.</span> 创建守护进程模型：</span><br><span class="line">   <span class="number">1.</span> 父进程fork子进程，然后父进程退出（<span class="keyword">if</span>（pid&gt;<span class="number">0</span>）&#123;<span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span>、<span class="number">2</span> <span class="built_in">exit</span>(<span class="number">0</span>)、<span class="number">3</span> kill自己）  </span><br><span class="line">   目的是：子进程肯定不是组长进程，为后续调用setsid函数提供条件</span><br><span class="line">   <span class="number">2.</span> 子进程调用setsid函数创建一个新的会话  </span><br><span class="line">   目的是：  </span><br><span class="line">   - 该子进程成了该会话的会长</span><br><span class="line">   - 该子进程成了该组的组长进程</span><br><span class="line">   - 不在受控制终端的影响了</span><br><span class="line">   <span class="number">3.</span> 改变当前进程的工作目录，chdir-------不是必须的</span><br><span class="line">   <span class="number">4.</span> 重设文件掩码，umask（<span class="number">0000</span>） ------不是必须的</span><br><span class="line">   <span class="number">5.</span> 关闭STDIN_FILENO STDOUT_FILENO STDERR_FILENO   --------不是必须的</span><br><span class="line">   <span class="number">6.</span> 核心操作  </span><br><span class="line">   编写一个守护进程，每隔<span class="number">2</span>S钟获取一次系统时间，并将这个时间写入磁盘文件：  </span><br><span class="line">   分析：首先要按照<span class="number">1.3</span>介绍的守护进程的步骤创建一个守护进程  </span><br><span class="line">   每隔<span class="number">2</span>S钟：使用setitimer函数设置时钟，该时钟发送的是SIGALARM信号，  </span><br><span class="line">   信号操作：注册信号处理函数，signal或者sigaction，还有一个信号处理函数  </span><br><span class="line">   获取一次系统时间：time函数的使用，ctime函数的使用  </span><br><span class="line">   写入磁盘文件：文件操作函数： open write close  </span><br><span class="line">   优化：</span><br><span class="line">   - 不再频繁的打开和关闭文件</span><br><span class="line">   - 如何控制<span class="built_in">log</span>文件大小 test.<span class="built_in">log</span> test.<span class="built_in">log</span><span class="number">.1</span> test.<span class="built_in">log</span><span class="number">.2</span></span><br><span class="line">   - ![avatar](/Linux系统编程-守护进程-线程-网络概念/守护进程<span class="number">1.</span>png)</span><br><span class="line"><span class="number">5.</span> 守护进程的特点：</span><br><span class="line">   <span class="number">1.</span> 一个linux后台服务进程</span><br><span class="line">   <span class="number">2.</span> 不依赖于控制终端</span><br><span class="line">   <span class="number">3.</span>  周期性执行某些任务</span><br><span class="line">   <span class="number">4.</span> 不受用户登陆和注销的影响</span><br><span class="line">   <span class="number">5.</span> 一般以d结尾</span><br><span class="line">   <span class="number">6.</span> 不能和用户通过控制终端进行交换  </span><br><span class="line">   进程组和会话：  </span><br><span class="line">   进程组：一个进程组包含多个进程  </span><br><span class="line">   会话：多个组组成一个会话  </span><br><span class="line">   创建会话的进程不能是组长进程；  </span><br><span class="line">   一般创建会话是父进程先fork子进程，然后父进程退出，让子进程调用setsid函数创建一个会话，这个子进程即使会长也是组长。只要是创建会话，这个进程就脱离了控制终端的影响</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span>和<span class="built_in">exit</span>的用法：</span><br><span class="line">   ```c</span><br><span class="line">   <span class="keyword">return</span>;<span class="comment">//不带返回值的return语句</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//带返回值的return语句,或者返回一个变量或一个函数。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span><span class="comment">//表示函数异常结束</span></span><br><span class="line">   <span class="keyword">return</span>;的作用相当于<span class="keyword">break</span>;用于中断循环的作用；</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;则是<span class="keyword">return</span>的另一种用法，专用于返回值非<span class="keyword">void</span>的函数返回其值。</span><br><span class="line">   ```  </span><br><span class="line">   例如：<span class="keyword">int</span> main()&#123;  f();  <span class="keyword">return</span> <span class="number">0</span>;  &#125;  </span><br><span class="line">   <span class="built_in">exit</span>函数：  </span><br><span class="line">   如果任意一个线程调用了<span class="built_in">exit</span>或_exit，则整个进程的所有线程都终止，由于从main函数<span class="keyword">return</span>也相当于调用<span class="built_in">exit</span></span><br><span class="line"><span class="number">7.</span> 原子操作：该怎么要么不执行，要么就完成   </span><br><span class="line">   比如n++是由好几个指令完成，但是它一次性完成  </span><br><span class="line">   关于这个说法在数据库中也存在  </span><br><span class="line">   互斥锁的使用步骤：</span><br><span class="line">   - 创建一把锁：<span class="keyword">pthread_mutex_t</span> mutex；<span class="comment">//mutex=1; 初始为1表示锁可以用</span></span><br><span class="line">   - 在main函数中初始化互斥锁：pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">   - 锁的作用---在共享资源出现的位置的上下加锁和解锁</span><br><span class="line">      ``pthread_mutex_lock(&amp;mutex);  <span class="comment">//mutex-- 锁为0被占用``   </span></span><br><span class="line">      <span class="comment">//共享资源操作的代码  </span></span><br><span class="line">      ``pthread_mutex_unlock(&amp;mutex);  <span class="comment">//mutex++``</span></span><br><span class="line">   - 在main函数中释放互斥锁</span><br><span class="line">  注意：加锁之后效率变低的本质是：两个线程不能并行了，只能有一个线程执行。  </span><br><span class="line">  异常退出需要解锁</span><br><span class="line"><span class="number">8.</span> umask文件掩码：<span class="number">0002</span>  第一位代表<span class="number">8</span>进制，二三四分别代表文件所属用户，文件所属组，其他人  </span><br><span class="line">   建议多写宏，少写数字，跨系统宏不变  </span><br><span class="line">   写代码时候建议<span class="string">&quot;,&quot;</span>后边跟一个<span class="string">&quot;空格&quot;</span>，比如sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);    </span><br><span class="line">   ulimit -a 查看各种数据类型大小  </span><br><span class="line">   ctrl + s 终止屏幕输出  ctrl+q恢复屏幕输出  </span><br><span class="line">   编译的时候太长了 需要写一个脚本编译：</span><br><span class="line">   ```c</span><br><span class="line">   <span class="number">1</span> vi pmak  </span><br><span class="line">   <span class="number">2</span> gcc -o $<span class="number">1</span> $<span class="number">1.</span>c -lpthread 其中$<span class="number">1</span>代表第一个参数</span><br><span class="line">   <span class="comment">//man pthread_create中Compile and link with -pthread，就是gcc -o a.out pthread_create.c -lpthread</span></span><br><span class="line">   需要在链接和编译的时候添加-lpthread库</span><br><span class="line">   <span class="number">3</span> chmod +x pmak   </span><br><span class="line">   <span class="number">4</span> ./pmak  pthread_create_loop 就可以了</span><br></pre></td></tr></table></figure>
<img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B2.png" alt="avatar"></li>
<li>服务就是后台进程<br> bash、shell 也是进程 比如打开4个shell终端，就会有4个bash<br> 但是查看bash时：ps -ef | grep bash 会多出现一个 grep bash命令本身<br> 看进程组的命令 ps -ef | wc -l<br> 查看会话的命令 ps ajx<br> 查看文件中内容显示到终端：tail -f mydemon.log<h2 id="Linux系统编程-线程同步"><a href="#Linux系统编程-线程同步" class="headerlink" title="Linux系统编程-线程同步"></a>Linux系统编程-线程同步</h2></li>
<li>读写锁：读写锁是一把锁<br>总结：写独占 读共享 当读和写一起等待锁的时候，写的优先级高<br>读写锁互斥：线程A持有读锁，线程B请求写锁，会阻塞<br>读写锁使用步骤：<ol>
<li>先定义一把读写锁：<br>pthread_rwlock_t rwlock;</li>
<li>初始化读写锁(主函数中)<br>pthread_rwlock_init(&amp;rwlock，NULL)；</li>
<li>加锁<br>pthread_rwlock_rdlock(&amp;rwlock);——&gt;加读锁<br>pthread_rwlock_wrlock(&amp;rwlock);——&gt;加写锁<br>///<br>共享资源的位置<br>///</li>
<li>解锁<br> pthread_rwlock_unlock(&amp;rwlock);</li>
<li>释放锁<br> pthread_rwlock_destory(&amp;rwlock);</li>
</ol>
</li>
<li>死锁：<br>死锁不是linux提供给开发者的一种机制，而是由于开发者操作不当引起的  <ul>
<li>自己锁自己 注意点：线程在异常退出的时候也需要解锁</li>
<li>A线程占用着A锁，又想去获得B锁，B线程占用着B锁，又想去获得A锁<br>两个线程都不释放自己的锁，又想去获得对方的锁，从而造成了死锁<br>解决办法：<ol>
<li>需要先释放掉自己的锁再去获得其他锁</li>
<li>避免使用嵌套的锁，让线程按照一定的顺序加锁</li>
<li>可以调用pthread_mutex_trylock函数加锁，该函数不阻塞，所以不会产生死锁</li>
</ol>
</li>
</ul>
</li>
<li>条件变量：<ol>
<li>定义条件变量<br><code>pthread_cond_t cond;</code></li>
<li>初始化条件变量<br><code>pthread_cond init(&amp;cond ,NULL);</code></li>
<li>在生产这线程中调用<br><code>pthread_cond_signal(&amp;cond);</code></li>
<li>在消费者线程中调用：<br><code>pthread_cond_wait(&amp;cond, &amp;mutex);</code></li>
<li>释放条件变量<br><code>pthread_cond_destroy(&amp;cond);</code><br>多个生产者和多个消费者程序在运行的时候core掉的原因分析：<br>假如只有一个生产者生产了一个节点，此时会调用pthread_cond_signal通知消费者线程，此时若有多个消费者被唤醒了，则最终只有一个消费者获得锁，此时会将head置为NULL，然后其余的几个消费者线程只会有一个线程获得锁，然后读取head的内容就会core掉。<br>在使用条件变量的线程中，能够引起线程的阻塞的地方有两个：<ol>
<li>在条件变量处引起阻塞—-&gt;这个阻塞会被pthread_cond_signal解除阻塞</li>
<li>互斥锁也会使线程引起阻塞，其他线程先抢到锁—–&gt;其他线程解锁会使该线程解除阻塞  </li>
</ol>
</li>
<li>生产者结束之后 会唤醒很多消费者线程同时抢锁，但是只有一个线程可以抢到。</li>
</ol>
</li>
<li>生产者和消费者模型：<br>消费者中的head是生产者中的pNode<br>pthread_create函数的最后一个参数可以传到子线程中<br>比如：ret=pthread_create(&amp;thread2[i], NULL, consumer, arr[i]);<br>void *consumer(void *arg) 其中arr[i]传给arg;  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B3.png" alt="avatar"></li>
</ul>
</li>
<li>usleep(1000)=sleep(1)<br>信号量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义信号量变量</span><br><span class="line"><span class="keyword">sem_t</span> sem1;</span><br><span class="line"><span class="keyword">sem_t</span> sem2;</span><br><span class="line"><span class="number">2.</span> 初始化信号量</span><br><span class="line">sem_init(&amp;sem1,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">sem_init(&amp;sem2,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">3.</span> 加锁</span><br><span class="line">sem_wait(&amp;sem1);</span><br><span class="line"><span class="comment">//共享资源</span></span><br><span class="line">sem_post(&amp;sem2);</span><br><span class="line">sem_wait(&amp;sem2);</span><br><span class="line"><span class="comment">//共享资源</span></span><br><span class="line">sem_post(&amp;sem1);</span><br><span class="line"><span class="number">4.</span> 释放资源</span><br><span class="line">sem_destroy(sem1);</span><br><span class="line">sem_destroy(sem2);</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B4.png" alt="avatar"><h2 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h2></li>
</ul>
</li>
<li>网络应用程序常见的两种设计模式：  <ol>
<li>C/S模式：<br>优点：可以安装在本地，可以缓存数据，协议的选择灵活<br>缺点：客户端工具需要有程序员开发，开发周期长工作量大；<br>需要本地安装，对客户的电脑安全有一定影响。</li>
<li>B/S模式<br>浏览器/web服务器模式<br>优点：浏览器不用开发，开发周期短，工作量小<br>缺点：只能选择http协议，协议选择受限制，不能缓存数据，效率受影响</li>
</ol>
</li>
<li>服务说白了就是守护进程<br>xiaobu@ubuntu:/etc$ vim services查看端口号<br>21端口ftp 22端口 ssh 23端口 Telnet<br>127.0.0.1本都回环地址<br>地址重用大概一分钟左右</li>
<li>协议：<br>解释：协议是双方共同指定的一组规则，在网络通讯中表示通讯双方传输数据和解释数据的一组规则。<br>图中：从A上传文件到服务器B，需要在A和B之间制定一个双方都认可的规则，这个规则就称为文件传输协议，该协议是ftp协议的一个初始版本，后经过不断的完善，优化最终形成了一个完成的ftp协议。<br>注意：协议和具体平台无关。<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B5.png" alt="avatar"></li>
</ul>
</li>
<li>一、网络字节序:<br>大端和小端的概念<br>大端(高端)(网络)：低位地址存放高位数据，高位地址存放低位数据<br>小端(低端)：低位地址存放低位数据，高位地址存放高位数据——这个是正常的<br>网络传输数据的时候用的高端字节序，所以高端字节序也叫网络字节序<br>本机上使用的是小端(低端)字节序  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="keyword">short</span> s;</span><br><span class="line">       <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">   &#125;un2;<span class="comment">//共用体 两个变量占用同一块内存</span></span><br><span class="line">   ```  </span><br><span class="line">   <span class="comment">//如果用short s赋值 用c显示可以，但是用short赋值，用c再赋值就会覆盖  </span></span><br><span class="line">   二、大小端转换的函数：  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br><span class="line">   ```  </span><br><span class="line">   <span class="comment">//函数名的h表示主机host, n表示网络network, s表示short, l表示long  to表示 到大端和小端的使用使用场合???	  </span></span><br><span class="line">   大端和小端只是对数据类型长度是两个及以上的, 如<span class="keyword">int</span>  <span class="keyword">short</span>, 对于单字节	没限制, 在网络中经常需要考虑大端和小端的是IP和端口. 端口就是<span class="keyword">short</span>类型  </span><br><span class="line">   三、IP地址转换函数:</span><br><span class="line">   <span class="number">1.</span> ``<span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;``  </span><br><span class="line">   函数说明: 将字符串形式的点分十进制IP(低端)转换为大端模式的网络IP(整形<span class="number">4</span>字节数)  </span><br><span class="line">   p-&gt;表示点分十进制的字符串形式  </span><br><span class="line">   to-&gt;到  </span><br><span class="line">   n-&gt;表示network网络  </span><br><span class="line">   参数说明:  </span><br><span class="line">   af: AF_INET  </span><br><span class="line">   src: 字符串形式的点分十进制的IP地址  </span><br><span class="line">   dst: 存放转换后的变量的地址   </span><br><span class="line">   例如: inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv.sin_addr.s_addr);  </span><br><span class="line">   手工也可以计算: 如<span class="number">192.168</span><span class="number">.232</span><span class="number">.145</span>, 先将<span class="number">4</span>个正数分别转换为<span class="number">16</span>进制数,   </span><br><span class="line">   <span class="number">192</span>---&gt;<span class="number">0xC0</span>  <span class="number">168</span>---&gt;<span class="number">0xA8</span>   <span class="number">232</span>---&gt;<span class="number">0xE8</span>   <span class="number">145</span>---&gt;<span class="number">0x91</span>  </span><br><span class="line">   最后按照大端字节序存放: <span class="number">0x91E8A8C0</span>, 这个就是<span class="number">4</span>字节的整形值.  </span><br><span class="line">   <span class="number">2.</span> ``<span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;``  </span><br><span class="line">   函数说明: 网络IP转换为字符串形式的点分十进制的IP  </span><br><span class="line">   参数说明:  </span><br><span class="line">   af: AF_INET  </span><br><span class="line">   src: 网络的整形的IP地址  </span><br><span class="line">   dst: 转换后的IP地址,一般为字符串数组  </span><br><span class="line">   size: dst的长度  </span><br><span class="line">   返回值:   </span><br><span class="line">   成功--返回指向dst的指针  方便链式编程  </span><br><span class="line">   失败--返回<span class="literal">NULL</span>, 并设置errno</span><br><span class="line"><span class="number">5.</span> 服务端开发流程:</span><br><span class="line">	<span class="number">1.</span> 创建socket,返回一个文件描述符lfd---socket()  </span><br><span class="line">      --该文件描述符用于监听客户端连接</span><br><span class="line">	<span class="number">2.</span> 将lfd和IP  PORT进行绑定----bind()</span><br><span class="line">	<span class="number">3.</span> 将lfd由主动变为被动监听----listen()</span><br><span class="line">	<span class="number">4.</span> 接受一个新的连接,得到一个文件描述符cfd----accept()  </span><br><span class="line">   ---该文件描述符是用于和客户端进行通信的</span><br><span class="line">   ```c</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	  	接收数据---read或者recv</span><br><span class="line">	  	发送数据---write或者send</span><br><span class="line">	  &#125;<span class="comment">//一般情况下服务端是先接收在发送，</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>关闭文件描述符—-close(lfd)  close(cfd);  </li>
</ol>
***服务器端获取客户端的ip方便设置黑名单  </li>
<li>客户端的开发流程:<ol>
<li>创建socket, 返回一个文件描述符cfd—socket()  </li>
</ol>
—该文件描述符是用于和服务端通信<ol start="2">
<li>连接服务端—connect() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//发送数据---write或者send</span></span><br><span class="line"><span class="comment">//接收数据---read或者recv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>close(cfd)<br>测试过程中可以使用netstat命令查看监听状态和连接状态<br>netstat命令:  netstat -anp | grep 8888<br>a表示显示所有,<br>n表示显示的时候以数字的方式来显<br>p表示显示进程信息(进程名和进程PID)</li>
</ol>
</li>
<li>以太网帧格式：<br>ARP协议：通过对方的IP地址获取MAC地址<br>IP协议：在网络层<br>TCP协议：面向连接的，安全的，可靠的数据流传输协议<br>UDP协议：面向无连接的，不安全的，不可靠的数据报传输。<br>数据报传输就是要传就一下传完，不能像TCP分块拆，因为没序号，无连接<br>RARP协议：逆向地址解析协议，通过MAC地址获取对方的IP地址<br>帧类型有三种：其中数据不够46需要补齐，如果给了一个报文，参照图运用memcpy()函数拷贝字段<br>其中的发送端ip地址指的是大端字节序的整型值  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B6.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B7.png" alt="avatar"></li>
</ul>
</li>
<li>socket编程主要的API函数介绍:<ol>
<li><code>int socket(int domain, int type, int protocol);</code><br>函数描述: 创建socket<br>当调用socket函数以后, 返回一个文件描述符, 内核会提供与该文件描述符相对应的读和写缓冲区, 同时还有两个队列, 分别是请求连接队列和已连接队列(监听文件描述符才会有)  </li>
<li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>函数描述: 将socket文件描述符和IP,PORT绑定</li>
<li><code>int listen(int sockfd, int backlog);</code><br>函数描述: 将套接字由主动态变为被动态<br>假如backlog=10 ，最多连10个客户端，多了需要等待，10个已经进入连接队列中了，再有连接来只能放在等待连接队列(请求连接队列)中，最大128，不建议填0；</li>
<li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>函数说明:获得一个连接(不是新建一个连接), 若当前没有连接则会阻塞等待  </li>
</ol>
***在accept函数调用之前连接就已经建立了，获得连接就是从已连接队列中获得一个连接<br>addr: 传出参数, 保存客户端的地址信息，记录谁连的<br>addrlen: 传入传出参数,  addr变量所占内存空间大小，传入告诉accept这个addr占用内存，传出代表，函数调用完之后被填充了多少<br>accept函数是一个阻塞函数, 若没有新的连接请求, 则一直阻塞<br>内核会负责将请求队列中的连接拿到已连接队列中  <ol start="5">
<li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>函数说明: 连接服务器 客户端函数  </li>
<li>接下来就可以使用write和read函数进行读写操作了.<br>读取数据和发送数据:    客户端函数<pre><code class="c">ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);    
//对应recv和send这两个函数flags直接填0就可以了
</code></pre>
个人理解：<br>调用accept之后能拿到一个连接，有了连接可以通信服务端有两种类型文件描述符：  </li>
<li>监听文件描述符：调用socket返回的文件描述符，然后调用listen已近设置为被动监听状态，接收连接，有客户端连过来就接收连接</li>
<li>通信文件描述符：调用accept返回的文件描述符，用来和客户端通信的，收发数据<br>客户端只有一种类型文件描述符(不需要监听)：</li>
<li>通信文件描述符：调用socket返回的文件描述符，用来和客户端通信的，收发数据</li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B8.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B9.png" alt="avatar"></li>
</ol>
</li>
<li>socket编程用到的重要的结构体:struct sockaddr<br> struct sockaddr结构说明:<pre><code class="c">struct sockaddr &#123;
    sa_family_t sa_family;
    char     sa_data[14];
&#125;
</code></pre>
 struct sockaddr_in结构:<pre><code class="c">struct sockaddr_in &#123;
     sa_family_t    sin_family; /* address family: AF_INET */
     in_port_t      sin_port;   /* port in network byte order */
     struct in_addr sin_addr;   /* internet address */
&#125;;
/* Internet address. */
struct in_addr &#123;
     uint32_t  s_addr;     /* address in network byte order */
&#125;;     //网络字节序IP--大端模式
</code></pre>
 通过man 7 ip可以查看相关说明  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B10.png" alt="avatar"></li>
</ul>
</li>
<li>数据通讯过程<br>在发送方是数据层层打包过程<br>在接收方是数据层层解包过程<br>网卡发送的数字信号 通过modemn<br>转换成模拟信号发送到网络中  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B11.png" alt="avatar"></li>
</ul>
</li>
<li>OSI（Open System Interconnection）七层模型：<br>物数网传会表应<br>应用层：主要就是应用程序，ftp ssh email http<br>表示层：进行编解码和翻译工作<br>会话层：建立会话和保持会话 建立信道<br>传输层：定义了端到端的传输，TCP  UDP协议   A端和B端通信中间有很多层，就是很多点(路由器)<br>网络层：定义了点到点的传输，IP协议—–路由器   点到点指的就是路由器到路由器，<br>数据链路层：数据校验（CRC 4个字节），定义了数据格式–帧(从网卡发出去的都叫帧，帧就是有格式的字符串)<br>ARP协议 RARP协议<br>物理层：通讯介质-双绞线，光纤  调制解调器modemn(模数转换和数模转换)<br>TCP四层模型：<br>应用层：对应会话层，表示层和应用层<br>传输层：对应传输层<br>网络层：对应网络层<br>网络接口层：对应物理层和数据链路层<br>知识点：<br>猫的作用：接收信号时，通过高低电频的方法将模拟信号转换为数字信号，其中网线中就是高低电频的模拟信号，<br>外边发的数据最后由网卡接收。<br>路由器：是连接两个不同网段的桥梁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/" data-id="ckp3bilio00074suegy5rb5cs" data-title="守护进程-线程-网络基本概念" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Linux系统编程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-05-16T07:09:49.292Z" itemprop="datePublished">2021-05-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux系统编程1"><a href="#Linux系统编程1" class="headerlink" title="Linux系统编程1"></a>Linux系统编程1</h2><ol>
<li><ol>
<li>gdb调试：<br>gdb是在程序运行的结果与预期不符合的时候，可以使用gdb进行调试，<br>特别注意的是：使用gdb调试需要在编译的时候加-g参数。（在调试的时候就可以看到源代码）<br><code>gcc -g -c hello.c    //-g用的时候和-c一起用 生成.o文件</code><br><code>gcc -o hello hello.o //如果通过.o文件生成可执行文件时，添加-g文件看不懂二进制</code><br>gdb有点像小型的shell，里边也有命令<br>启动gdb：<br><code>gdb program（./main）set args hello world </code><br><code>show args</code>  </li>
<li>执行程序：<br>run 会在第一个断点处停下来<br>start 会在第一条语句处(；)停下来</li>
<li>list：<br>list(可以用“l”简写)显示源代码 只显示10行<br>list fun  list main 查看main函数<br>list linenum   list 1 回到第一行<br>list file linenum   list fun1.c：1 进入fun1.c函数中的第一行<br>list - 显示当前文件开始处的源程序。<br>set listsize count：设置一次显示源代码的行数。<br>show listsize：查看当前listsize的设置。<br>enter执行刚刚执行过的命令</li>
<li>断点操作<br>break 设置断点, 可以简写为b<br>b linenum<br>b func<br>b file:linenum<br>b file:func<br>info break 简写 i b  查询所有断点<br>disable  m n | m-n<br>enable m n | m-n<br>delete m n | m-n   d 后边什么都不写就是删除所有<br>b test.c:9 if intValue == 5 条件断点</li>
<li>调试命令：<br>run 运行程序, 可简写为r<br>next 单步跟踪, 函数调用当作一条简单语句执行, 可简写为n<br>step 单步跟踪, 函数调进入被调用函数体内, 可简写为s<br>finish 退出进入的函数, 如果出不去, 看一下函数体中的循环中是否有断点，如果有删掉，或者设置无效<br>until 跳出循环 在一个循环体内单步跟踪时, 这个命令可以运行程序“直到退出循环体”,可简写为u,<br>如果出不去, 看一下函数体中的循环中是否有断点，如果有删掉，或者设置无效<br>continue 继续运行程序, 可简写为c(若有断点则跳到下一个断点处)<br>print var 打印变量值</li>
<li>自动显示（需要执行才能看见）<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">display  var</span><br><span class="line">info display</span><br><span class="line">disable display m n | m-n </span><br><span class="line">enable display m n | m-n</span><br><span class="line"><span class="keyword">delete</span> display  m n | m-n</span><br><span class="line">undisplay m n | m-n</span><br></pre></td></tr></table></figure></li>
<li>查看变量的名字<br><code>ptype argv</code><br><code>type=char **</code><br><code>p width --打印变量width 的值$4 = 13</code><br>你可以使用set var命令来告诉GDB, width不是你GDB的参数, 而是程序的变量名, 如：<code>set var width=47  // 将变量var值设置为47</code></li>
<li>gdb调试适合单进程，不适合多线程.gdb退出不是exit 是Quit</li>
<li>*gdb适合单进程 如果多线程或者多进程 就很复杂（属于命令行）<br>vs中通过断点调试，可以把变量值打开，可以查地址（属于图形化界面）<br>！！！最牛逼的调试方式就是：打印日志，要打印到文件中，方便查看<br>args是arguments 参数的复数(名词复数)的缩写<br>argc默认的值是1，就是自己  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;this is main!\n&quot;</span>);</span><br><span class="line">   	<span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="built_in">printf</span>(<span class="string">&quot;[%d]:[%s]\n&quot;</span>, i, argv[i]);</span><br><span class="line">   	&#125;</span><br><span class="line">       fun1();</span><br><span class="line">       fun2();</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sum(10)==[%d]\n&quot;</span>, sum(<span class="number">10</span>));</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li>c 文件的编译用gcc c++文件的编译用g++<br>gcc编译程序时，</li>
</ol>
<ul>
<li>编译成可执行程序 </li>
<li>编译成库文件 </li>
<li>编译成.o文件（属于库文件）<br>tab键是一个字符</li>
</ul>
</li>
<li><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;argc; i++)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;[%d]:[%s]\n&quot;</span>, i, argv[i]);</span><br><span class="line">&#125;<span class="comment">//打印main函数的命令行参数，其中i=0</span></span><br></pre></td></tr></table></figure>
<img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B1.png" alt="avatar"></li>
<li>makefile：<br>makefile文件是用来管理项目工程文件，通过执行make命令，make就会解析并执行makefile文件<br>makefile命名：makefile 或者Makefile<br>makefile的编写：<br>规则：<br>目标：依赖(条件)<br>(tab)命令<br>这命令会将依赖生成目标<br>第一个版本：    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  main：main.c fun1.c fun2.c sum.c</span><br><span class="line">gcc -o main main.c fun1.c fun2.c sum.c</span><br></pre></td></tr></table></figure>
缺点：改其中一个文件(main.c) 所有文件都需要重新编译<br>第二个版本：     <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  main：main.o fun1.o fun2.o sum.o</span><br><span class="line">gcc -o main mian.o fun1.o fun2.o sum.o</span><br><span class="line">  <span class="comment">//生成main.o的规则</span></span><br><span class="line">  main.o：main.c</span><br><span class="line">  	gcc -c main.c -I./</span><br><span class="line">  fun1.o：fun1.c</span><br><span class="line">  	gcc -c fun1.c </span><br><span class="line">  fun2.o：fun2.c</span><br><span class="line">  	gcc -c fun2.c </span><br><span class="line">  sum.o：sum.c</span><br><span class="line">  	gcc -c sum.c </span><br></pre></td></tr></table></figure>
检查规则：<br>要想生成目标文件，先要检查依赖条件是否都存在：<br>若都存在，则比较目标时间和依赖的时间，如果依赖时间比目标时间新，<br>则重新生成目标；否则不重新生成<br>若不存在，则往下找有没有生成依赖的规则，有则生成，如果没有则报错。<br>//touch可以更新文件最后修改时间<br>缺点: 冗余, 若.c文件数量很多, 编写起来比较麻烦.<br>第三个版本：   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">target=main</span><br><span class="line">objects=main.o fun1.o fun2.o sum.o</span><br><span class="line">CC=gcc</span><br><span class="line">CPPFLAGS=-I./</span><br><span class="line">$(target)：$(objects)</span><br><span class="line">	$(CC) -o main $(objects)</span><br><span class="line">main.o：main.c</span><br><span class="line">	$(CC)  -c main.c $(CPPFLAGS)</span><br><span class="line">fun1.o：fun1.c</span><br><span class="line">	$(CC)  -c fun1.c </span><br><span class="line">fun2.o：fun2.c</span><br><span class="line">	$(CC) -c fun2.c </span><br><span class="line">sum.o：sum.c</span><br><span class="line">	$(CC)  -c sum.c </span><br></pre></td></tr></table></figure>
makefile中的变量：  <ul>
<li>普通变量：<ul>
<li>自定义变量：<code>var=hello，$(var)</code></li>
<li>自带变量：<code>CC CPPFLAGS(头文件路径) CFLAGS LDFLAGS(链接路径)</code></li>
</ul>
</li>
<li>自动变量：<code>$@(目标) $&lt;(第一个依赖) $^(所有依赖)（只能在规则中的命令中使用） </code> </li>
<li>模式规则：<code>%.o:%.c------&gt;前后的%必须相同</code>  </li>
</ul>
第四个版本：     <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">target=main</span><br><span class="line">src=$(wildcard *.c)</span><br><span class="line">objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line">CC=gcc</span><br><span class="line">CPPFLAGS=-I./</span><br><span class="line">$(target)：$(objects)</span><br><span class="line">	$(CC) -o $@ $^</span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC)  -c $&lt; $(CPPFLAGS)</span><br></pre></td></tr></table></figure>
makefile函数：<ol>
<li>wildcard – 查找指定目录下的指定类型的文件<code>src=$(wildcard *.c) //找到当前目录下所有后缀为.c的文件,赋值给src</code></li>
<li>patsubst – 匹配替换<code>obj=$(patsubst %.c,%.o, $(src)) //把src变量里所有后缀为.c的文件替换成.o//src=$(wildcard *.c)，</code>其中”*.c”是wildcard函数的参数，用<code>&quot;$()&quot;获取wildcard *.c函数的返回值赋给src字符串</code></li>
<li>如：当前目录下有a.c b.c c.c<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  src=$(wildcard *.c)-----&gt;src=a.c b.c c.c</span><br><span class="line">obj=$(patsubst %.c,%.o, $(src))-----&gt;obj=a.o b.o c.o</span><br></pre></td></tr></table></figure>
第五个版本：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">target=main</span><br><span class="line">src=$(wildcard *.c)</span><br><span class="line">objects=$(patsubst %.c,%.o,$(src))</span><br><span class="line">CC=gcc</span><br><span class="line">CPPFLAGS=-I./</span><br><span class="line">$(target)：$(objects)</span><br><span class="line">	$(CC) -o $@ $^</span><br><span class="line">%.o:%.c</span><br><span class="line">	$(CC)  -c $&lt; $(CPPFLAGS)</span><br><span class="line">.PHONY：clean</span><br><span class="line">clean：</span><br><span class="line">	rm -f $(objects) $(target)</span><br></pre></td></tr></table></figure>
makefile增加清理功能<br>终极目标：makefile文件中第一次出现的目标叫做终极目标<br><code>.PHONY：clean     //伪目标不检查更新  </code><br><code>clean：  rm -f $(objects) $(target)  </code><br>！！！使用 -f 可以指定makefile文件，如：make -f mainmak 或者执行make -f mainmak clean<br>生成main文件之后可以删除head.h文件，类似于静态库，在预编译阶段展开编译到程序中<br>如果make clean放在前边作为终极目标，那么需要make main命令实现main规则</li>
</ol>
</li>
<li>dev/tty  设备文件只能用open打开，fopen中能打开普通文件<br>perror和errno:<br>一个进程里边都有一个errno，errno会对应一个错误描述信息，errno可以用perror打印出来。<br>errno是一个全局变量, 当系统调用后若出错会将errno进行设置, perror可以将errno对应的描述信息打印出来.<br>E2BIG   Argument list too long (POSIX.1)<br>//E2BIG(宏 整型值)对应后边信息    POSIX代表可移植的，是个标准<br>每个程序（进程）之间的errno是不一样的  errno只是在一个进程中有用</li>
<li>C库函数与系统函数的关系：<br>调用和被调用的关系；库函数是对系统函数的进一步封装<br>C标准函数有 stdin stdout stderr(标准错误输出)，stdout是文件指针，所以至少有三项…<br>printf函数是标准输出函数，内部调用write函数，write函数中有文件描述符，可以将printf中的文件描述符通过write函数传下去，hello也可以传下午，然后sys_write()可以调用内核中设备驱动函数，由设备驱动函数将字符串显示到屏幕上。<br>系统调用: 由操作系统实现并提供给外部应用程序的编程接口，<br>(Application Programming Interface, API), 是应用程序同系统之间数据交互的桥梁。***应用层write()是对系统调用层sys_wirte()的封装<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B2.png" alt="avatar"></li>
<li>C库IO函数的工作流程：<br>文件指针 （结构体类型指针）FILE *fp，fp调用fopen()之后，在堆区分配空间把地址返回给fp，里边存放与文件相关的信息和保存了文件的状态，比如<ul>
<li>文件描述符、</li>
<li>读写指针（光标）位置变化。</li>
<li>fp不指向文件，但是fp关联文件。  </li>
</ul>
文件描述符（整型）0~1024 ，其中0,1,2被占用。刚写完的文件是读不到的，因为光标到最后了 需要fseek将光标移到开始位置（或者关闭重启）。<ul>
<li>文件存在磁盘上，缓冲在内存上 </li>
<li>通过文件描述符可以找到inode，每个数据块都有一个inode，通过inode找到磁盘数据块</li>
<li>fp指针至少有三项：1，文件描述符FD  2，文件指针 FP_POS 3，文件缓冲区BUFFER<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B3.png" alt="avatar"><br>fopen打开hello.txt文件，返回fp指针，fp指针中存放文件描述符FD对应txt文件，fp指针中存放文件读写指针位置，表示在文件读写过程中的实际位置，fp指针中存放I/O缓冲区（内存地址），通过这个地址可以找到对应内存块，最后将内存块中的内容存到txt磁盘上，或者从磁盘上txt中读取内容到内存块中再传到用户程序中<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B4.png" alt="avatar"></li>
</ul>
</li>
<li>阻塞和非阻塞是文件的属性还是read函数的属性?<br>通过读文件测试得知：read函数在读完文件之后，再次read，<br>则read会立即返回，表明read函数读取普通文件是非阻塞的。<br>设备文件：/dev/tty  标准输入STDIN_FILENO<br>通过读/dev/tty终端设备文件，表明read函数读取设备文件是阻塞的<br>结论：阻塞和非阻塞是文件本身的属性, 不是read函数的属性.<br>socket pipe 设备文件 这三种文件都是阻塞的 普通文件是非阻塞的</li>
<li>man命令：<br>man fileno 直接查看系统命令<br>man 2 wirte 其中2 代表系统调用<br>man 3  ……代表标准C语言函数<br>man 4 …… 设备文件的说明，通常在/dev下的文件<br>***0x00和0效果一样  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">   <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="keyword">sizeof</span>(buf));  </span><br><span class="line">   <span class="built_in">memset</span>(buf,<span class="number">0</span>,<span class="keyword">sizeof</span>(buf));  </span><br><span class="line">   main()  </span><br><span class="line">   &#123;</span><br><span class="line">   &#125;<span class="comment">//查看函数“&#125;”的位置，shift+%命令</span></span><br><span class="line">   ```  </span><br><span class="line">   还有就是~/lib，~/在makefile中不好用  </span><br><span class="line">   当前目录：程序在哪执行的，哪就是当前目录  </span><br><span class="line">   位操作符：&amp; | ~ 与或非 <span class="keyword">off_t</span>表示偏移键</span><br><span class="line"><span class="number">9.</span> 文件I/O  </span><br><span class="line">   linux中系统函数成功，大多数返回<span class="number">0</span>(或者大于<span class="number">0</span>的数)  </span><br><span class="line">   失败返回<span class="number">-1</span>，如果有指针返回<span class="literal">NULL</span>，并设置errno(对应一个错误描述)  </span><br><span class="line">   <span class="number">1.</span> open函数  </span><br><span class="line">   函数原型``<span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;``</span><br><span class="line">	参数：mode, 表示该文件的访问权限。  </span><br><span class="line">   文件最终权限：``mode &amp; ~umask(掩码)    比如mode是<span class="number">0777</span>  umask是<span class="number">0002</span> “`”``是取反的操作  </span><br><span class="line">	mode=<span class="number">0777</span> 因为是<span class="number">8</span>进制所以前边的<span class="number">0</span>代表<span class="number">8</span>进制  </span><br><span class="line">   每个用户都有一个文件掩码umask 掩码的意思就是把这个权限去掉 掩盖的意思 掩盖其他人写的权限  </span><br><span class="line">   成功: 返回一个最小且未被占用的文件描述符</span><br><span class="line">   <span class="number">2.</span> close函数内部有个隐藏操作：刷新  </span><br><span class="line">   linux提供的函数都是不带缓冲的，比如fclose()内部调用的就是close()，会将缓冲区的内容刷新到磁盘里面，也就是说打开文件之后记得close，有open就有close</span><br><span class="line">   <span class="number">3.</span> read函数和fread()，fput()一样，fgets()是读  </span><br><span class="line">   函数原型: ``<span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);``  </span><br><span class="line">   参数：fd 是open返回的 count代表<span class="keyword">sizeof</span>(buf)  </span><br><span class="line">   例如：buf是<span class="number">100</span>字节(count=<span class="number">100</span>)  但是里边的文件是<span class="number">50</span>字节，最终读取<span class="number">50</span>字节  </span><br><span class="line">   返回值：读取的字节数</span><br><span class="line">   <span class="number">4.</span> write函数  </span><br><span class="line">   函数原型: ``<span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span></span>;  ``</span><br><span class="line">   参数：count代表buf中实际字节数<span class="built_in">strlen</span>(buf)，不是buf的大小(<span class="keyword">sizeof</span>(buf))  </span><br><span class="line">   例如：``<span class="keyword">char</span> buf[<span class="number">256</span>]=<span class="string">&quot;hello world&quot;</span>；``</span><br><span class="line">   <span class="number">5.</span> lseek函数 类似fseek函数 移动指针  </span><br><span class="line">   使用lseek函数<span class="string">&quot;获取文件大小&quot;</span>  </span><br><span class="line">   使用lseek函数<span class="string">&quot;实现文件拓展&quot;</span>   </span><br><span class="line">   例如：U盘拷文件时，U盘只有<span class="number">800</span>M 但是文件<span class="number">1</span>G，如何实现U盘插上就能看见内存不够。或者迅雷下载时提醒内存不够</span><br><span class="line">   <span class="number">6.</span> perror函数 打印函数调用失败原因</span><br><span class="line">   <span class="number">7.</span> ![avatar](/Linux系统编程/系统编程<span class="number">5.</span>png)</span><br><span class="line"><span class="number">10.</span> 一个程序运行起来之后就叫进程，  </span><br><span class="line">    程序运行，操作系统就会为其分配一个<span class="number">4</span>G(<span class="number">32</span>位系统<span class="number">2</span>^<span class="number">32</span>)虚拟地址空间，进程执行起来需要资源，cpu资源、内存资源、终端设备。一个程序启动以后默认有三个终端（<span class="built_in">stdin</span> <span class="built_in">stdout</span> <span class="built_in">stderr</span>），终端也是文件。  </span><br><span class="line">    用户区空间(<span class="number">3</span>G)：</span><br><span class="line">    <span class="number">1.</span> shell也是程序(进程)，shell也有环境变量</span><br><span class="line">    <span class="number">2.</span> 命令行参数：main函数有实际上有三个参数，但是我们见到的都是两个参数（一个是参数的个数，一个是具体的参数）给命令行传参(main函数) ./main hello world ni hao 后边四个就是参数。main函数就是一个命令</span><br><span class="line">    <span class="number">3.</span> 函数不要返回局部变量指针，函数结束会被释放掉，变成野指针</span><br><span class="line">    <span class="number">4.</span> 堆的地址分配是从低地址到高地址，栈是从高到低</span><br><span class="line">    <span class="number">5.</span> .bss(未初始化全局变量)  .data(已初始化全局变量)在main函数之外定义的全局变量，如果初始化了在.data区，如果没有初始化默认是<span class="number">0</span>，在.bss区(未初始化全局变量)。</span><br><span class="line">    <span class="number">6.</span> 一般情况下<span class="literal">NULL</span>就是<span class="number">0</span>  </span><br><span class="line">      内核区空间(<span class="number">1</span>G)：  </span><br><span class="line">      特点：不能读写，不能直接操作内核，我们只能操作用户空间  </span><br><span class="line">      内核是操作系统去管理，资源分配的事  </span><br><span class="line">      进程是操作系统管理  </span><br><span class="line">      内核中的进程管理中有个PCB（进程控制块）</span><br><span class="line">      ![avatar](/Linux系统编程/系统编程<span class="number">6.</span>png)</span><br><span class="line"><span class="number">11.</span> 虚拟地址空间：  </span><br><span class="line">    进程的虚拟地址空间分为用户区和内核区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;  </span><br><span class="line">    内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(本质是一个结构体);  </span><br><span class="line">    PCB中有文件描述符表, 文件描述符表中存放着打开的文件描述符, 涉及到文件的IO操作都会用到这个文件描述符.  </span><br><span class="line">    PCB进程控制块里存放文件描述符表，它里边存放多个打开的文件描述符（打开的文件），每个进程默认打开三个文件描述符， <span class="number">0</span>-&gt;<span class="built_in">stdin</span> <span class="number">1</span>-&gt;<span class="built_in">stdout</span> <span class="number">2</span>-&gt;<span class="built_in">stderr</span>，如果<span class="number">0</span>-&gt;<span class="built_in">stdin</span>关闭，这个<span class="number">0</span>文件描述符被回收，再打开文件从<span class="number">0</span>开始分配，一个进程最多打开<span class="number">1024</span>个文件（<span class="number">0</span>~<span class="number">1023</span>）  </span><br><span class="line">    pcb：结构体:task_stuct, 该结构体在:  </span><br><span class="line">    /usr/src/linux-headers<span class="number">-4.4</span><span class="number">.0</span><span class="number">-97</span>/include/linux/sched.h:<span class="number">1390</span>  </span><br><span class="line">    每一个进程都有一个文件描述符表：<span class="number">1024</span>  </span><br><span class="line">    •前三个被占用, 分别是<span class="number">0</span>-&gt;STDIN_FILENO, <span class="number">1</span>-&gt;STDOUT_FILENO, <span class="number">2</span>-&gt;STDERR_FILENO  </span><br><span class="line">    •文件描述符作用：通过文件描述符找到inode, 通过inode找到磁盘数据块.  </span><br><span class="line">    虚拟地址空间-&gt;内核区-&gt;进程管理-&gt;PCB-&gt;文件描述表-&gt;文件描述符-&gt;文件IO操作使用文件描述符  </span><br><span class="line">    FILE *fp = fopen();<span class="comment">//C语言中  </span></span><br><span class="line">    <span class="keyword">int</span> fp=open();<span class="comment">//linux中直接操作文件描述符  </span></span><br><span class="line">    有个函数通过文件指针找到文件描述符：<span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE *stream)</span></span></span><br><span class="line">    ![avatar](/Linux系统编程/系统编程7.png)</span><br><span class="line"><span class="number">12.</span> fcntl函数:  </span><br><span class="line">    函数描述: 改变已经打开的文件的属性  </span><br><span class="line">    函数原型: <span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>; <span class="comment">//&quot;... /* arg */ &quot;代表变参函数，最常见的变参函数printf  </span></span><br><span class="line">    若cmd为F_DUPFD, 复制文件描述符, 与dup相同  </span><br><span class="line">    若cmd为F_GETFL, 获取文件描述符的flag属性值  </span><br><span class="line">    若cmd为 F_SETFL, 设置文件描述符的flag属性  </span><br><span class="line">    fcntl函数常用的操作:</span><br><span class="line">    <span class="number">1.</span> 复制一个新的文件描述符:</span><br><span class="line">   ``<span class="keyword">int</span> newfd = fcntl(fd, F_DUPFD, <span class="number">0</span>);``</span><br><span class="line">    <span class="number">2.</span> 获取文件的属性标志</span><br><span class="line">   ``<span class="keyword">int</span> flag = fcntl(fd, F_GETFL, <span class="number">0</span>)``</span><br><span class="line">    <span class="number">3.</span> 设置文件状态标志</span><br><span class="line">   ``flag = flag | O_APPEND;``</span><br><span class="line">   ``fcntl(fd, F_SETFL, flag)``</span><br><span class="line">    <span class="number">4.</span> 常用的属性标志</span><br><span class="line">         - O_APPEND-----设置文件打开为末尾添加</span><br><span class="line">         - O_NONBLOCK-----设置打开的文件描述符为非阻塞</span><br><span class="line">    <span class="number">5.</span> make dup2可以取代gcc dup2  </span><br><span class="line">       make dup2  将dup2.c生成dup2 可执行文件   </span><br><span class="line">       gcc dup2生成  a.out可执行文件</span><br><span class="line"><span class="number">13.</span> stat/lstat函数  </span><br><span class="line">    函数描述: 获取文件属性  </span><br><span class="line">    函数原型:   </span><br><span class="line">    ``<span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;  ``  </span><br><span class="line">    ``<span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *buf)</span></span>;`  </span><br><span class="line">    <span class="comment">//const char *pathname，文件路径包含文件名字，输入参数（我们告诉函数）  </span></span><br><span class="line">    <span class="comment">//struct stat *buf，输出参数（函数告诉我们），c++输出可以用引用和地址，把指针传进去  </span></span><br><span class="line">    引用的本质就是常量指针  </span><br><span class="line">    ***开发过程中看见参数前加coust一定是输入，因为传入的不能改  </span><br><span class="line">    shell命令id 打印用户的id 一个用户只有一个id   </span><br><span class="line">    获取文件类型：  </span><br><span class="line">    If (st_mode &amp; S_IWUSR)  ------为真表明可写     <span class="comment">//读写执行要写在三个if中  </span></span><br><span class="line">    If (st_mode &amp; S_IXUSR)   ------为真表明可执行  </span><br><span class="line">    If (st_mode &amp; S_IRUSR)   -----为真表明可读，其中st_mode是我们获取的权限，如果st_mode中有可读，则st_mode 和 S_IRUSR取与为可读，证明st_mode中有可读权限  </span><br><span class="line">    使用st_mode成员判断文件类型</span><br><span class="line">    ```c</span><br><span class="line">     <span class="keyword">if</span>((sb.st_mode &amp; S_IFMT) == S_IFLNK)</span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;链接文件\n&quot;</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">if</span> (S_ISREG(sb.st_mode))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;普通文件\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    ```    </span><br><span class="line">    判断文件权限</span><br><span class="line">     ```c</span><br><span class="line">     <span class="keyword">if</span>(sb.st_mode &amp; S_IROTH)&#123;</span><br><span class="line">          <span class="built_in">printf</span>(<span class="string">&quot;-------R----&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">     ```  </span><br><span class="line">     stat函数和lstat函数的区别  </span><br><span class="line">     对于普通文件, 这两个函数没有区别, 是一样的.  </span><br><span class="line">     对于连接文件,调用lstat函数获取的是链接文件本身的属性信息;   </span><br><span class="line">     而stat函数获取的是链接文件指向的文件的属性信息. stat穿透</span><br><span class="line"><span class="number">14.</span> 多个<span class="keyword">if</span>和<span class="keyword">if</span> <span class="keyword">else</span> <span class="keyword">if</span>相比，<span class="keyword">if</span> elseif更好，不需要多次判断  </span><br><span class="line">    权限不是互斥的只能用<span class="keyword">if</span> 不能用<span class="keyword">else</span>和switct <span class="keyword">case</span>  </span><br><span class="line">    <span class="keyword">switch</span> <span class="keyword">case</span> 要不<span class="keyword">if</span> <span class="keyword">else</span>效率高  </span><br><span class="line">    <span class="comment">//过滤掉.和..文件  </span></span><br><span class="line">    ```c</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(pDent-&gt;d_name,<span class="string">&quot;.&quot;</span>)==<span class="number">0</span>||<span class="built_in">strcmp</span>(pDent-&gt;d_name,<span class="string">&quot;..&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;   </span><br></pre></td></tr></table></figure>
 //过滤的时候不能用memcmp(pDent-&gt;d_name,”.”)，会把”.”隐藏文件都过滤掉</li>
<li>使用dup2函数实现标准输出重定向操作<br>类似于”&gt;” 比如：ls -l &gt;test.log<br>dup2(fd，STDOUT_FILENO)；STDOUT_FILENO追随fd，类似cp a b ，将a内容拷贝到b内容中 b追随a<br>STDOUT_FILENO默认指向/dev/tty<br><code>***1,printf(&quot;ni hao hello world&quot;);  </code><br><code>***2,write(STDOUT_FILENO，&quot;ni hao hello world&quot;，strlen(&quot;ni hao hello world&quot;));  </code><br>//1和2一个意思，printf是C语言的库函数 write是linux提供的系统函数 ，printf内部调用write函数<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B8.png" alt="avatar"></li>
<li><ol>
<li>dup函数和dup2函数讲解 <img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B9.png" alt="avatar">  </li>
<li>dup2函数讲解  <img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B10.png" alt="avatar"></li>
<li>dup2函数讲解验证思路 函数原型：<code>dup2(oldfd,newfd);</code> <img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B11.png" alt="avatar"><br>!!!函数的参数如果是指针或者引用可以输入或者输出</li>
</ol>
</li>
<li>程序和进程：<br>程序：是指编译好的二进制文件，在磁盘上，占用磁盘空间, 是一个静态的概念.<br>进程：一个启动的程序， 进程占用的是系统资源，如：物理内存，CPU，终端等，是一个动态的概念<br>程序 → 剧本(纸)<br>进程 → 戏(舞台、演员、灯光、道具…)<br>同一个程序可以在多个终端执行，类似于同一台戏可以在多个舞台演出。<br>***每启动一个程序都会有一个进程PID，即使是相同的程序多次启动也会有个不同的PID<br>并发和并行：<br>并发：在一个时间段内，一个cpu上，有多个程序在执行；<br>并行：在一个时间片，有多个程序在执行（前提是有多个cpu）<br>cpu会将一个大的时间段分成多个小的时间片，让进程轮流使用cpu的时间片<br>PCB-进程控制块（Processing Control Block）：<br>每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。<br>进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。<br>//pid_t，看到”_t”这种，代表type define定义出来的，可以对这个类型进行重新定义（相当于起了一个别名）  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B12.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B13.png" alt="avatar"><h2 id="Linux系统编程2"><a href="#Linux系统编程2" class="headerlink" title="Linux系统编程2"></a>Linux系统编程2</h2></li>
</ul>
</li>
<li>ps和kill命令：<br>ps是查看进程相关信息的，比如pid属于哪个组，哪个用户，哪个会话<br>tty代表设备终端  command执行的命令或者可执行程序  SID会话(包含组)<br>kill和read 既是命令又是函数 man kill 或者 man 2 kill<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  ps aux | grep &quot;xxx&quot;</span><br><span class="line">ps ajx(-ajx) | grep &quot;xxx&quot;</span><br><span class="line">ps -ef | grep bash</span><br><span class="line">-a：（all）当前系统所有用户的进程</span><br><span class="line">-u：查看进程所有者及其他一些信息</span><br><span class="line">-x：显示没有控制终端的进程 -- 不能与用户进行交互的进程【输入、输出】</span><br><span class="line">-j: 列出与作业控制相关的信息</span><br><span class="line">kill -l 查看系统有哪些信号</span><br><span class="line">kill -9 pid 杀死某个线程 </span><br><span class="line">kill -15 杀死进程，但是可以被进程捕获，kill 9 不能被捕获</span><br></pre></td></tr></table></figure></li>
<li>进程状态切换图：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kill -SIGSTOP <span class="number">3387</span>  暂停 （T）代表暂停</span><br><span class="line">ps -ef | grep sleep 命令查看进程</span><br><span class="line">ps -ajx 查看进程全部信息</span><br><span class="line">kill -SIGCONT <span class="number">3387</span> 继续 （S）代表sleep</span><br><span class="line">kill <span class="number">-9</span> <span class="number">3387</span> 彻底杀死进程</span><br></pre></td></tr></table></figure>
//sleep 100（100代表100s）程序运行一半时接收SIGSTOP命令挂起，然后再接收SIGCONT命令回到就绪状态，<br>然后获得cpu时间片继续运行<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B14.png" alt="avatar"></li>
<li>execl函数讲解：<br>换核不换壳<br>套路：如果想在一个进程内部执行系统命令或者是应用程序，优先应该想到如下方式：<br>先fork()，然后在子进程里面执行execl拉起可执行程序或者命令。 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line">   pid=fork();  </span><br><span class="line">   <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">   &#123;</span><br><span class="line">	execl(……)；</span><br><span class="line">   &#125;<span class="comment">//当然父进程中也可以执行这个</span></span><br><span class="line">   ```  </span><br><span class="line">   execl和execlp函数的区别：  </span><br><span class="line">   execl函数原型: <span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;  </span><br><span class="line">   execlp函数原型: <span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...<span class="comment">/* (char  *) NULL */</span>)</span></span>;  </span><br><span class="line">   <span class="comment">//path一般拉起自定义写的应用程序，比如当前目录中的hello.c生成的hello程序  </span></span><br><span class="line">   <span class="comment">//如果想执行一个ls -l 系统命令，用file，因为ls -l 的命令已经配置到PATH环境变量里了</span></span><br><span class="line">   ![avatar](/Linux系统编程/系统编程<span class="number">15.</span>png)</span><br><span class="line"><span class="number">4.</span> 循环创建子进程：  </span><br><span class="line">   正常顺序是：i=<span class="number">0</span>，父进程fork()出来一个子进程，并且fork出来的子进程拥有和父进程相同的代码段，也要返回循环。i=<span class="number">1</span>，父进程又fork出来一个子进程，并且fork出来的子进程拥有和父进程相同的代码段。并且第一次fork出来的子进程也fork出来孙子进程，拥有和子进程相同的代码，返回循环……  </span><br><span class="line">   <span class="comment">//其中父进程创建出来的子进程之间的i值是相互独立的，更改不影响其他子进程。  </span></span><br><span class="line">   <span class="comment">//个人感觉如果不添加break的话 最终除了父进程，其他子进程中的i全部变成i=2。  </span></span><br><span class="line">   <span class="comment">//因为这个不是彼此子进程相互影响，是父子之间进行改变  </span></span><br><span class="line">   循环创建兄弟子进程：其中<span class="keyword">break</span>;阻止子进程返回循环，父进程i变化到<span class="number">3</span>，i=<span class="number">0</span>、<span class="number">1</span>、<span class="number">2</span>代表是自进程  </span><br><span class="line">   sleep（<span class="number">1</span>）有延缓执行的作用</span><br><span class="line">   ![avatar](/Linux系统编程/系统编程<span class="number">16.</span>png)</span><br><span class="line"><span class="number">5.</span> fork函数：  </span><br><span class="line">   函数作用：创建子进程  ***也就是创建进程  </span><br><span class="line">   返回值：调用成功:父进程返回子进程的pid，子进程返回<span class="number">0</span>；  </span><br><span class="line">   所以父进程的返回值(pid&gt;<span class="number">0</span>)  </span><br><span class="line">   父进程中的pid值和子进程中的getpid()获得的pid一样，因为这个pid就是fork的返回值  </span><br><span class="line">   父进程中的getpid就是父进程本身的进程，fpid就是父进程的父进程  </span><br><span class="line">   如果不判断pid是否大于<span class="number">0</span>，结果下边的逻辑父子都执行  </span><br><span class="line">   在fork函数之前的<span class="built_in">printf</span>只打印一次，在fork函数之后的<span class="built_in">printf</span>打印两次  </span><br><span class="line">   getpid函数：  </span><br><span class="line">   返回自己当前进程的pid，谁调用它就返回谁</span><br><span class="line">   ![avatar](/Linux系统编程/系统编程<span class="number">17.</span>png)</span><br><span class="line"><span class="number">6.</span> fork进程就是被当前的shell（<span class="number">2815</span>）(-bash)拉起来的，  </span><br><span class="line">   <span class="number">1</span>号进程是很多进程的父进程，很多进城就是被<span class="number">1</span>号进程拉起来的  </span><br><span class="line">   父子进程共享标准输出  </span><br><span class="line">   如果sleep(<span class="number">1</span>)，父进程先回到shell，子进程后执行完的。在shell中执行的每一个进程，退出之后都会回到shell，  </span><br><span class="line">   fork创建之后 父子进程是并行执行，他们关系是父子，以后一般都会在子进程中拉起一个函数，函数拉起一个可执行程序  </span><br><span class="line">   ！！！父进程先死掉才会出现这种，子进程变成孤儿 需要多敲一个回车才能返回shell  </span><br><span class="line">   解决办法：在父进程中加一个wait(<span class="literal">NULL</span>)；阻塞保证父进程后退出，阻止孤儿进程产生  </span><br><span class="line">      - ![avatar](/Linux系统编程/系统编程<span class="number">18.</span>png)</span><br><span class="line">   父进程先死掉才会出现这种，子进程变成孤儿 需要多敲一个回车才能返回shell</span><br><span class="line">      - ![avatar](/Linux系统编程/系统编程<span class="number">19.</span>png)</span><br><span class="line"><span class="number">7.</span> 只要有父进程，子进程的内核资源就会被回收，子进程可以回收自己的用户资源，但是不能回收内核资源  </span><br><span class="line">   回收指的就是回收内核资源  </span><br><span class="line">   孤儿进程：  </span><br><span class="line">   父进程先退出，子进程就变成了孤儿进程，此时被init进程(<span class="number">1</span>号进程)领养  </span><br><span class="line">   当孤儿进程退出之后，就会被init进程回收。  </span><br><span class="line">   僵尸进程：  </span><br><span class="line">   子进程先退出，父进程没有完成对子进程的回收，此时子进程就变成了僵尸进程。  </span><br><span class="line">   如何解决僵尸进程：  </span><br><span class="line">   不能使用kill <span class="number">-9</span>杀死僵尸进程，原因是僵尸进程是一个死掉的进程，不接收信号；  </span><br><span class="line">   应该使用杀死僵尸进程的父进程的方法来解决僵尸进程：  </span><br><span class="line">   原因是：杀死其父进程可以让init进程领养僵尸进程，最后由init进程回收僵尸进程</span><br><span class="line">      - ![avatar](/Linux系统编程/系统编程<span class="number">20.</span>png)</span><br><span class="line"><span class="number">8.</span> 父子进程不能共享全局变量：  </span><br><span class="line">   写时复制，读时共享  </span><br><span class="line">   ``ps -ef | grep bash``  </span><br><span class="line">   管道实现进程间通信：  </span><br><span class="line">   管道两边都是进程，两个进程之间通信用的就是管道，ps输出写到管道里，grep bash读从管道里  </span><br><span class="line">   从虚拟空间映射到物理内存，和从物理内存映射到虚拟空间的过程是MMU内存管理单元做的</span><br><span class="line">      - ![avatae](/Linux系统编程/系统编程<span class="number">21.</span>png)</span><br><span class="line">      - ![avatae](/Linux系统编程/系统编程<span class="number">22.</span>png)</span><br><span class="line"><span class="number">9.</span> wait函数：  </span><br><span class="line">    函数原型：<span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);  </span><br><span class="line">    返回值： &gt;<span class="number">0</span>：回收的子进程的PID，<span class="number">-1</span>：没有子进程  </span><br><span class="line">    参数：status：子进程的退出状态  </span><br><span class="line">    <span class="keyword">if</span>(WIFEXITED(status))&#123;WEXITSTATUS(status)&#125;  </span><br><span class="line">    <span class="keyword">if</span>(WIFSIGNALED(status))&#123;WTERMSIG(status)&#125;  </span><br><span class="line">    wait函数在父进城中调用，并且是阻塞函数  </span><br><span class="line">    waitpid函数：  </span><br><span class="line">    函数原型：<span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status, in options)</span></span>;  </span><br><span class="line">    参数：  </span><br><span class="line">    pid：  </span><br><span class="line">    pid&gt;<span class="number">0</span>：表示等待指定的子进程  </span><br><span class="line">    pid=<span class="number">-1</span>：表示等待任意子进程  </span><br><span class="line">    status：同wait函数  </span><br><span class="line">    options：  </span><br><span class="line">    <span class="number">0</span>：表示阻塞   </span><br><span class="line">    WNOHANG：表示不阻塞  </span><br><span class="line">    返回值：  </span><br><span class="line">    &gt;<span class="number">0</span>：回收的子进程的PID  </span><br><span class="line">    =<span class="number">0</span>：若options取值为WNOHANG，则表示子进程还活着  </span><br><span class="line">    <span class="number">-1</span>：表示已经没有子进程了  </span><br><span class="line">    注意：调用一次waitpid活着wait函数只能回收一个子进程。  </span><br><span class="line">    如果有三个子进程，需要回收四次，最后一次返回<span class="number">-1</span></span><br><span class="line">      - ![avatar](/Linux系统编程/系统编程<span class="number">23.</span>png)</span><br><span class="line">    ```c</span><br><span class="line">    <span class="keyword">int</span> main()</span><br><span class="line">      &#123;</span><br><span class="line">          <span class="comment">//创建子进程</span></span><br><span class="line">          <span class="keyword">pid_t</span> pid =fork();</span><br><span class="line">          <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)<span class="comment">//fork失败的情况</span></span><br><span class="line">          &#123;   </span><br><span class="line">              perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">          &#125;   </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)<span class="comment">//父进程</span></span><br><span class="line">          &#123;   </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;father:[%d],pid ==[%d],fpid==[%d]\n&quot;</span>,pid,getpid(),getppid());</span><br><span class="line">              <span class="keyword">int</span> status;</span><br><span class="line">              <span class="comment">//pid_t wpid=wait(&amp;status);</span></span><br><span class="line">              <span class="comment">//pid_t wpid=waitpid(pid,&amp;status,0);//pid代表当前的子进程&gt;0, 0代表阻塞</span></span><br><span class="line">              <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">              &#123;   </span><br><span class="line">                  <span class="keyword">pid_t</span> wpid = waitpid(<span class="number">-1</span>,&amp;status,WNOHANG);<span class="comment">//-1表示等待任意子进程，WNOHANG表示不阻塞</span></span><br><span class="line">                  <span class="comment">//printf(&quot;wpid==[%d]\n&quot;,wpid);</span></span><br><span class="line">                  <span class="keyword">if</span>(wpid&gt;<span class="number">0</span>)<span class="comment">//有子进程退出情况</span></span><br><span class="line">                  &#123;   </span><br><span class="line">                      <span class="keyword">if</span>(WIFEXITED(status))<span class="comment">//正常退出</span></span><br><span class="line">                      &#123;   </span><br><span class="line">                          <span class="built_in">printf</span>(<span class="string">&quot;child normal exit,status==[%d]\n&quot;</span>,WEXITSTATUS(status));</span><br><span class="line">                      &#125;   </span><br><span class="line">                      <span class="keyword">else</span> <span class="keyword">if</span>(WIFSIGNALED(status))<span class="comment">//信号被杀死</span></span><br><span class="line">                      &#123;   </span><br><span class="line">                          <span class="built_in">printf</span>(<span class="string">&quot;child killed by signal,signo==[%d]\n&quot;</span>,WTERMSIG(status));</span><br><span class="line">                      &#125;   </span><br><span class="line">                  &#125;   </span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">0</span>)<span class="comment">//子进程还活着</span></span><br><span class="line">                  &#123;   </span><br><span class="line">                      <span class="comment">//printf(&quot;child is living,wpid==[%d]\n&quot;,wpid);</span></span><br><span class="line">                  &#125;   </span><br><span class="line">                  <span class="keyword">else</span> <span class="keyword">if</span>(wpid==<span class="number">-1</span>)<span class="comment">//没有子进程了</span></span><br><span class="line">                  &#123;   </span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;no child is living,wpid==[%d]\n&quot;</span>,wpid);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;   </span><br><span class="line">              &#125;   </span><br><span class="line">              sleep(<span class="number">100</span>);</span><br><span class="line">          &#125;   </span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)<span class="comment">//子进程</span></span><br><span class="line">          &#123;   </span><br><span class="line">              <span class="built_in">printf</span>(<span class="string">&quot;child:pid==[%d],fpid==[%d]\n&quot;</span>,getpid(),getppid());</span><br><span class="line">              sleep(<span class="number">1</span>);</span><br><span class="line">              <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">          &#125;   </span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;   </span><br></pre></td></tr></table></figure></li>
<li>IPC，InterProcess Communication 进程间通信 inter什么什么之间的意思<br>两个进程要想完成数据交换(通讯)，必须通过内核；<br>一个进程将数据写到内核，然后另一个进程从内核中读走数据<br>现今常用的进程间通信方式有：<br>1管道 (使用最简单)<br>2信号 (开销最小)<br>3共享映射区 (无血缘关系)<br>4本地套接字 (最稳定)<br><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B24.png" alt="avatar"></li>
<li>pipe用于父子进程间通信：<ul>
<li>父进程创建pipe</li>
<li>父进程调用fork函数创建子进程</li>
<li>父进程关闭一端</li>
<li>子进程关闭一端</li>
<li>父进程和子进程分别值执行read和write操作</li>
</ul>
</li>
<li>父子进程间完成：<code>ps aux | grep bash</code><br>需要用到两次重定向dup2函数<ol>
<li>创建管道pipe</li>
<li>创建子进程fork</li>
<li>在父进程中关闭读端fd[0]</li>
<li>在子进程中关闭写端fd[1]</li>
<li>在父进程中将标准输出重定向到管道的写端</li>
<li>在子进程中将标准输入重定向到管道的读端</li>
<li>在父进程中用execl函数执行ps aux命令</li>
<li>在子进程中用execl函数执行grep bash命令</li>
<li>在父进程中回收子进程wait函数</li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B25.png" alt="avatar"></li>
</ol>
</li>
<li>管道的读写行为：<br>-读操作：<br>有数据：read正常读，返回读出的字节数<br>无数据：写端全部关闭：read解除阻塞，返回0, 相当于读文件读到了尾部<br>没有全部关闭：read阻塞<br>-写操作：<br>读端全部关闭：管道破裂，进程终止, 内核给当前进程发SIGPIPE信号<br>读端没全部关闭：<ul>
<li>缓冲区写满了  write阻塞</li>
<li>缓冲区没有满  继续write  </li>
</ul>
</li>
</ol>
<p>   如何查看管道缓冲区大小：<br>   命令<br>   <code>ulimit -a  pipe size    (512 bytes, -p) 8   ==4M  </code><br>   <code>ulimit -c unlimited 改变core文件大小为无限大小  </code><br>   函数<br>   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe size==[%ld]\n&quot;</span>, fpathconf(fd[<span class="number">0</span>], _PC_PIPE_BUF));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;pipe size==[%ld]\n&quot;</span>, fpathconf(fd[<span class="number">1</span>], _PC_PIPE_BUF));</span><br></pre></td></tr></table></figure><br>   <img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B26.png" alt="avatar"><br>14. 管道（pipe）： 在fork之前创建管道</p>
<ul>
<li>1，管道的本质是一块内核缓冲区 内部使用环形队列实现</li>
<li>管道有读写两端，读写两端是两个文件描述符</li>
<li>数据的流向是从管道的写端流到数据的读端（数据的流向是单向的）</li>
<li>数据读走之后，在管道中就消失了。</li>
<li>pipe只能用于有血缘关系的进程间通讯</li>
<li>管道的读写两端是阻塞的。 read没有数据阻塞 write写满了阻塞</li>
<li>管道的大小默认为4K，但是会根据实际情况做适当调整  pipe函数：<br>函数原型：<code>int pipe(int fd[2]);</code>      整型数组<br><code>int pipe(int fd[2])；int pipe(int *fd); sizeof(fd)的值 8  4  </code><br>函数返回值：<br>若函数调用成功，fd[0]存放管道的读端，fd[1]存放管道的写端<br>返回 int fd[2]，因为返回值只有一个，所以返回数组。<br>其中参数可以数组或者指针，因为数组名就是首元素地址 也是指针<br>读写管道的实质是操作内核缓冲区<br>个人理解：创建管道就是创建两个文件描述符<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B27.png" alt="avatar"></li>
</ul>
</li>
</ul>
<ol start="15">
<li><p>fifo完成两个进程之间通信的思路：<br>进程A:</p>
<ul>
<li>创建一个fifo文件：mkfifo命令或者使用mkfifo函数</li>
<li>open fifo文件，获得一个文件描述符fd</li>
<li>写fifo文件 —write(fd,”xxx”,…)</li>
<li>关闭fifo文件 —close(fd)；最新显示write中不能close</li>
</ul>
<p>进程B：</p>
<ul>
<li>打开fifo文件，获得文件描述符fd</li>
<li>读fifo文件—read(fd,buf,sizeof(buf));</li>
<li>关闭fifo文件 — close(fd);</li>
</ul>
<p>access函数：<br>可以检查文件是否存在  还有可以判断文件权限 R_OK W_OK X_OK  这权限如果不指定 应该是当前用户的<br>函数原型：<code>int access(const char *pathname, int mode);  </code><br>比如：<code>int ret=access(&quot;./myfifo&quot;,F_OK); </code><br>返回值：如果是0 文件存在 如果 不等于0 文件不存在<br>个人理解：至少需要一个文件，一个管道文件，七种系统类型文件之一p</p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B28.png" alt="avatar"></li>
</ul>
</li>
<li><p>getchar(); //等待一个回车 马上结束<br>#if 0<br>……<br>#endif   //注释的方法<br>内存操作函数：memcpy memset malloc<br>获取文件大小：  </p>
<ul>
<li>lseek返回值  文件打开用这个</li>
<li>stat函数  文件没有打开用这个</li>
</ul>
<p>给一个没有读端的管道写数据会产生SIGPIPE信号  kill -l   第十三条</p>
</li>
<li><p>共享映射区：存储映射I/O (Memory-mapped I/O)<br>mmap函数：<br>函数原型：void <em>mmap(void <em>addr, size_t length, int prot, int flags, int fd, off_t offset);<br>参数：<br>addr：一般传NULL，表示让内核去指定一个内存起始地址<br>length：文件大小&gt;0 文件大小=0 不能创建映射区<br>方法：lseek或者stat函数<br>prot：映射区的保护方式 PROT_READ PROT_WRITE  PROT_READ | PROT_WRITE<br>这个权限小于open函数权限<br>flags：映射区的特性<br>MAP_SHARED：对映射区的修改会反映到文件中（可以对文件进行修改）</em>*</em>这个修改是指通过内存修改文件<br>MAP_PRIVATE：对映射区的修改不会对文件产生影响<br>fd：打开的文件描述符 不是管道的文件描述符fd[1] 因为管道文件描述符是阻塞的<br>fd=open()；<br>offset：从文件的哪个位置开始映射，一般传0 。一般是0或者4k的整数倍<br>返回值：成功返回映射区的首地址（有可能是addr系统指定的起始位置）<br>munmap函数：<br>函数作用：释放由mmap函数建立的存储映射区<br>函数原型：int munmap(void *addr, size_t length);<br>函数参数：addr 是mmap返回的指针(映射区首地址)  length：映射区大小<br>使用mmap函数建立匿名映射：  应用于有血缘关系的进程间通信</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">void</span> * addr = mmap(<span class="literal">NULL</span>, <span class="number">4096</span>, PROT_READ|PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">  MAP_ANONYMOUS与MAP_SHARED一起使用，而且fd指定为<span class="number">-1</span></span><br><span class="line">  ```     </span><br><span class="line">  个人理解：通过<span class="built_in">memcpy</span>将<span class="built_in">string</span>写到addr的文件中，在通过<span class="built_in">memcpy</span>把buf从addr中读出来，addr空间是根据文件len大小开辟的</span><br><span class="line">  代码实现：</span><br><span class="line">  ```c</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="comment">//使用mmap函数建立共享映射区</span></span><br><span class="line">  <span class="keyword">int</span> fd =open(<span class="string">&quot;./test.log&quot;</span>,O_RDWR);</span><br><span class="line">  <span class="keyword">if</span>(fd&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">&quot;open error&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">int</span> len=lseek(fd,<span class="number">0</span>,SEEK_END);</span><br><span class="line">  <span class="keyword">void</span> *addr=mmap(<span class="literal">NULL</span>,len,PROT_READ|PROT_WRITE,MAP_PRIVATE,fd,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span>(addr==MAP_FAILED)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">&quot;mmap error&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//创建子进程</span></span><br><span class="line">  <span class="keyword">pid_t</span> pid=fork();</span><br><span class="line">  <span class="keyword">if</span>(pid&lt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      perror(<span class="string">&quot;fork error&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid&gt;<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line"><span class="built_in">memcpy</span>(addr,<span class="string">&quot;hello world&quot;</span>,<span class="built_in">strlen</span>(<span class="string">&quot;hello world&quot;</span>));</span><br><span class="line">      wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid==<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">char</span> *p=(<span class="keyword">char</span> *)addr;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;[%s]&quot;</span>,p);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>！！！addr相当于全局变量、堆、栈，不能共享。<br>！！！但是对于这些addr，我们只用它的地址，它的值，可以共享<br>！！！可以共享文件描述符<br>实现原理：那个图的含义<br>目的就是把文件映射到内存，这样A进程可以读内存 B进程也可以读内存，实现两个进程之间通讯<br>实际上两个进程之间通讯是借助了这个文件。<br>如果A进程和B进程想使用mmap进程通讯过程是：<br>A进程打开那个文件映射到内存，B进程也打开那个文件映射到内存，因为是相同文件，所以内存是相同一块，然后可以操作了  </p>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B29.png" alt="avatar"></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" data-id="ckp3biliu000c4suehppvhdbl" data-title="Linux系统编程" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C++" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/24/C++/" class="article-date">
  <time class="dt-published" datetime="2021-04-24T13:50:08.924Z" itemprop="datePublished">2021-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/24/C++/">C++</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h2><ol>
<li>Qt调用system()编译c文件时失败：<br>system(“gcc D:\Qt\QtProjects\01IDE\hello12.c -o D:\Qt\QtProjects\01IDE\hello12”);<br>原因：gcc环境配置之后，在cmd中可以直接gcc命令就可以生成exe，但是在Qt中输入全路径gcc，还是无法生成exe。<br>解决办法：重启一下电脑 这他妈的！！！</li>
<li>ui-&gt;label(.)-&gt;setText();<br>ui是系统定义好的指针，指向label代表要操作label对象，然后实现label对象中的方法<br>在QT中”-&gt;”和”.”会自动匹配，只要按点就可以</li>
<li>C++中分开定义函数时 结构体(类)中声明，类外定义函数，但是需要加上作用域 告诉编译器 函数属于结构体(类) void Test : : setA(){a=10;}<br>静态函数的调用方式有两种，类名或者对象名<br>Test : :fun();obj.fun(); “Test::”类名调用 静态函数的标志</li>
<li>在调用QByteArray.data()之前，必须要先显示储存这个QByteArray。像这样<code>const char *buf = str.toString().data();</code>会使程序崩溃，因为QByteArray没有被储存，调用data()前是不存在的，必须先显式调用一次fromUnicode()，再调用data()。<br>把QString 转化为 char* 方法：<ol>
<li>先把QString类型变为QByteArray类型</li>
<li>从QByteArray类型再转为char* 类型 </li>
<li>如果使用标准C函数，如果有中文必须是gbk编码 比如fopen()</li>
<li><img src="/C++/C++1.png" alt="avatar"></li>
</ol>
</li>
<li>两者不一样  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cchar *p1=<span class="string">&quot;hello world!&quot;</span>; </span><br><span class="line"><span class="keyword">char</span> str[]=<span class="string">&quot;hello world&quot;</span>; </span><br></pre></td></tr></table></figure>
<ul>
<li>p1 代表指针变量存的是字符串在字符常量区的地址  </li>
<li>指针变量p1 里边存放地址，但是本身也有地址</li>
<li>str 字符数组 里边存放的是字符 如果存的是指针，就是指针数组  </li>
<li>str本身地址就是元素的首地址 然后每个子元素都有自己地址  </li>
<li>一般指针指向的都是数组的首元素地址</li>
<li><img src="/C++/C++3.png" alt="avatar"></li>
</ul>
</li>
<li>前置++返回的是引用，后置++返回的是值。  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;++(++a)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//允许前置++</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(a++)++&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//不允许后置++</span></span><br><span class="line"><span class="keyword">int</span> b=<span class="number">0</span>；<span class="built_in">cout</span>&lt;&lt;（b++）++&lt;&lt;<span class="built_in">endl</span>；<span class="comment">//err,因为b++返回的已经不是b了，  </span></span><br><span class="line">只能是值的形式返回。局部对象引用形式返回会操作非法内存</span><br></pre></td></tr></table></figure></li>
<li>前置和后置性能对比：前置效率更高，因为前置少创建一个临时对象。后置用值的形式返回会创建一个新的对象，调用拷贝构造</li>
<li>函数参数传递分为值传递和地址传递（指针）还有引用传递（实际上也是指针传递），地址传递也可以是间接赋值，可以改变main函数中变量（属性）值<br>值传递会产生一个拷贝的工作，为了提高效率使用引用传递或者地址传递，所以拷贝构造函数不能用值传递，会变成递归。值传递的本质就是调用拷贝构造函数</li>
<li>调用拷贝构造函数的方式 值传递 Person p =p1<br>不要返回一个局部对象的引用，因为引用会被释放掉，而值不会，会根据值创建出来一个新的值</li>
<li>函数参数中int *p，代表指针 形参中是指针，实参中是&amp;取地址<br>函数参数中int &amp;p，代表引用 &amp;在函数形参中不是取地址<br>引用只能引用变量（栈上合法） int &amp;a=10；//10存在符号表，以键值对的形式存储（堆区）<br>但是coust int &amp;a=10；//coust 在栈区 int temp=10，int&amp;a=temp;<br>加coust防止修改a<br>函数调用的时候只要函数名和参数类型一样，至于参数是值传递还是地址传递还是引用传递无所谓，因为函数的重载就是函数的返回值类型和函数名一样，只是参数的类型和个数或者是否有coust决定重载，C语言中函数可以没有return，C++中必须有</li>
<li>```c<br>Struct Person<br>{<br>  int age；<br>  void func()<br>  {age++;}<br>}//C++中结构体可以有函数，<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">    int age是结构体Person的一个属性 函数可以修改属性，c语言中不能在结构体中创建函数，所以没办法修改属性</span><br><span class="line">12. 1. 三目运算符在C语言下返回的是值，在C++语言下返回的是变量</span><br><span class="line">    2. C语言下coust是伪常量，不可以初始化数组</span><br><span class="line">    3. C++coust修饰的变量是常量，可以用来初始化数组</span><br><span class="line">    4. C语言中coust修饰全局变量默认的是外部链接属性</span><br><span class="line">    5. C++coust修饰全局变量默认的是内部”链接属性“（可以添加一个关键字extern提高作用域，c中默认添加extern，c++中不添加）</span><br><span class="line">    6. 局部变量中coust int b&#x3D;10；（只有这种不分配内存）b放在常量区（C++中符号表以键值对形式存储），int temp&#x3D;b取地址的时候编译器会临时分配空间temp，p指向的是temp，int *p&#x3D;&amp;temp ，*p&#x3D;200；结果不会变</span><br><span class="line">    7. coust使用普通变量初始化，b分配在栈上不是常量区，是可以修改b的值，int a&#x3D;10；coust int b&#x3D;a；int*p&#x3D;（int*）&amp;b；</span><br><span class="line">    8. int a&#x3D;10；coust int b&#x3D;a；分配内存</span><br><span class="line">    9. 分配内存是分配到栈上</span><br><span class="line">    10. coust int &amp;ref&#x3D;10；不加coust报错，有coust相当于写成 int temp&#x3D;10   </span><br><span class="line">    coust int &amp;ref&#x3D;temp； 开辟临时内存,常量引用的使用场景 修饰函数中的形参 防止误操作</span><br><span class="line">    11. coust修饰指针 int *p 和coust int *P不一样，第二个是只读</span><br><span class="line">13. 构造函数调用方法：</span><br><span class="line">    1. 1括号法 Person p(10)；</span><br><span class="line">    2. 2显示法 Person p1&#x3D;Person(10); </span><br><span class="line">    3. Person(10);匿名对象 特点：当前行执行完后 立即释放不要用拷贝构造函数初始化 匿名对象 Person(p1); 编译器认为Person p1 是对象实例化 如果有p1 p1就重定义了</span><br><span class="line">14. 如果在cpp文件中 extern “C”void show（）；则不需要#include“test.h”头文件，因为可以找到show函数  </span><br><span class="line">    如果在test.h文件中添加extern “C”，在cpp文件中需要添加#include“test.h”头文件</span><br><span class="line">C++函数有重载，会对函数名称做修饰，导致调用c语言函数链接失败</span><br><span class="line">15. 引用的目的就是起别名(外号),但是都是指向一块内存  </span><br><span class="line">    int a&#x3D;10；int &amp;b&#x3D;a； b&#x3D;100；(在b&#x3D;100的时候，b已经是引用类型int&amp;)  </span><br><span class="line">    输出a&#x3D;100，b&#x3D;100；  </span><br><span class="line">    &amp;在等号左边就是引用，等号右边就是取地址,引用的基本语法 类型 &amp;别名&#x3D;原名 别名就是引用  </span><br><span class="line">    引用的本质在C++中实现是一个指针变量</span><br><span class="line">    &#96;&#96;&#96;c</span><br><span class="line">    Type&amp;ref&#x3D;val；</span><br><span class="line">    &#x2F;&#x2F;Type* const ref&#x3D;&amp;val;&#x2F;&#x2F;指针常量必须初始化，而且ref的值不可以修改</span><br><span class="line">    !!!ref的值就是指针指向，即地址（指针）</span><br><span class="line">    &#x2F;&#x2F;Type* const ref&#x3D;&amp;val;  ref&#x3D;NULL；&#x2F;&#x2F;err，指针的值，只读</span><br><span class="line">    &#x2F;&#x2F;const Type* ref&#x3D;&amp;val;&#x2F;&#x2F;指针指向的内存不可以修改</span><br><span class="line">    !!!const修饰* 类似于解引用*ref，指针指向的值（内存）</span><br><span class="line">    ref&#x3D;20；&#x2F;&#x2F;内部发现ref是引用之后，自动转换*ref&#x3D;20；</span><br></pre></td></tr></table></figure>
<img src="/C++/C++5.png" alt="avatar"></li>
<li><ol>
<li>ostream&amp; cout对象全局也只有一个，所以cout作为参数时要用应用的形式传入进来，返回值是ostream的引用实现链式操作  </li>
<li>out可以改成out，因为是引用 可以起别名  </li>
<li>通过类创建对象过程   称为 实例化对象（自动调用构造函数初始化对象）动态对象创建 new 类似于C语言中malloc方法 在堆上开辟空间对象创建之后 默认调用构造函数和析构函数</li>
<li>在写拷贝构造函数的时候，不用判断，因为构造就是从无到有。</li>
<li>=赋值释放空间的时候，发生浅拷贝，重复释放同一块内存。深拷贝重新new一块内存</li>
<li>Person p；和Person *p=new Person；区别就是一个是对象一个是指针对象</li>
<li>空指针访问成员函数_this用法：<ol>
<li>如果成员函数中没有用到this指针，可以用空指针调用成员函数</li>
<li>如果成员函数中用到了this，那么这个this需要加判断，防止代码down掉</li>
<li>this指针 指向 被调用的成员函数 所属的对象</li>
<li>this指针可以解决名称冲突</li>
<li>this指针 隐式加在每个成员函数中</li>
<li>*this 就是本体 ==Person p1；中的p1</li>
<li>p1.personAddPerson(p2).personAddPerson(p2).personAddPerson(p2);//链式编程</li>
</ol>
</li>
<li>值传递就是调用拷贝构造函数，<code>Person p=p1；&lt;=&gt;Person p(p1);&lt;=&gt;Person p=Person(p1);</code></li>
</ol>
</li>
<li>重写函数调用符号“（）”，myPrint(“hello world”);<br>当myPrint调用小括号的时候就相当于调用operator()函数了，传的参数hello world就是string text<br>仿函数 本质是一个对象 函数对象<br>运算符重载不要重载&amp;&amp;、||，没办法模拟短路特性<br>重写“==”符号时，operator==后边（）中的参数就是调用者==右边的数<br>重写“（）”符号时，operator()后边（）中的参数就是调用者（）中的数<br>重写“-&gt;”符号时，operator-&gt;后边（）中没有参数，所以调用者只重写-&gt;sp-&gt;showAge();//本质sp-&gt;-&gt;showAge();编译器简化为sp-&gt;showAge();</li>
<li>静态成员的访问方式有两种(非静态只有第一种):<ol>
<li>通过对象进行访问（自动调用构造函数初始化对象）</li>
<li>通过类名直接访问（静态成员不属于某个对象）</li>
<li>“静态成员变量”也是有访问权限的，私有变量类外访问不到</li>
<li>静态成员初始化不受访问权限影响，但是创建对象访问的时候会受到影响</li>
<li>单例模式中“静态成员（指针）”写在private中，但是在类外实例化（区别m_A是在类上，而new Person不在类对象上）</li>
<li>static <em>Printer</em>printer；编译阶段就分配内存</li>
<li>静态变量是在编译阶段就分配空间，对象还没创建时就已经分配空间</li>
</ol>
</li>
<li><ol>
<li>写文件是 o –输出 ofstream  输出到文件中</li>
<li>读文件是 i  –输入 ifstream   输入到文件中</li>
<li>cin&gt;&gt;buf  将缓冲区的字符存到buf中</li>
</ol>
</li>
<li>char类型可以转化成int类型,char引用不能转成int类型引用，引用不能转换<br>多态实现原理，父类引用指向子类对像<br>利用cin.get获取字符串的时候，换行符留在缓冲区中<br>案例1中判断用户输入内容是数字还是字符串，从缓冲区中读取</li>
<li>利用初始化列表语法  显示调用父类中的其他构造函数<br>Son2：和Son2()：区别，前者是继承 后者 初始化列表<br>Son2（int a =2000）：Base2(a)在QT中默认生成的代码，相当于用一个参数传给父类做初始化,最后子类继承打印m_A<br><img src="/C++/C++6.png" alt="avatar"></li>
<li>继承优点：<ol>
<li>减少重复的代码，提高代码复用性</li>
<li>重复的代码写到抽象类里</li>
<li>父类中 构造、析构、拷贝构造 、operator=  是不会被子类继承下去的</li>
<li>子类可以继承成员函数和成员变量，private的属性也会继承，由于访问权限会被编译器隐藏（但是内存不变）</li>
<li>通过类名的方式 访问 父类作用域下是m_A静态成员变量<code>cout&lt;&lt;&quot;Base中的m_A=&quot;&lt;&lt;Son::Base::m_A&lt;&lt;endl;</code></li>
<li>```C<br>template&lt;class T1,class T2&gt;<br>//告诉下边有T1 T2不要报错<br>//方便用户传入，当子类继承父类的类模板时<br>template&lt;class T1,class T2&gt;<br>class Son2：Public Base2<T2><br>{<br>public::<br>T1 obj;<br>}//T2传给父类 T1传给自己<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">23. 类对象作为类中成员：</span><br><span class="line">    1. 当其他类对象 作为本类成员，先构造其他类对象，再构造自身，析构的顺序和构造相反</span><br><span class="line">    2. 图中的传递方式为：Person p中的张三-&gt;Person有参构造函数中的string name-&gt;m_Name(name)中从m_Name&#x3D;name,然后string m_Name&#x3D;name，调用有参构造函数（因为赋初值了）</span><br><span class="line">    3. Phone m__Phone是phone数据类型，赋初值的时候调用的是string类型，所以调用phone的有参构造函数</span><br><span class="line">    4. ![AVATAR](&#x2F;C++&#x2F;C++7.png)</span><br><span class="line">24. 当发生&quot;虚继承&quot;后，sheep和tuo类中 继承了一个  vbptr指针   虚基类指针   指向的是一个 虚基类表  vbtable </span><br><span class="line">    - 虚函数内部工作原理中：</span><br><span class="line">    - &#96;&#96;&#96;C</span><br><span class="line">      SheepTuo st; 	st.m_Age&#x3D;10;</span><br><span class="line">      &amp;st取对象地址 *（int*）&amp;st 代表地址传成int*步长，然后解引用到虚基类表中， </span><br><span class="line">      但是虚基类表是个数组，数组名代表首元素地址，</span><br><span class="line">      所以*（int*）&amp;st还是个地址 </span><br><span class="line">      &#x2F;&#x2F;通过Sheep找到 偏移量 在多态中找到的不是偏移量而是地址</span><br><span class="line">      *（（int*）*（int*）&amp;st+1）&#x3D;&#x3D;8 </span><br><span class="line">      &#x2F;&#x2F;通过偏移量访问m_Age</span><br><span class="line">      ((Animal)(char*)&amp;st+*（（int*）*（int*）&amp;st+1）)-&gt;m_Age</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>多态中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> doSpeak（Animal&amp; animal）</span><br><span class="line"><span class="comment">//Animal&amp;animal =cat；父类引用指向子类对象 </span></span><br><span class="line">AbstractCalculater *calculater =<span class="keyword">new</span> AddCalculator；</span><br><span class="line"><span class="comment">//1建立父类和子类关系 2是用父类指针调用子类对象，实现父类的多态</span></span><br></pre></td></tr></table></figure>
函数名就是函数地址<br>C\C++默认调用惯例 __cdecl<br>多态的调用惯例是 _stdcall<br>纯虚函数不能创建对象，所在的类是抽象类，如果子类继承纯虚函数不实现，那么子类也是抽象类不能创建对象<br>子类在堆区开辟空间需要调用析构函数，所以父类中需要写虚析构函数或者纯虚构函数</li>
<li>异常变量的生命周期<ol>
<li>抛出的是 throw MyException();  catch (MyException e) 调用拷贝构造函数 效率低（会创建一个临时对象）</li>
<li>抛出的是 throw MyException();  catch (MyException &amp;e) 只调用默认构造函数 效率高 推荐</li>
<li>抛出的是 throw &amp;MyException(); catch (MyException *e) 对象会提前释放掉，不能在非法操作</li>
<li>抛出的是 new MyException();   catch (MyException *e) 只调用默认构造函数 自己要管理释放</li>
<li>异常变量的生命周期中使用指针会提前释放掉，而使用引用不会，因为会发生赋值，会提高引用生命周期，提高到等号左边<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2></li>
</ol>
</li>
<li><ol>
<li>List容器排序默认时升序，改变成降序需要在sort函数中添加回调函数或者仿函数对象（匿名对象）sort（v.begin（），v.end（），MyCompare（））；参考C提高06-12</li>
<li>set容器排序默认时升序，改变成降序在插入之前改变容器，因为它是只读，set&lt;int，myCompareint&gt;s；myCompareint是仿函数数据类型</li>
<li>map容器排序默认时升序，改变成降序在插入之前改变容器，因为它是只读，set&lt;int，int，myCompareint&gt;m；myCompareint是仿函数数据类型</li>
<li>find_if(v.begin(),v.end(),GreaterThan20())；中GreaterThan20（）是匿名对象</li>
<li>for_each(v.begin(),v.end(),myPrintInt);//myPrintInt代表函数指针或者回调函数名，或者匿名对象</li>
</ol>
</li>
<li>原生指针也是迭代器,所以迭代器可以理解为指针(为了让我们访问到容器中的元素)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;<span class="comment">//创建一个vector容器 容器中存放元素类型是int类型  类似于显示指定类型 </span></span><br><span class="line">Person&lt;string,int&gt; p1(&quot;孙悟空&quot;，100)；</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itBegin=v.begin();</span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator代表在vector&lt;int&gt;容器作用域下的迭代器 迭代器就是指针</span></span><br><span class="line">v.begin()起始迭代器 “指向”容器中第一个数据</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*itBegin&lt;&lt;<span class="built_in">endl</span>;<span class="comment">// *itBegin代表&lt;&gt;中的内容（解引用）</span></span><br><span class="line"><span class="comment">//在for_each(v.begin(),v.end(),myPrintInt);</span></span><br><span class="line"><span class="comment">//lambda表达式 匿名函数 []代表lambda表达式标志 []（）&#123;&#125;</span></span><br><span class="line">for_each(v.begin(),v.end(),[](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span>&lt;&lt;val&lt;&lt;“”；&#125;);</span><br><span class="line"><span class="keyword">void</span> myPrintInt（<span class="keyword">int</span> val）</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span>&lt;&lt;val&lt;&lt;“”；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
v.begin()代表起始迭代器，其中myPrintInt代表函数指针或者回调函数名（函数名就是函数指针），其中for_each函数系统底层类似于以前C中打印函数（封装了这个桥梁），我们只需要写回调函数和底层填写回调函数即可，不用写桥梁</li>
<li>自定义数据类型Person（class Person）的对象模型初探<br>“&lt;&lt;”代表写“ &gt;&gt;”代表读，读和写都是从文件和缓冲区角度考虑，读代表从缓冲区（文件）读到屏幕中<br>arr[5]其中arr这个数组名除了sizeof和取地址，其他情况都是数组的首地址</li>
<li><ol>
<li>循环创建对象“数据”，但是每个对象数据尾插到v容器中都是有地址的，然后player对象和worker对象多次被重写,push_back尾插只插数据，是一种数据结构</li>
<li>将字符串转成const char* 需要用到”c_str()”<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str=<span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str2=s.c_str();</span><br></pre></td></tr></table></figure></li>
<li>```c<br>coust char* 转string 利用string的有参构造<br>coust char* 可以隐式类型转换为 string<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">4. 高阶排序只需要在回调函数中添加一个if语句</span><br><span class="line">5. find_if-&gt;_Find_if源码 返回是一个迭代器参数,其中参数是两个迭代器和一个匿名对象 v.begin()-&gt;_InIt _First  GreaterThan20()-&gt;_Pr _Pred  </span><br><span class="line">_Find_if本质就是一个for循环，底层如果满足val&gt;20条件就break；返回当前迭代器，不满足返回end迭代器</span><br><span class="line">6. &#96;&#96;&#96;c</span><br><span class="line">   &#x2F;&#x2F;函数对象 又叫仿函数 本质就是对象 </span><br><span class="line">   void test01（）</span><br><span class="line">   &#123;</span><br><span class="line">     Person p（100）；&#x2F;&#x2F;开辟在栈上</span><br><span class="line">     Person *p&#x3D;new Person；&#x2F;&#x2F;开辟咋堆区</span><br><span class="line">   &#125;</span><br><span class="line">   &#x2F;&#x2F;有时候仿函数也充当一种数据类型</span><br><span class="line">   class MyPrint</span><br><span class="line">   &#123;</span><br><span class="line">   public：</span><br><span class="line">   void operator（）（int num）</span><br><span class="line">   &#123;</span><br><span class="line">     cout &lt;&lt;num&lt;&lt;endl;</span><br><span class="line">     m_Count++;	</span><br><span class="line">   &#125;</span><br><span class="line">   int m_Count&#x3D;0;</span><br><span class="line">   &#125;</span><br><span class="line">   void doPrint（MyPrint myprint，int num）</span><br><span class="line">   &#123;</span><br><span class="line">     myPrint（num）；&#x2F;&#x2F;函数对象作为参数传递，因为本质是一个数据类型</span><br><span class="line">   &#125;</span><br><span class="line">   void test03（）</span><br><span class="line">   &#123;</span><br><span class="line">     doPrint（MyPrint（），1000）；&#x2F;&#x2F;匿名对象</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><ol>
<li>set的成员函数find和string中的find返回值不一样，set返回值是迭代器，string返回值是int类型 除了string是int类型 其他返回的都是迭代器  </li>
<li>set迭代器只读 一旦插入不能修改  </li>
<li>set&lt;int，仿函数&gt;s是set&lt;&gt;s的重载，int是个数据类型，所以必须放仿函数，因为类算是自定义数据类型，回调函数不是数据类型   </li>
<li>仿函数本质是类，其中重载“（）”运算符  </li>
<li>set&lt;int，compare&gt;s中只需要传入仿函数就可以实现从大到小排序，是因为set底层调用仿函数  类似于list中的remove删除自定义类型数据，需要重写”==”运算符，因为底层用到了== </li>
</ol>
</li>
<li>stl中主要用到类模板和函数模板，都是泛型编程<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reverse反转 reserve（<span class="keyword">int</span> len） 预留</span><br><span class="line"><span class="comment">//逆序遍历</span></span><br><span class="line"><span class="keyword">for</span>（<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;：：reverse_iterator it=v.rbegin()；it!=v.rend()；it++）&#123;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>；&#125;</span><br><span class="line"><span class="comment">//类名加小括号 代表匿名vector&lt;int&gt;(v).swap(v); </span></span><br><span class="line"><span class="comment">//巧用swap指针交换和匿名函数特点，实现内存收缩//实际上是写了一个匿名对象和自身互换</span></span><br></pre></td></tr></table></figure></li>
<li><ol>
<li>STL的六大组件：容器（container）、算法（Algorithm）、迭代器（iterator）、仿函数（函数对象C++06-03）、适配器（将多个参数返回一个参数）、空间配置器（管理空间）</li>
<li>容器分为：String容器 、Vector容器（类似动态数组） Deque容器 List容器</li>
<li>常用的数据结构有：数组（array）、链表（list）、tree（树）、栈（stack）、队列（queue）、集合（set）、映射表（map）</li>
<li>这些数据分为序列式容器（string vector deque 栈 队列 ilst）和关联式容器（set map）</li>
<li>关联式容器特点：<ol>
<li>插入时就做好排序了 </li>
<li>键值对<br>iterator 普通迭代器;reverse_iterator 反转迭代器;coust_iterator 指针迭代器<br>定义迭代器类似于定义指针 也类似自定义类型（person）</li>
</ol>
</li>
</ol>
</li>
<li><ol>
<li>lambda表达式     <a href=""></a>{} </li>
<li>如果想强制调用函数模板，可以使用空模板参数列表 例如：sort源码中默认升序less&lt;&gt;()&lt;=&gt;”&lt;”</li>
<li>char*  转 int atoi string 转char* .c_str()<br>所以string转int this-&gt;baseDamage=atoi(WeaponData[id][“weaponAtk”].c_str())<br>int转string类型 to_string()<br>%s打印char*类型的字符串<br>getchar（）；从缓冲区取走换行符 等价于cin.get()<br>getchar（）让用户等待，停留 需要用户在输入一下值 才会进入下一个界面</li>
</ol>
</li>
<li>ret返回值 ref引用 coust防止被修改<ul>
<li>随机种子 头文件 #include <ctime></li>
<li>srand((unsigned int )time(NULL));</li>
<li>Swap()本质就是指针交换</li>
<li>vector<int> ::iterator it=v1.begin()……</li>
<li>其中*it 代表<int>中int,map&lt;int,string&gt;::iterator mit=m.begin()……</li>
<li>其中mit-&gt;first或者(*mit).second,赋值操作有m.insert(make_pair(2, 20));   m[4] = 40;</li>
</ul>
</li>
<li><ol>
<li>内建函数对象 大于 greater<int> 头文件 functional</li>
<li>类模板Person&lt;string,int&gt;p1(“孙悟空”,100)；//显示指定类型</li>
<li>函数模板mySwap<int>（a，b）;//显示指定类型</li>
<li>template<class T>T plus<T>//加法函数 二元运算，其中template<class T>T中最后的T代表类模板对象 plus<T>代表函数模板，plus代表函数 内部自动重写”()”</li>
<li>template<class T>T negate<T>//取反函数 一元运算<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> test01（）</span><br><span class="line">&#123;</span><br><span class="line">	negate&lt;<span class="keyword">int</span>&gt; n; <span class="built_in">cout</span> &lt;&lt;n(<span class="number">10</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//结果-10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>template<class T>bool greater<T>//大于  greater<T>函数 greater<T>()函数对象==大于号<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sort（v.begin()，v.end()，greater&lt;<span class="keyword">int</span>&gt;()）；</span><br><span class="line">for_each(v.begin()，v.end()，[](<span class="keyword">int</span> val)&#123;<span class="built_in">cout</span>&lt;&lt;val&lt;&lt;<span class="string">&quot; &quot;</span>;&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="QT实战编程"><a href="#QT实战编程" class="headerlink" title="QT实战编程"></a>QT实战编程</h2></li>
</ol>
</li>
<li>实例化对象两种方式：<ul>
<li>一种是在栈上Person p；//调用默认构造函数</li>
<li>Person p（this）；//调用有参构造函数指定父类</li>
<li>一种是在堆区 Person *p =new person；</li>
</ul>
</li>
<li>成员函数需要写作用域<ol>
<li>connect( myBtn , &amp;MyPushButton::clicked ,this, &amp;MyWidget::close);<br>其中四个参数代表四个指针 myBtn对象指针，clicked函数地址代表函数指针，this对象指针，函数地址代表函数指针  </li>
<li>&amp;MyPushButton::clicked找成员函数地址的方法 调用非静态成员函数必须用对象 </li>
<li>函数名本质就是一个函数指针  函数指针可以指向函数地址 函数指针==函数地址  </li>
<li>this可以省略</li>
</ol>
</li>
<li>h文件中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyWidget(QWidget *parent = <span class="number">0</span>);<span class="comment">//调用有参构造初始化父类指针</span></span><br><span class="line">teacher(QObject *parent = <span class="literal">nullptr</span>);  <span class="comment">//nullptr 代表NULL Printor 空指针 </span></span><br><span class="line"><span class="comment">//QObject 对象数的根 代表实体</span></span><br></pre></td></tr></table></figure>
需要用户传一个parent值来初始化 如果不传值，默认为0来初始化父类的一些属性 parent属性<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cpp文件中：MyWidget::MyWidget(QWidget *parent): QWidget(parent)</span><br><span class="line">teacher::teacher(QObject *parent) : QObject(parent)</span><br><span class="line"><span class="comment">//初始化列表 将参数交给父类 父类进行初始化操作</span></span><br><span class="line">（继承关系，先初始化父类，然后再初始化子类）</span><br></pre></td></tr></table></figure>
父类初始化之后，子类构造会调用父类的构造函数 所以新建类之后系统默认添加这种有参构造函数来初始化parent指针</li>
<li>当信号和槽发生重载时候，需要利用函数指针明确指出函数地址<br><code>void(Teacher:: *teacherSignal)(QString) = &amp;Teacher::hungry;</code></li>
<li>创建“对象”在栈上，是个变量不是指针可以直接“.”来调用函数。<br>创建“对象指针”在堆区，函数结束之后不会释放掉的 “-&gt;”来调用函数。<br>对于静态成员函数可以用两种方式访问 一种是类名直接访问，一种是创建对象<br><code>QMessageBox：：critical（this，“错误”，“critical”）;</code>//其中”错误”代表地址 </li>
<li>this使用：<ol>
<li>哪个对象调用这个构造函数 this指向那个对象 this是指针</li>
<li>在Mywidget的构造函数中，this代表mywidget类对象，既当前窗口对象Mywidget,而图中的<code>QPushButton * btn= new QPushButton();</code></li>
<li>QPushButton()构造函数可以有很多重载</li>
<li>第二个参数代表btn的父类是谁，this指向当前对象，让按钮显示在当前层中（button默认在顶层中）。</li>
<li><code>QWidget *parent=this；</code>让当前指针this=parent指针 </li>
<li>父类指针指向子类对象来实现多态<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p =<span class="keyword">new</span> Son();</span><br><span class="line">QTextEdit *edit = <span class="keyword">new</span> QTextEdit（<span class="keyword">this</span>）；</span><br><span class="line">setCentralWidget（edit）；</span><br><span class="line"><span class="comment">//其中的参数是QWidget *widget 父类指针但是填写的是子类对象</span></span><br></pre></td></tr></table></figure></li>
<li><img src="/C++/QT1.png" alt="avatar"></li>
<li>函数的参数是父类指针，填写this代表将teacher绑定到this上不用析构了，其中将this代表widget对象继承Qwidget<ul>
<li><img src="/C++/QT2.png" alt="avatar"></li>
</ul>
</li>
</ol>
</li>
<li>ui就是界面文件中的ui文件<ul>
<li>ui函数体中 ui-&gt;setupUi(this);表示ui帮助创建的界面</li>
<li>都在ui-&gt;setupUi(this);下进行编辑</li>
<li>其中的actionNew默认对象是个指针 </li>
<li>return a.exec(); //.exec()阻塞代码 不是创建在栈上</li>
<li><img src="/C++/QT4.png" alt="avatar"></li>
</ul>
</li>
<li>lambda表达式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;=&#125;函数体内可以使用lambda所在作用范围内所有可见的局部变量</span><br><span class="line">QPushButton * btn2= <span class="keyword">new</span> QPushButton(<span class="string">&quot;aaa&quot;</span>,<span class="keyword">this</span>);</span><br><span class="line">[=]()&#123;</span><br><span class="line">btn2-&gt;setText(<span class="string">&quot;bbb&quot;</span>); <span class="comment">//lanbda的作用范围就是当前作用域</span></span><br><span class="line">&#125;；<span class="comment">//这只是函数的声明不是调用，想调用需要在后边添加一个()</span></span><br><span class="line">相当于值传递</span><br><span class="line">connect(btn4,&amp;QPushButton::clicked,<span class="keyword">this</span>,[=]()&#123;</span><br><span class="line">btn4-&gt;setText(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
this代表当前窗口 然后去执行lanbda表达式<br>this可以省略 因为this和后边的lambda表达式 是一个东西</li>
<li>如果类的构造函数是无参的可以dataConfig config;直接创建对象<br>//同步二维数组 如果以后有保存需求 可以利用数组还原  记录点击前的样子<br><code>this-&gt;gameArray[i][j]=this-&gt;gameArray[i][j]==1?0:1;</code></li>
<li>读取gbk格式<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">    QTextCodec * codec = QTextCodec::codecForName(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    codec-&gt;toUnicode(<span class="built_in">array</span>)；	</span><br><span class="line">    QTextCodec * codec = QTextCodec::codecForName(<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//codec-&gt;toUnicode(array);</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;setWindowTitle(codec-&gt;toUnicode(<span class="string">&quot;翻金币主场景&quot;</span>));</span><br><span class="line">    <span class="comment">//自定义按钮需要设置到某个场景中</span></span><br><span class="line">    backBtn-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">## 数据结构</span><br><span class="line"><span class="number">1.</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkNode</span>*<span class="title">Next</span> 四个字节，指针就是四个字节，<span class="title">return</span>的返回值 1和-1都是真 0是假</span></span><br><span class="line"><span class="class">2. 顺序存储-数组、链式存储-链表、栈存在顺序和链式，队列存在顺序和链式，树存在链式，顺序有点需要补全代码比较浪费资源、图有顺序（邻接矩阵）和链式（邻接表）</span></span><br><span class="line"><span class="class">3. 链表长度<span class="title">m_size</span>代表有几个节点，和<span class="title">pos</span>下标不一样，链表插入初始为0，<span class="title">m_size</span>比<span class="title">pos</span>多一  </span></span><br><span class="line"><span class="class">   ![<span class="title">avatar</span>](/<span class="title">C</span>++/数据1.<span class="title">png</span>)</span></span><br><span class="line"><span class="class">4. 动态数组初始化，用函数返回动态数组指针的形式初始化，这个返回的动态数组指针指向的是动态数组，堆区开辟空间时：</span></span><br><span class="line"><span class="class">   1. 动态数组开辟一块并将指针返回</span></span><br><span class="line"><span class="class">   2. 动态数组中的内容开辟指针</span></span><br><span class="line"><span class="class">   3. ![<span class="title">avatar</span>](/<span class="title">C</span>++/数据2.<span class="title">png</span>)</span></span><br><span class="line"><span class="class">   4. 可以直接定义结构体指针指针</span></span><br><span class="line"><span class="class">      1. ![<span class="title">avatar</span>](/<span class="title">C</span>++/数据3.<span class="title">png</span>)</span></span><br><span class="line"><span class="class">5. 头结点结构体中<span class="title">LJD</span> *<span class="title">next</span>；指向邻接点结构体  </span></span><br><span class="line"><span class="class">   邻接点结构体中的<span class="title">Struct</span> <span class="title">LJD</span> *<span class="title">next</span>；指向<span class="title">V0</span>的下一个邻接点结构体，  </span></span><br><span class="line"><span class="class">   不是<span class="title">V1</span>的邻接点结构体位置，虽然是链表形式，但是都是表示<span class="title">V0</span>的邻接点结构体</span></span><br><span class="line"><span class="class">   - ![<span class="title">avatar</span>](/<span class="title">C</span>++/数据4.<span class="title">png</span>)</span></span><br><span class="line"><span class="class">6. <span class="title">V0</span>首先就是一个一维的<span class="title">Char</span>*，一维的数组</span></span><br><span class="line"><span class="class">   ```<span class="title">c</span></span></span><br><span class="line"><span class="class">   <span class="title">typedef</span> <span class="title">char</span> <span class="title">VertexInfo</span>[9];</span> <span class="comment">//代表9个字符的字符串</span></span><br><span class="line">   VertexInfo vertex[MaxVertex];&lt;=&gt;vertex[MaxVertex][<span class="number">9</span>]</span><br><span class="line">   <span class="comment">//代表每行存一个字符串  顶点的名字</span></span><br><span class="line">   VertexInfo代表<span class="keyword">char</span>类型字符数组</span><br></pre></td></tr></table></figure></li>
<li>选择排序（只是在更新下标，然后经过一次交换）<br>冒泡排序 插入排序 第二个for中如果满足条件先执行结构体中的代码然后执行j–操作<br><img src="/C++/%E6%95%B0%E6%8D%AE5.png" alt="avatar"></li>
<li>链表结构体、动态数组结构体、队列结构体的初始化可以放在初始化函数中返回一个动态数组、链表、队列的指针，这个初始化工作也可以放在main函数中或者test01()函数中</li>
<li>顺序队列这种数据类型的声明和初始化,入列函数中seqQueue queue类似于int a是形参  自定义结构体声明是不占有内存的，定义时赋值之后才有<br> <img src="/C++/%E6%95%B0%E6%8D%AE6.png" alt="avatar"></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/24/C++/" data-id="ckp3bilim00044sue6sz63yjo" data-title="C++" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-数据库学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-24T12:40:10.182Z" itemprop="datePublished">2021-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/">数据库学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><ol>
<li>Oracle数据库安装：<ol>
<li>win10本机安装Oracle(当做服务器==自己装服务器)   虚拟机安装win7来链接本地oracle(当做客户端)<br>本机需要启动OracleServiceORCL   home1TNSListener<br> 虚拟机win7需要执行 在命令行窗口 sqlplus scott/tiger<br> 然后在sql窗口中执行：SQL&gt;select * from tab;  然后出现四张表<br> 这种方式比较简单 本机启动oracle 虚拟机一连</li>
<li>使用虚拟机：虚拟机需要安装oracle数据库<br>本机需要自己安装oracle客户端：一定要选管理员  然后使用plsqldevelop软件<br>需要使用linux下启动oracle数据库    让本机的oracle客户端去连</li>
<li>oracle服务器 ：<br>SYSDBA账户：sys 密码sys     SYSDBA账户：system 密码：manager<br>Normal用户 ： scott    密码：tiger  Normal用户 ： hr   密码：hr</li>
</ol>
</li>
<li>oracle安装注意事项：<ol>
<li>路径里不要有中文和空格，ups系统 不间断电源系统</li>
<li>我们通过操作实例(内存)来操作数据库(硬盘上),一旦SGA(System Global Area)提交数据，就不支持回滚了,</li>
<li>客户端提交的请求都会进入到PGA(progrem Global Area)中处理</li>
<li>实例：就是一组进程(服务==守护进程) ：比如查询订单是通过oracle服务查询订单</li>
<li>逻辑概念：表空间，表空间由多个数据文件组成。位于实例上，在内存中。其中有个映射的操作类似map</li>
<li>物理概念：数据文件，位于硬盘之上。(C:\app\Administrator\oradata\orcl目录内后缀为.DBF的文件)，一个表空间可以包含一个或者是多个数据文件。1：n（表空间：数据文件）</li>
</ol>
</li>
<li>虚拟机(ubuntu和redhat)安装oracle辛酸史：<ol>
<li>Ubuntu安装Oracle手册（简单版）：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/rogear/p/8075455.html">https://www.cnblogs.com/rogear/p/8075455.html</a></li>
<li>史上最详细最全的CentOS(Linux)上安装Oracle的教程：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/binqq/articles/10907055.html">https://www.cnblogs.com/binqq/articles/10907055.html</a></li>
<li>VMware下对Ubuntu进行扩充磁盘大小 <a target="_blank" rel="noopener" href="https://blog.csdn.net/Timsley/article/details/50742755">https://blog.csdn.net/Timsley/article/details/50742755</a></li>
<li>虚拟机中ubuntu的swap空间不足：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_33911208/article/details/84578318">https://blog.csdn.net/qq_33911208/article/details/84578318</a></li>
<li>oracle为hr用户解锁，添加scott用户：  <a target="_blank" rel="noopener" href="https://blog.csdn.net/u011521890/article/details/52202962">https://blog.csdn.net/u011521890/article/details/52202962</a></li>
</ol>
</li>
<li>使用where进行过滤:<ul>
<li>若在编写sql语句的时候, 书写错误, 则可以进行修改:   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SQL&gt; select * ffom</span><br><span class="line">SQL&gt; emp;</span><br><span class="line">先输入: 错误发生的那一行, 然后输入c /ffom/from,最后输入/执行sql语句.</span><br><span class="line">SQL&gt; <span class="number">2</span></span><br><span class="line">SQL&gt; c/ffom/from</span><br><span class="line">SQL&gt; /</span><br></pre></td></tr></table></figure></li>
<li>基本结构: <code>select .... from  table  where  condtion;</code></li>
<li>若编写的sql语句比较长, 可以使用edit打开一个记事本, 在记事本上编写:    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如: SQL&gt;edit , 然后按/执行sql语句</span><br><span class="line">保存查询结果:</span><br><span class="line">spool名的使用: </span><br><span class="line">spool d:\results</span><br><span class="line">select * from emp;</span><br><span class="line">spool off</span><br></pre></td></tr></table></figure>
   这样会将查询结果保存到文件中.</li>
</ul>
</li>
<li>使用比较运算符: &gt; &gt;= &lt; &lt;= != (&lt;&gt;) between and 案例:<ol>
<li>查询10号部门的员工信息   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from emp where deptno=<span class="number">10</span>;</span><br></pre></td></tr></table></figure></li>
<li>查询员工名字为king的员工信息   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      select * from emp where ename = &#x27;KING&#x27;;		</span><br><span class="line">      ```     </span><br><span class="line">      结论: 表中的列的值是区分大小写的; 但是关键字不区分大小写 </span><br><span class="line"><span class="number">3.</span> 查找薪水不等于<span class="number">1250</span>员工的信息</span><br><span class="line">      ```c</span><br><span class="line">      select * from emp where sal!=<span class="number">1250</span>;</span><br><span class="line">      select * from emp where sal&lt;&gt;<span class="number">1250</span>;  </span><br></pre></td></tr></table></figure></li>
<li>查询入职日期为1981年11月17日的员工信息   <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">      select * from emp where hiredate=&#x27;1981-11-17&#x27;; --查询错误</span><br><span class="line">      select * from emp where hiredate=&#x27;17-11月-81&#x27;;  </span><br><span class="line">      ```				</span><br><span class="line"><span class="number">5.</span> 查询当前使用的日期格式: </span><br><span class="line">      ```c</span><br><span class="line">      select * from v$nls_parameters;</span><br></pre></td></tr></table></figure></li>
<li>修改日期格式:    <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter session set NLS_DATE_FORMAT=&#x27;yyyy-mm-dd&#x27;;</span><br></pre></td></tr></table></figure></li>
<li>修改成原有的格式:    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      alter session set NLS_DATE_FORMAT=&#x27;DD-MON-RR&#x27;;</span><br><span class="line">      说明: 需要注意日期格式, 默认是DD-MON-RR  		</span><br><span class="line">      ```	  </span><br><span class="line"><span class="number">9.</span> 查找工资介于<span class="number">1000</span><span class="number">-2000</span>之间的员工信息</span><br><span class="line">      ```c</span><br><span class="line">      select * from emp where sal&gt;=<span class="number">1000</span> <span class="keyword">and</span> sal&lt;=<span class="number">2000</span>;</span><br><span class="line">      select * from emp where sal between <span class="number">1000</span> <span class="keyword">and</span> <span class="number">2000</span>;</span><br></pre></td></tr></table></figure>
   结论: between and是闭区间</li>
</ol>
</li>
<li>linux下启动oracle数据库:<ul>
<li>使用linux的oracle用户登陆:     <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sqlplus sys/sys as sysdba</span><br><span class="line">sqlplus / as sysdba	</span><br><span class="line">SQL&gt; startup   ---启动数据库服务</span><br><span class="line">需要先用系统账户启动然后 才能让普通账户去连接</span><br><span class="line">SQL&gt; shutdown immeidate   ----关闭数据库服务</span><br><span class="line">启动监听服务:    lsnrctl start</span><br></pre></td></tr></table></figure></li>
<li>linux下停止oracle数据库: <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关闭oracle：shutdown immediate</span><br><span class="line">其中退出数据库 ：<span class="built_in">exit</span>或者quit</span><br><span class="line">停止监听服务:    lsnrctl stop</span><br></pre></td></tr></table></figure></li>
<li>使用sqlplus登陆oracle数据库:<ul>
<li>普通用户登陆:  <code>sqlplus scott/tiger@192.168.233.128/orcl</code><br> <code>sqlplus scott/tiger@192.168.233.128:1521/orcl</code></li>
<li>sys用户登陆:  <code>sqlplus sys/sys as sysdba</code></li>
<li>解锁用户:<code>alter user scott account unlock;</code></li>
<li>加锁用户:<code>alter user scott account lock;</code></li>
<li>修改用户密码: <code>password scott</code><br> <code>alter user scott identified by xxxxx;</code></li>
<li>查看当前的语言环境:<br> <code>select userenv(&#39;language&#39;) from dual; </code></li>
</ul>
</li>
<li>qlplus的基本操作:<ul>
<li>显示当前用户:show user</li>
<li>查看当前用户下的表:select * from tab; </li>
<li>查看表结构:desc emp;</li>
<li>设置行宽:set linesize 140 </li>
<li>设置页面显示的行数: set pagesize 100</li>
<li>永久设置行宽和页面显示的行数:<br> D:\app\Administrator\product\11.2.0\client_1\sqlplus\admin </li>
<li>设置员工名列宽:<br> col ename for a10  一个a代表一个英文宽度</li>
<li>设置薪水列为4位数字：<br> col sal for 9999     一个9代表一个数字宽度</li>
</ul>
</li>
</ul>
</li>
<li>select 和 from 关键字在数据库中不区分大小写,<br>Select语句的整体形式：select col1, col2…  <ol>
<li><code>基本的from table_name //表示col1 col2列从 table name表中查出来  where condition //加条件 过滤数据</code></li>
<li><code>分组的 group by col… //表示要对前边过滤出来的数据进行分组having condtion //对分组数据进行查询过滤</code></li>
<li>排序的 order by col…//对前边的结果进行排序 写在最后边(对最后的结果排序)注意：oracle中select * oracle中有个将*转成具体列的过程</li>
<li>基本的SELECT语句<br> <code>其语法格式为：SELECT *|&#123;[DISTINCT] column|expression [alias],...&#125;FROM    table;</code></li>
<li>案例: <ul>
<li>查询所有员工的所有记录<br>   <code>select * from emp;</code></li>
<li>查询员工号，姓名，月薪，奖金，年薪<pre><code>``select empno, ename, sal, comm, sal*12 from emp;``
使用select * 和 select 列名的区别: 使用select *会先查有哪些列, 影响效率
</code></pre>
</li>
<li>对案例2使用别名:<br>   <code>select empno, ename, sal as 工资, comm 奖金, sal*12 &quot;年 薪&quot; from emp;</code><pre><code>关于别名的结论: 
as可以省略
如果别名中间有空格, 需要使用&quot;&quot;引起来
</code></pre>
</li>
<li>查询员工号，姓名，月薪，奖金，年薪，年收入<pre><code>``select empno, ename, sal, comm, sal*12 年薪, sal*12+nvl(comm, 0) 年收入 from emp;``
结论: 
1 包含有null的表达式都为空
2 nvl的用法: nvl(a, b): 如果a为空, 则取b的值.          
</code></pre>
</li>
<li>查看员工表不同的部门编号<pre><code>``select distinct deptno from emp;``            
</code></pre>
</li>
<li>查看不同部门的不同工种<pre><code>``select distinct detpno, job from emp; ``
结论:distinct的作用范围??
distinct作用于后面出现的所有的列.            
</code></pre>
</li>
<li>输出计算表达式 3+20<em>5，显示当前日期  sysdate<br>   ``select 3+20</em>5, sysdate from dual;``<pre><code>注意: dual表是一个伪表, 主要是为了满足sql的语法规定    desc dual； 只有一条记录(字段)
</code></pre>
</li>
</ul>
</li>
</ol>
</li>
<li>SQL和sqlplus区别:<ol>
<li>SQL → 语言，关键字不能缩写 ，一种语言，ANSI 标准，关键字不能缩写</li>
<li>sqlplus → Oracle提供的工具，一种环境，关键字可以缩写，命令不能改变数据库中的数据的值</li>
<li>cmd sql也是在sqlplus中</li>
</ol>
</li>
<li>字符串相关函数:<ol>
<li>lower 小写, upper 大写, initcap    单词的首字母大写<br>select lower(‘HELLO WORLD’) “小写”, upper(‘Hello world’) “大写”, initcap(‘hello world’) “首字母大写” from dual;</li>
<li>concat(连接符||)<br>select concat(‘hello ‘,’world’) from dual;<br>**注意: concat函数只能连接两个字符串, 若想连接三个的话只能嵌套调用:<br>select concat(concat(‘hello ‘,’world’), ‘ nihao’) from dual;<br>select ‘hello ‘ || ‘world ‘ || ‘nihao’ from dual;<br>**注意: || 可以连接多个字符串, 建议使用||来连接字符串.<br>**总结: concat只能用于两个字符串的连接, ||可以用于多个字符串的连接, 在使用的使用建议尽量的使用||.</li>
<li>substr(str,pos,len)截取字符串<br>select substr(‘helloworld’,1,3), substr(‘helloworld’,1), substr(‘helloworld’,-3) from dual;<br>**总结:pos是从1开始的, 若len为0表示从pos开始, 截取到最后, 若pos为负数, 表示从末尾倒数开始截取,</li>
<li>instr(str, substr):判断substr是否在str中存在, 若存在返回第一次出现的位置, 若不存在则返回0<br>select instr(‘hello llo’, ‘llo’),  instr(‘hello llo’, ‘ow’)from dual;</li>
<li>lpad和rpad–l(r)pad(str, len, ch):返回len长度的字符串, 如果str不够len的话, 在左(右)填充ch这个字符<br>select lpad(‘aaaa’, 10, ‘$’), rpad(‘aaaa’, 10, ‘#’) from dual;</li>
<li>trim:去掉首部和尾部的空格,中间的空格不去掉<br>select ‘aaa’||trim(‘  hello world  ‘)||’bbb’ from dual;<br>trim(c from str):去掉str中的c字符<br>select trim(‘x’ from ‘xxxxxhello worldxxxxx’) from dual;</li>
<li>replace(str, old, new):将str字符串中的old字符串替换成new字符串<br>select replace(‘hello world’,’llo’,’yy’) from dual;</li>
<li>length和lengthb<br>select length(‘hello world’) 字符数, lengthb(‘hello world’) 字节数 from dual;<br>select length(‘哈喽我的’) 字符数, lengthb(‘哈喽我的’) 字节数 from dual;<br>注意:对于length函数一个汉字是一个字符, 对于lengthb函数,一个汉字占两个,<br>这两个函数对于普通字符串没有什么区别.</li>
</ol>
</li>
<li>排序: <ul>
<li>使用order by关键字, 基本格式:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select  ... from ... where condition order by colname|alias|expr|number(序号)</span><br><span class="line">order by有两种排序方法; 一种是升序, 一种是降序: 默认是升序的(asc), 降序为desc</span><br><span class="line">a 使用列名进行排序: </span><br></pre></td></tr></table></figure></li>
<li>分组数据: 借助execl理解分组功能.<br>基本格式 : <code>select ..., count() from emp where ... group by .. </code><br>说明: 按照group by 后给定的表达式，将from后面的table进行分组, 针对每一组, 使用分组函数。</li>
<li>转换函数:to_char和to_number、–to_char和to_date、oracle有隐式转换和显示转换</li>
<li>在where条件中使用like–模糊查找, 其中: ‘%’匹配任意多个字符。’_’匹配一个字符</li>
<li>在where条件中使用in–in后面是一个集合</li>
<li>在where条件中使用逻辑运算符: or(或) and(与) not(非)</li>
</ul>
</li>
<li>数据处理:sql语言的类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DML data manipulation language  数据操作语言，对应增删改查</span><br><span class="line">DDL  data definition language  数据定义语言 create, drop, truncate</span><br><span class="line">DCL  data control language 数据控制语言 grant, revoke, commit, rollback</span><br></pre></td></tr></table></figure></li>
<li>from后边有多个表 必须加where条件 要不就变成了笛卡尔集<ul>
<li>外连接 哪边少 加在哪一边</li>
<li>select min(sal) from emp where deptno=30;</li>
<li>先执行where条件 在执行分组函数</li>
<li>group by 后边只能跟列</li>
<li>distinct 去重复</li>
</ul>
</li>
<li>表的约束:<ol>
<li>表的约束（5种）：</li>
<li>检查 (值是否符合预设的规则)</li>
<li>非空 (not null)</li>
<li>唯一 (不能重复)</li>
<li>主键（非空+唯一）</li>
<li>外键 (取值必须在另外一个表中存在)</li>
</ol>
</li>
<li>表的创建和管理:<ul>
<li>创建前提条件：表空间的使用权限和create table的权限</li>
<li>表名的注意事项: 以字母开头, 长度不能超过30个字符, 不能是oracle的关键字或保留字, 不能与其他对象重名</li>
<li>创建表的数据类型见讲义部分.</li>
</ul>
</li>
<li>事物的概念:数据库事务, 是由有限的数据库操作序列组成的逻辑执行单元,<ul>
<li>这一系列操作要么全部执行, 要么全部放弃执行.</li>
<li>数据库事务由以下的部分组成:<ul>
<li>一个或多个DML语句</li>
<li>一个 DDL(Data Definition Language – 数据定义语言) 语句</li>
<li>一个 DCL(Data Control Language – 数据控制语言) 语句</li>
</ul>
</li>
<li>事务的特点：要么都成功，要么都失败。</li>
<li>事物开始: 事物以DML语句开始, 执行一系列的数据插入或者是修改操作</li>
<li>事物结束: <ul>
<li>提交结束: commit;</li>
<li>隐式提交: 执行了DDL语句(如create了一个表), 正常退出        </li>
<li>显示回滚: rollback;</li>
<li>隐式回滚: 断电, 宕机, 异常退出等</li>
<li>事物的特性:原子性、一致性、隔离性、持久性&lt;具体概念见讲义部分&gt;</li>
<li>事物的隔离级别: 了解oracle是读已提交数据, mysql是可重复读.</li>
</ul>
</li>
</ul>
</li>
<li>索引也是数据库的一个对象, 索引主要是用于表, 目的是提高查询的效率,rownum 行号 rowid 存放这一行的行地址(类似于指针)</li>
<li>序列:<ol>
<li>序列的用处:<br>由于表的主键要求是非空且唯一的, 为了保证主键是非空和唯一的, 可以使用序列.</li>
<li>如何创建序列<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create sequence seq_mytest;</span><br><span class="line">select xxxx_name from user_xxxxs;</span><br><span class="line">select sequence_name from user_sequences;</span><br></pre></td></tr></table></figure></li>
<li>序列的属性<br>currval 和 nextval, 但是第一次使用的时候先要取nextval的值.</li>
<li>如何删除序列    <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop sequence seq_mytest;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>视图:<ol>
<li>什么是视图:<br>视图是用来查看数据的, 视图本身不存储数据, 数据来源于基础表.    </li>
<li>如何创建视图:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create <span class="keyword">or</span> replace view vw_emp as select * from emp;</span><br><span class="line">create <span class="keyword">or</span> replace view vw_emp as select empno, ename, job from emp</span><br><span class="line">where deptno=<span class="number">20</span>;</span><br><span class="line">create <span class="keyword">or</span> replace view vw_emp_dept as select e.deptno, d.dname, e.ename,</span><br><span class="line"> e.job from emp e,dept d where e.deptno=d.deptno;</span><br><span class="line">```		</span><br><span class="line"><span class="number">3.</span> 创建只读视图:</span><br><span class="line">```c</span><br><span class="line">create <span class="keyword">or</span> replace view vw_emp as select * from emp with read only;		</span><br><span class="line">view_name from user_views;</span><br></pre></td></tr></table></figure></li>
<li>如何删除视图:<br><code>drop view vw_emp;</code></li>
<li>使用视图的目的:<br>可以简化查询<br>可以限制用户对某些数据的访问</li>
<li>注意点:<br>不要通过视图去修改表的数据。</li>
</ol>
</li>
<li>复习：oracle<ol>
<li>基本概念<br>select * | col from table where cond group by col having cond order by col;</li>
<li>简单的select查询</li>
<li>带有where条件的select查询<br>比较运算符 &lt; &gt; = != &lt;&gt; &lt;= &gt;=<br>集合运算符: in not int<br>逻辑表达式: and or<br>模糊查找: like _ % escape</li>
<li>order by<br>列名  表达式  别名  序号</li>
<li>distinct</li>
<li>分组函数: max min avg count sum<br>分组数据: group by </li>
<li>多表查询:<br>笛卡尔积<br>等值连接  不等值连接  外连接   自连接</li>
<li>子查询:<br>可以在select from having where 后面跟子查询</li>
<li>事务<br>DML: insert delete update select<br>DDL: drop create truncate grant revoke<br>DCL:commit rollback savepoint<br>事务的特点 ACID</li>
<li>oracle对象<br>表<br>视图<br>索引<br>序列<br>同义词<h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2></li>
</ol>
</li>
<li>表的约束:<ul>
<li>定义主键约束　primary key:    不允许为空，不允许重复</li>
<li>定义主键自动增长　auto_increment</li>
<li>定义唯一约束　unique</li>
<li>定义非空约束　not null</li>
<li>定义外键约束　constraint ordersid_FK foreign key(ordersid) references orders(id)</li>
<li>删除主键：alter table tablename drop primary key ;</li>
</ul>
</li>
<li>数据库CURD对数据库进行增(create)、删(delete)、改(update)、查(Retrieve)操作。<ol>
<li>知识点补充: 介绍mysql数据库与oracle数据库的不同(图解说明)<ul>
<li>mysql数据库: root用户 &gt; 库 &gt; 表</li>
<li>oracle数据库: 数据库 &gt; 用户 &gt; 表    </li>
</ul>
</li>
<li>创建数据库<ul>
<li>创建数据库, 默认为latin1<br> create database mydb1;        </li>
<li>指定字符集为utf8<br> create database mydb2 character set utf8;    </li>
<li>指定字符集为utf8,并对插入的数据进行检查<br> create database mydb3 character set utf8 collate utf8_general_ci;    </li>
</ul>
</li>
<li>查看数据库<ul>
<li>显示所有数据库<br> show databases;</li>
<li>显示创建数据库的语句信息<br> show create database mydb1;<br>注意 ：mysql默认语言集是latin1，每次在创建数据库的时候应指定字符集.</li>
</ul>
</li>
<li>修改数据库<ul>
<li>修改mydb1的字符集为utf8(不能修改数据库名)<br> alter database mydb1 character set utf8;</li>
</ul>
</li>
<li>删除数据库<ul>
<li>drop database mydb1;</li>
</ul>
</li>
</ol>
</li>
<li>表结构显示：五个字段就是代表5个列<ul>
<li>十进制 100 转成八进制=64 ，反过来八进制的64=6*16+4=100</li>
<li>status;查看当前用户信息</li>
<li>mysql中的ifnull函数相当于oracle中的nvl函数</li>
<li>RHEL系统就是Red Hat Enterprise Linux</li>
</ul>
</li>
<li>多表查询:<ol>
<li>准备测试数据<ul>
<li>将scott_data.sql文件的数据导入到mysql中</li>
<li>mysql&gt; source scott_data.sql        </li>
</ul>
</li>
<li>交叉连接—相当于笛卡尔积<ul>
<li>select e.<em>, d.</em> from emp e cross join dept d;</li>
</ul>
</li>
<li>自连接</li>
<li>查询emp表和dept表的所有信息: <ul>
<li>SQL99: </li>
<li>select e.<em>, d.</em> from emp e inner join dept d on e.deptno=d.deptno;其中inner可以省略</li>
<li>oracle写法: select e.<em>, d.</em> from emp e, dept d where e.deptno=d.deptno;</li>
<li>总结: <ul>
<li>[,]—-&gt;[inner join]</li>
<li>[where]—–&gt;[on]</li>
<li>注意: 不能显示40号部门的信息, 此时需要使用外连接</li>
</ul>
</li>
</ul>
</li>
<li>外连接<ul>
<li>左外连接:<ul>
<li>select e.<em>, d.</em> from emp e right outer join dept d on e.deptno=d.deptno;</li>
</ul>
</li>
<li>右外连接:<ul>
<li>select e.<em>, d.</em> from dept d left outer join emp e on e.deptno=d.deptno;</li>
</ul>
</li>
<li>[注意]SQL99中，外链接取值与关系表达式=号左右位置无关。取值跟from后表的书写顺序有关。 <ul>
<li>“xxx left outer join yyy”  则为取出xxx的内容</li>
<li>“xxx right outer join yyy” 则为取出yyy的内容</li>
</ul>
</li>
</ul>
</li>
<li>自连接:<ul>
<li>查询员工、老板信息，显示: xxx的老板是yyy </li>
<li>分析: 可以将emp表当成两个表来用, 一个是员工表 e, 一个是老板表 b</li>
</ul>
</li>
</ol>
</li>
<li>遇到问题查看Mysql数据库api文档<br>redHat7.0 linux安装mysql：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_32223565/article/details/79894037">https://blog.csdn.net/qq_32223565/article/details/79894037</a></li>
<li>locate命令 快速查找根据服务器里的小库 区别find -name <ul>
<li>比如新建一个文件不会马上 存在小库中需要重启才能locate到</li>
<li>nm命令可以查看库内包含的函数</li>
</ul>
</li>
<li>复习：mysql<ul>
<li>mysql基础知识:安装 版本 启动</li>
<li>库的CURD</li>
<li>表的CURD</li>
<li>数据的CURD:<ul>
<li>外连接的写法与oracle有区别.</li>
</ul>
</li>
<li>中文乱码问题分析</li>
<li>mysqlAPI编程:<ul>
<li>mysql_init</li>
<li>mysql_real_connect</li>
<li>mysql_query</li>
<li>mysql_store_result</li>
<li>mysql_fetch_row</li>
<li>mysql_affected_rows</li>
<li>mysql_field_count</li>
<li>mysql_num_fields</li>
<li>mysql_fetch_fields</li>
<li>mysql_free_result</li>
<li>mysql_close</li>
</ul>
</li>
<li>mysql事务:<ul>
<li>start transaction;</li>
<li>set autocommit=0;</li>
<li>set autocommit=1;</li>
<li>commit rollback  </li>
</ul>
</li>
</ul>
</li>
<li>修改mysql为手工提交:<ol>
<li>开启事务<br>start transaction;</li>
<li>设置手工提交<br>set autocommit=0;</li>
<li>开启事务<br>start transaction;</li>
<li>设置自动提交<br>set autocommit=1;</li>
</ol>
</li>
<li>mysql客户端编写思路分析:<ol>
<li>mysql初始化–mysql_init</li>
<li>连接mysql数据库—mysql_real_connect</li>
<li>while(1)</li>
<li>关闭连接: mysql_close();</li>
</ol>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%A6%E4%B9%A0/" data-id="ckp3bilit000b4sue97fg7h3f" data-title="数据库学习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-C语言学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-04-21T14:36:32.634Z" itemprop="datePublished">2021-04-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/">C语言学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="C基础"><a href="#C基础" class="headerlink" title="C基础"></a>C基础</h2><ol>
<li>字符如何转换为整形：’1’ - ‘0’=1;  ‘2’ - ‘0’=2,它俩是用ASCII码相减的即49-48=1,auto在c中自动变量可以省略 自动分配空间 自动释放空间auto在c++中自动推到类型</li>
<li>十进制数是站在用户角度 原码 二进制 八进制 十六进制 站在计算机角度 补码<br>int 4个字节 32位(每个字节8位)1000 0000 0000 0000 0000 0000 0111 1011<br>8000007b 一看就是补码 考虑有符号位时(%d\n)需要转成原码 考虑无符号位时(%u\n)不需转，直接是原码</li>
<li>8位数值越界 char a=127+2；129 的二进制1000 0001 这是负数补码(从计算机角度考虑二进制是补码)1000 0001的原码是1111 1111 是-127</li>
<li>程序运行过程：需要运算不能再内存中运算，需要内存中数据加载到寄存器，再运算，把运算结果从寄存器中移回内存</li>
<li>Sizeof():字符个数包括”\0”;Strlen():指定字符串长度不包括”\0”;字符串不用取地址&amp;，数组名就是首元素地址;int*p=null; *p=100;其中null也是野指针，也会发生段错误.</li>
<li>```c<br>%c格式对应的是单个字符 %o格式对应的是八进制<br>%d格式对应的是十进制 %x格式对应的是16进制<br>%p格式对应的是地址,一般以16进制方式输出指针<br>%s格式对应的是字符串 %s特点：<br>0、一个数组也想一下都打印出来，需要自己写while<br>1、从首元素开始打印，直到结束符位置<br>2、操作指针所指向的内容<br>eg：char str[]=”hello mike”;<br>printf(“str=%p\n”,*str);打印的str首地址<br>printf(“str=%s\n”,str);打印hello mike<br>printf(“str=%c\n”,*str);*str代表第0个元素，它是char<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">7. 字符数组和字符串的关系：字符串一定是字符数组</span><br><span class="line">   &#96;&#96;&#96;c</span><br><span class="line">   eg：char[]&#x3D;&quot;abc&quot;;默认后边带&quot;\0&quot;</span><br><span class="line">   字符数组char[]&#x3D;&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;</span><br><span class="line">   str[0]代表操作首元素地址中的内存，str[0]&lt;&#x3D;&gt;*(str+0)&lt;&#x3D;&gt;*str</span><br><span class="line">   &amp;str[0]代表获取到首元素的地址，&amp;str[0]&lt;&#x3D;&gt;str</span><br><span class="line">   p++&lt;&#x3D;&gt;&amp;str[0]+1</span><br></pre></td></tr></table></figure>
<img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C1.png" alt="avatar"></li>
<li>指针：<ol>
<li>如果操作p，就是操作p变量指向内存</li>
<li>指针变量不同于普通变量</li>
<li>数组指针不同于普通数组</li>
<li>实参和形参 实参是零级指针要想赋值 需要形参是一级指针</li>
<li>数组指针<code>*p</code>代表操作了首元素指向的地址 普通数组<code>*p</code>代表首元素,<code>*</code>解引用去操作指向的内存操作*p，就是操作指针指向内存.</li>
<li><code>*p</code>等价于*(p+0)，同时等价于p[0];操作指针所指向的内存.</li>
<li>!!!(p[0]不同于普通数组，不代表代表首元素，而是操作了首元素地址指向内存。因为p代表首元素地址&amp;p[0],所以 <em>p=</em>&amp;p[0]=p[0]，操作了int a)</li>
<li>个人理解 可以把p指针看成一个元素的数组指针p[];</li>
<li>指针数组<code>*p</code>代表首元素，数组指针*p代表操作首元素地址</li>
<li>一级指针操作零级指针 二级指针操作一级指针</li>
<li>普通指针p[0]不同于指针数组的p[0]差一层级</li>
<li>因为普通指针p存放的是别的元素的地址，指针数组p存放的是自己数组的首地址</li>
<li>!!!<code>*p</code>等价于*0xaabb (*代表操作地址对应内存(内容),p存的就是地址)两者都是操作0xaabb这个地址的内容</li>
<li>只有定义后的变量，此变量的地址才是合法地址,int *p 没有初始化时，p默认的值是随机数(0xaabbcc)</li>
<li>!!!指针变量默认存储的值是十六进制的地址，int类型变量默认存储的值是整型(100)</li>
<li><img src="C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C2.png" alt="avatar"></li>
</ol>
</li>
<li>首先p是一个指针数组，数组中每个元素存放指针 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">p[<span class="number">0</span>]操作的是p数组，*p[<span class="number">0</span>]操作的是a数组，&amp;a[<span class="number">0</span>]取a数组首元素地址</span><br><span class="line">p[<span class="number">0</span>]代表首元素地址的内容是&amp;a[<span class="number">0</span>]，直接操作p[<span class="number">0</span>]没有意义，*p[<span class="number">0</span>]才行</span><br><span class="line">p代表p数组的首元素地址&amp;p[<span class="number">0</span>], 所以*p代表p数组的首元素地址的内容(也就是地址指向的内存) </span><br><span class="line"> !!! 所以p[<span class="number">0</span>]&lt;=&gt;*p&lt;=&gt;*(p+<span class="number">0</span>)</span><br><span class="line"> !!! 其中的p不同于普通指针中的p</span><br><span class="line"> 我指针把地址给你 你就指向我    我要指向你 我比你多个*</span><br><span class="line"> eg <span class="keyword">int</span> ****p 我定义一个什么类型保存变量p  <span class="keyword">int</span> *****p来保存</span><br></pre></td></tr></table></figure>
 <img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C3.png" alt="avatar"></li>
<li>只要是变量常量都有地址，无论指针变量、文字常量``char *str1=”abc”;其中abc存在data的字符常量区，str1存的是首元素地址，不能修改str1指向的内存数组名是常量不能更改<br><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C4.png" alt="avatar"></li>
<li>指针数组是数组，数组指针是指针，指针函数是函数，都是看后边的<br>!!!P[i]等价*(p+i);内存就是数组，只要是指针都可以用”[]”，<br>转换偏向于从p[i]=&gt;*p   适用于指针数组和指针<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span>&lt;</span>=&gt;<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> a[])</span>&lt;</span>=&gt;<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> *a)</span></span></span><br><span class="line">fun中&quot;int a[10]&quot;不是数组是普通指针变量  a[]&lt;=&gt;*a</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">char</span> **p,<span class="keyword">int</span> n)</span></span>; </span><br><span class="line">**p不是二维数组是指针数组，但是*p在形参中代表普通指针</span><br><span class="line">等价于<span class="function"><span class="keyword">void</span> <span class="title">print_array</span><span class="params">(<span class="keyword">char</span> *p[],<span class="keyword">int</span> n)</span></span>;</span><br><span class="line">!!!当数组名作为函数参数的时候，会退化成为指针</span><br></pre></td></tr></table></figure>
<img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C5.png" alt="avatar"></li>
<li>```c<br>//p2是指针数组，其中char*存的是字符串”abc”地址<br>char <em>p2[]={“abc”,”mike”,”hello”};<br>//p2是char**类型，指向char</em>(单个指针)<br>char **p2={“abc”,”mike”,”hello”};//err    p2就是一个变量<br>如果char *tmp;   char *<em>p2=&tmp;//ok 指针p2指向tmp自己的地址<br>p2首元素是char</em>类型  &amp;p2[0]等价于p2<br>char **p=p2；//char *<em>指向char</em><br>char **p=&amp;p2[0];<br>如果char *p2[]作为函数参数，可以改为char **p2，数组当成指针用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">13. </span><br><span class="line">   - scanf()从缓冲区取内容</span><br><span class="line">   - fp文件指针，只要调用了fopen()函数就会指定文件(1.txt);</span><br><span class="line">   - fp指针只能借助文件库函数来操作</span><br><span class="line">   - fopen()在堆中开辟空间存放FILE结构体，并返回地址给fp指针，FILE结构体中有文件标识符(1024个)，与硬盘中文件建立连接，其中012被占用</span><br><span class="line">   - 没有fp&#x3D;fopen，然后fclose(fp)会段错误</span><br><span class="line">14.  C中函数的执行顺序是从上到下，如果自定义函数写在main函数的下边，需要在main函数的上边声明一下，然后在main函数中才可以调用变量的定义和声明不一样</span><br><span class="line">15. 普通局部变量不初始化，它的值为随机数static局部变量不初始化，它的值为0全局变量和static全局变量 不初始化都是0 &#96;&#96;static_fun()&#123;int a&#x3D;10; static int j&#x3D;a;&#125;&#96;&#96;j先分配的空间 a是当函数调用的时候才会有所有static只能用常量初始化</span><br><span class="line">16. #define和typedef区别</span><br><span class="line">    1. 前边是宏定义在预处理阶段</span><br><span class="line">    2. #define INT int；前边替换后边的</span><br><span class="line">    3. typedef在预编译阶段</span><br><span class="line">    4. typedef int int64；后边替换前边的</span><br><span class="line">17. %c和%d中间ASCII转换:</span><br><span class="line">    1. 数组清零</span><br><span class="line">    2. int b[10]&#x3D;&#123;0&#125;; 初始化可以这样赋值，数组个数是10 但是数组赋值的时候 最多到b[9] b[10]越界</span><br><span class="line">    3. &#x2F;&#x2F;处理一些代码，把b内部的元素改了 想重新清零</span><br><span class="line">    4. b[10]&#x3D;&#123;0&#125;;&#x2F;&#x2F;err !!!没有10这个元素</span><br><span class="line">18. return 0：一般用在主函数结束时，按照程序开发的一般惯例，表示成功完成本函数。</span><br><span class="line">return -1：:表示返回一个代数值，一般用在子函数结尾。按照程序开发的一般惯例，表示该函数失败；</span><br><span class="line">19. sizeof()测的是指针的长度(不是4就是8)，strlen()函数测的是字符串的长度&#96;&#96;int *p；&#96;&#96;&#x2F;&#x2F;指向堆区int类型空间,&#96;&#96;p&#x3D;(*int)molloc(sizeof(int));&#96;&#96; 但是保存的还是首元素地址,指针大小是根据系统位数决定的，32位 4个字节 64位 8个字节,size_t无符号整型</span><br><span class="line">地址也有地址，指的就是指针变量也有地址&#96;&#96;int *p&#x3D;NULL；printf(&quot;*p&#x3D;d%\n&quot;,*p);&#96;&#96;&#x2F;&#x2F;err,操作空指针指向的内存</span><br><span class="line">20. &#123;&#125;结尾有分号的两个 do while，struct，enum，联合体struct Student &#123; int age; char name[50]; int score;&#125;结构体是一个类型，在没有定义前 是没有分配空间的struct Student tmp；才会分配内存</span><br><span class="line">21. 在程序没有执行前，前三个分区已经确定了程序没有结束 heap空间不会自动释放data区分两部分：全局变量 static变量区和文字常量区!!!段错误 都是内存出现问题</span><br><span class="line">   ![avatar](&#x2F;C语言学习&#x2F;C6.png)</span><br><span class="line">22. 地址传递，形参修改影响到实参，所以函数中想打印实参而且不想通过参数被修改，所以可以用到coust</span><br><span class="line">   ![avatar](&#x2F;C语言学习&#x2F;C7.png)</span><br><span class="line">23. .h文件不能放定义，多个.c文件时容易发生重复定义所以.h文件存放声明 extern int a；static全局变量只能本文件(main.c)使用， 别的文件(test.c)不能使用main.c不引入头文件 然后自己声明，在test.c中定义全局变量和函数也是可以的getG();调用 无论是c还是c++，函数和变量都是“就近原则”register寄存器变量</span><br><span class="line">   ![avatar](&#x2F;C语言学习&#x2F;C8.png)</span><br><span class="line">24. ！！！指针赋值 ：在堆区开辟一块内存，他的地址固定 ，所以可以声明多个指针变量指向这个内存地址(c语言day15_指针复习)</span><br><span class="line">## C文件</span><br><span class="line">1. sprintf(buf,&quot;d%\n&quot;,num);字符串是以&quot;d%\n&quot;这种形式放到buf中</span><br><span class="line">sscanf(buf,&quot;d%\n&quot;,&amp;num);是以&quot;d%\n&quot;这种形式提取到num中</span><br><span class="line">2. int ch&#x3D;fgetc(fp); 返回值是读取到的字符；fgets(char*,sizeof(),char*stream)按行读取printf(&quot;ch&#x3D;%d\n&quot;,ch); fputc和fgetc主要根据文件指针操作文件初始的标志位都是在最前边</span><br><span class="line">   &#96;&#96;&#96;c</span><br><span class="line">   struct Student</span><br><span class="line">   &#123;</span><br><span class="line">   char *name;int id;int name_len;</span><br><span class="line">   &#125;Stu;</span><br><span class="line">   Stu s; s.id&#x3D;1; s.name_len&#x3D;strlen(&quot;mike&quot;);</span><br><span class="line">   s.name&#x3D;(char*)malloc(s.name_len+1);</span><br><span class="line">   printf(name&#x3D;%s,s.name);打印出mike，</span><br><span class="line">   printf(name&#x3D;%p,s.name);打印出0x112233，</span><br><span class="line">   s%代表指针指向内存</span><br></pre></td></tr></table></figure></li>
<li>文件分为：磁盘文件和设备文件,磁盘文件分为：文本文件和二进制文件<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fp=fopen(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;w&quot;</span>);<span class="comment">//文件内容清空</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);<span class="comment">//追加</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);<span class="comment">//只读</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>);<span class="comment">//可读可写不新建</span></span><br><span class="line">fp=fopen(<span class="string">&quot;text.txt&quot;</span>,<span class="string">&quot;w+&quot;</span>);<span class="comment">//可读可写新建</span></span><br></pre></td></tr></table></figure>
Windows中 b是二进制的意思 在linux中用r和rb结果是一样的<br>windows 平台的换行符”\r\n”;linux平台的换行符”\n”;<br>windows中读取的时候 会将所有的\r\n转换成\n;写入的时候 会将所有的\n转换成\r\n<br>所有读写的时候要写”wb”或者”rb” 是以二进制的方式打开，有什么字符就是什么字符 不会转换</li>
<li>字符可以直接比较，因为是ASCII码，文本文件最后是有一个”-1”类似于字符串最后有一个”\0”，fputc将字符放到指定的文件中或者屏幕中(stdout)；fgetc从键盘读取字符(stdin)</li>
<li>fread()读取完一个结构体时，光标也会自动移动到下一个结构体，类似于fgetc中读取到”\n”然后换行，fread()和fwrite()的特点光标自动移动<br><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E6%96%87%E4%BB%B61.png" alt="avatar"></li>
<li>```c<br>int <em>p 我需要保存你的地址，在原来类型的基础上多加</em>，所以int <strong>p<br>void fun(int</strong>p)<br>{        }<br>void main()<br>{ int *p=NULL;<br>fun (&amp;p);    }<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   1. 因为p本身就是int*</span><br><span class="line">   2. 首先&amp;p代表地址需要用指针变量存</span><br><span class="line">   3. 能存放&amp;p的变量应该是&#96;&#96;int**q，因为**q&#x3D;*p&#96;&#96;值传递不能影响实参，所以需要一个地址传递&amp;p，所以需要一个二级指针，通过函数返回值改变p，但是只能返回一个。</span><br><span class="line">   结构体数组可以用元素操作 也可以用地址操作 也可以通过一个指针指向首元素 &#96;&#96;Struct Student *p &#x3D;a; 	 p&#x3D;&amp;a[0];&#96;&#96;</span><br><span class="line">## C语言提高</span><br><span class="line">1. continue语句的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环</span><br><span class="line">   - ![avatar](&#x2F;C语言学习&#x2F;C提高1.png)</span><br><span class="line">2. &quot;%*&quot;忽略的意思，&quot;%[]&quot;匹配的意思。先是忽略非#，然后匹配非@，出现@匹配失败就不匹配了;忽略遇到空格或者\t代表忽略结束</span><br><span class="line">   - ![avatar](&#x2F;C语言学习&#x2F;C提高2.png)</span><br><span class="line">3. &#96;&#96;&#96;c</span><br><span class="line">   --&gt;fputc(buf[i]，f_write); &#x2F;&#x2F;写入文件</span><br><span class="line">   --&gt;fgetc(f_read);       &#x2F;&#x2F;读文件</span><br><span class="line">   --&gt;fputs(buf[i]，f_write);    &#x2F;&#x2F;写字符串到文件</span><br><span class="line">   --&gt;fgets(buf，1024，f_read)；&#x2F;&#x2F;从文件中读取到buf中</span><br><span class="line">   --&gt;fwrite(&amp;heros[i],sizeof(struct Hero),1,f_write);&#x2F;&#x2F;将数组写入到文件中</span><br><span class="line">   --&gt;fread(&amp;temp,sizeof(struct Hero)，4，f_read); &#x2F;&#x2F;从文件中读取到数组</span><br><span class="line">   --&gt;fprintf(f_write，&quot;%d&quot;，2018);   &#x2F;&#x2F;通过%d，格式化输出到文件中</span><br><span class="line">   --&gt;fscanf(f_read，&quot;%s&quot;，buf);   &#x2F;&#x2F;从文件中读取 存到buf中</span><br><span class="line">   --&gt;sprintf(buf，%s %s”，str1，str2);&#x2F;&#x2F;可以从str1中读取字符串，输出到buf中</span><br><span class="line">   --&gt;sscanf(str，%*d%s，buf1);  &#x2F;&#x2F;从str中读取 存到buf1中</span><br><span class="line">   --&gt;printf(“%d\n”,123);     &#x2F;&#x2F;123输出到屏幕</span><br><span class="line">   --&gt;scanf(&quot;%s&quot;,userName);   &#x2F;&#x2F;键盘输入到userName</span><br><span class="line">   --&gt;memcpy(buf，&amp;a，sizeof(int)); &#x2F;&#x2F;从a中拷贝到buf中</span><br><span class="line">   --&gt;strcpy(p，&quot;hello&quot;);     &#x2F;&#x2F;给p指向内存拷贝  拷贝到p指向内存</span><br><span class="line">   ***标准输出输入格式可以看作是分支和主干的关系</span><br><span class="line">   ***标准输出格式(分支到主干)是在被调中分配内存 主调中使用 </span><br><span class="line">   ***文件fgetc和sprintf都是把后边文件指针看做 分支 </span><br><span class="line">   ***读的时候从分支中读 写的时候往分支里写</span><br><span class="line">   ***遇到空格换行</span><br><span class="line">   while((ch&#x3D;fgetc(f_read))!&#x3D;EOF)</span><br><span class="line">   &#123;printf(&quot;%c&quot;,ch);&#125;&#x2F;&#x2F;当ch不是eof时，循环打印字符</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E6%8F%90%E9%AB%983.png" alt="avatar"></li>
</ul>
</li>
<li>字符串反转：其中<code>char temp=*start；</code>解引用（地址） 解出里边的数据也可以叫做操作地址指向的数据,***野指针没有权利free<ul>
<li><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E6%8F%90%E9%AB%984.png" alt="avatar"></li>
</ul>
</li>
<li>输出特性，在被调函数中分配空间主调函数中利用，想改变<code>char*p</code>的值 不能值传递需要间接赋值，通过地址传递，而修饰地址的地址需要用到二级指针 实际上*pp就是操作p的内存，因为pp中放的就是p的地址 改变了NULL<ul>
<li><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E6%8F%90%E9%AB%985.png" alt="avatar"></li>
</ul>
</li>
<li>栈底 高地址 高位字节数据 栈顶低地址 低位字节数据 （小端对齐）然后取地址发现俩个地址之间相差12 不是16 是因为有一个存的指针 </li>
<li>内存是一个一个字节的放 16进制=4个2进制=4位 8位=1字节 所以0x11223344=4个字节,地址默认就是16进制，但是%d打印出来的是int类型 需要转成int*类型,函数返回地址 代表函数执行完之后跳到哪里，存在栈区(存放第二行指令)在函数调用前先记录一下.代码可不是连续的 func函数执行完会直接跳到main函数的return的</li>
<li>字符串拷贝的牛逼写法<ol>
<li>主函数：<br><code>void test02（）&#123;char*str=&quot;hello world&quot;;char buf[1024]; copyString03（buf ,str）; printf（&quot;%s\n&quot;,buf）; &#125;</code></li>
<li>被调函数：<br><code>void copyString03（char *dest,char *src）&#123; while（*dest++=*src++）&#123;&#125;&#125;</code></li>
<li>***while条件中a=0跳出循环 不等于0不跳出循环</li>
</ol>
</li>
<li>char *p=NULL;//给p指向的内容拷贝内容;strcpy（p,”1111”）;空指针可以重复释放 但是野指针不可以重复释放;int a=1000； 只占四个字节 因为是int类型 跟后边的值没有关系</li>
<li>二维数组也是线性连续的内存，只不过是人为划分成了2维数组<br>一维数组 的数组指针 int(*p)[5]=&amp;arr；<br>二维数组 的数组指针 int(*p)[3]=arr； 一维数组的名代表指向第一个元素<br>二维数组 的数组指针 int(*p)[3][3]=&arr;   变量p就是一维数组指针<br>二维数组除了两种特殊情况外 二维数组名称是指向第一个一维数组  数组指针</li>
</ol>
<ul>
<li>```c<br> printf(“%d”,arr[1][2]);<br> printf(“%d”,<em>(</em>(array+i)+j));<br> array[3][3] 等价于一维数组指针<br> int(*array)[3]; 存了三个数组指针<br> 对比字符串不能用地址去对比 要用strcmp(pArr[max],pArr[j])==-1 表示&lt; <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">11. 两种特殊情况(其他情况都是代表四个字节，比如作为参数)</span><br><span class="line">       &#96;&#96;&#96;c</span><br><span class="line">       一维数组名不是 指向第一个元素的指针</span><br><span class="line">       int arr[5]&#x3D;&#123;1,2,3,4,5&#125;;</span><br><span class="line">       printf(&quot;%d\n&quot;,sizeof(arr));&#x2F;&#x2F;20 要是int*类型的话 是4</span><br><span class="line">       1. sizeof </span><br><span class="line">       2. 对数组名取地址 得到数组指针 步长是整个数组长度</span><br><span class="line">       printf(&quot;%d\n&quot;,&amp;arr);</span><br><span class="line">       printf(&quot;%d\n&quot;,&amp;arr+1); 跳跃了20 </span><br><span class="line">       arr数组名 它是一个指针常量 指针的指向不可以修改 指针指向的值可以修改</span><br><span class="line">       int * count a,count int * a ，常量指针值不可以修改，指针可以修改</span><br><span class="line">       arr[0]&#x3D;2200; ok     arr&#x3D;NULL;err</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="12">
<li>```c<br>int <em>pArray=(int</em>)malloc(sizeof(int)*5);<br>***返回的int类型数组首地址等价于栈区的指针数组<br>**<em>也可以理解为4</em>5个字符数组的首4个字符地址<br>类似于字符数组<br>**<em>连续线性空间可以当成一个数组<br>p=(char</em>)malloc(strlen(“hello”)+1);<br>strcpy(p,”hello”);<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">13. &#96;&#96;&#96;c</span><br><span class="line">    FILE *pFile&#x3D;fopen(&quot;.&#x2F;test.txt&quot;,&quot;r&quot;);</span><br><span class="line">    while（fgets（buf，1024，pFile）！&#x3D;NULL）</span><br><span class="line">    &#123;line++；&#125;调用fgets时光标会自己移动到文件尾,</span><br><span class="line">    需要将文件光标置首(FILE指针在统计完行之后没有置于光标的首，</span><br><span class="line">    然后接着往read&#39;FileData中放，所以不会读取到数据)</span><br><span class="line">    fseek（pFile，0，SEEK_SET）;</span><br></pre></td></tr></table></figure></li>
<li>自定义结构体可以理解为字符数组，有个首地址结构体存放变量 有个内存对齐 以大的为准<ol>
<li>位运算中 1代表真 0代表假</li>
<li>进制中 1代表负 0代表正数</li>
<li>电源中 1代表接通 0代表关闭</li>
<li>~代表按位取反 ，按位与&amp; 全真为真 一假为假</li>
<li>按位或 全假为假 一真为真</li>
<li>按位异或 相同为假 不同为真</li>
<li>***位运算实现交换</li>
<li>左移n位 需要乘2的n次方  0000 0001&lt;&lt;1  0000 0010</li>
<li>右移n位 需要除2的n次方  1000 1010&gt;&gt;2  0010 0010</li>
<li>右移运算 有些机器用0填充高位 有些机器用1填充高位</li>
<li>如果无符号都是用0填充</li>
</ol>
</li>
<li>&amp;取地址<code>*操作地址 []操作地址 pArray首元素地址=*pArray[0]=**int</code><br>数组名作为函数参数的时候会退化为指针，是因为数组名本身就是首元素地址</li>
<li>声明变量时<code>int **pArray 中的pArray相当于提取了两边地址（可以理解为引用），想操作内存的时候需要**pArray</code>(可以理解为解引用)。</li>
<li>由于每一行都是一个字符串所以用char<em>存;输入特性是从主到调 在主调函数中申请内存<br>输出特性是从调到主 在调用函数中申请内存;如果主函数中``char</em>* pArray=NULL ``需要在调用函数中用到3级指针同级指针修饰不成功可以用高级指针接收修饰就可以了</li>
<li>数组指针 int (*p)[5] 与指针数组int *p[3]不一样;二级指针都是指针数组首地址<br>指针大小是由系统决定一般都是4个字节或者8个字节</li>
</ol>
<ul>
<li>*arrP=arr==数组名</li>
<li><code>int *p=&amp;arr；</code>不等价<code>typedef int(ARRARY_TYPE)[5]；//ARRARY_TYPE</code>代表存放5个int类型的数组 的数据类型,这时可以用ARRARY_TYPE类型的指针接收 arr的地址 因为此时arr中有20个字符 如果用普通的二级指针接收的话只能存4个字节</li>
<li>开始写<code>int *p=&amp;arr；会提示“int *”与“int (*)[5]”</code>的间接级别不同</li>
</ul>
<ol start="19">
<li>perror（”打印文件失败”）；//打印显示信息和error宏相应信息</li>
</ol>
<p>***字符指针存放字符串地址 结构体指针存放自定义类型<br>**<em>结构体malloc开辟空间，如果结构体是一个 用char</em>存放地址 如果是多个，用char*存放首地址<br>***定义变量时 如果数组存的是指针 需要用二级指针维护，因为想实现引用传递 改变指针数组 需要用&amp;指针数组即三级指针</p>
<h2 id="C提高"><a href="#C提高" class="headerlink" title="C提高"></a>C提高</h2><ol>
<li><ul>
<li>主调函数中没有分配内存 被调函数用（高级指针）二级指针维护和分配内存，然后下边调用可以用同级指针</li>
<li>如果函数的参数是同级指针，类似于值传递，只能临时改变它的值。</li>
<li>尤其是free的时候，如果同级指针参数传递，需要在外边再释放一次</li>
<li>如果函数的参数是高一级指针，类似于地址传递，改变了这个指针的值</li>
</ul>
</li>
<li>通过偏移量 操作内存<ul>
<li><code>printf(&quot;t1.p=%d\n&quot;,*(int*)((char*)&amp;t1+offsetof(struct Teacher,b)));</code><br>offsetof 代表指针偏移数量 返回int类型</li>
<li>上述代码表示 <code>char*类型</code>的t1首地址加上偏移量转成int*类型 在解引用</li>
</ul>
</li>
<li>传参时<ul>
<li>主调函数中的二级指针需要被调函数参数的三级指针去接收，或者用二级指针，函数返回值的方式接收</li>
<li>释放的时候如果不是三级指针接收的 需要在最外边在释放一次</li>
<li>char ** Student；存放指针数组相当于 用数组解了一层引用 再用*表示地址 可以理解为一个学生是一个char *</li>
<li>char**是个数组 </li>
<li>在堆区开辟地址存放结构体数组之类的 尽量用指针</li>
<li>name就是字符地址 因为是字符串 字符串名是地址</li>
<li>开辟内存 建立关系***strlen（pos+1）代表从pos+1位置到最后的个数</li>
<li>在堆区分配内存 不能同时赋初值 需要在第二行初始化,浅拷贝在堆区分配内存 会出现重复释放 重复释放就是释放野指针</li>
<li>内存对齐的 对其模数是2的n次方查看当前对齐模数 #pragma pack(show)；也可以是#pragma pack(1);</li>
<li>pragma once防止头文件重复这里默认的对其模数是8 左边的结果是24（8*3）右边的结果是17 对其模数1,因为double要放在8 所以char放在4~7 前一个数偏移多少要看后面的</li>
<li>没有内存对齐 好多变量都要二次访问 </li>
<li>内存对齐使用空间换时间</li>
</ul>
</li>
<li>递归函数必须有退出条件，否则一会儿栈区内存就满了,斐波那契数列就是利用递归函数 函数的退出条件就是前两个数</li>
<li>预处理的基本概念：c语言对源程序处理的四个步骤：预处理（展开宏）、编译（做语法检测）、汇编（生成二进制文件）、链接（生成exe）。</li>
<li><ol>
<li>链表的分类一：<ul>
<li>静态链表  在栈上分配内存   在当前函数中运用</li>
<li>动态链表  在区分配内存   只要不释放掉</li>
</ul>
</li>
<li>链表的分类二：<ul>
<li>单向链表  双向链表</li>
<li>单向循环链表  双向循环链表</li>
<li>带头节点和不带头节点的链表：带头节点链表中头节点只有指针域，指向头节点。如果在头节点插入节点，只需要访问头节点.nest（真实有数据）就可以</li>
</ul>
</li>
</ol>
</li>
<li>函数指针（数组有三种定义方式）也有三种定义方式<ol>
<li>先定义出函数类型，再通过类型定义函数指针<br>typedef void(FUNC_TYPE)(int, char);      FUNC_TYPE* p=func；</li>
<li>定义出函数指针’类型’，再通过类型定义函数指针’变量’<br>typedef void( * FUNC_TYPE2)(int, char);   FUNC_TYPE2 p=func;</li>
<li>直接定义函数指针变量<ul>
<li>void(*pFunc3)(int, char) = func; pFunc3();</li>
</ul>
</li>
<li>函数指针数组  void(*pArray[3])();</li>
<li>不存在函数数组指针，因为函数 数组指针（函数数组 指针）是两个概念，但都是指针<br>类似于定义数组指针<ul>
<li>函数名(func)本质就是一个函数指针   可以利用函数指针调用函数 </li>
<li>函数调用的操作符就是”（）”    func+（）==&gt;变量+（） 就是调用函数了</li>
</ul>
</li>
<li>定义一个函数类型 主要是 返回值类型和形参的类型  cdecl调用惯例</li>
<li>函数指针和指针函数<ul>
<li>函数指针 指向了函数的指针</li>
<li>指针函数 函数返回值是指针的函数</li>
</ul>
</li>
</ol>
</li>
<li>难：函数指针作为函数参数叫回调函数<br>提供一个打印函数 可以打印任意类型的数据;为什么printTest中函数指针作为函数参数？<ul>
<li>首先printTest中是没有办法确定数据类型的，可以取到a的内存首地址</li>
<li>不能写printf,是因为不知道格式化怎么去写,所以把接口交还给客户，架接起“桥梁”。</li>
<li>myPrint和myPrintInt只要是返回值和参数类型相同就可以，一个是形参一个是实参</li>
<li>所以函数名作为参数的时候可以代表回调函数或者仿函数</li>
</ul>
</li>
<li>回调函数：<ul>
<li>一开始不能确定的东西，我们回头再去调用。类似一个接口 等待我们去实现，用户只要更改int* num=data；中的数据类型就可以</li>
<li>打印需求可以直接调用myPrintInt去执行，也可以通过调用中间函数printAllArray去执行（中间函数中存在回调函数类似于多态和工厂模式）</li>
<li>需要用户自己，交还给用户，需要用到回调函数</li>
</ul>
</li>
<li>声明外部函数(导出函数):<ul>
<li>__declspec(dllexport) int myminus(int a ,int b);</li>
<li>declspec代表特殊声明 declear声明 specail特殊 dllexport dll导出的意思</li>
<li>动态库添加现有项的其他方法 main函数前添加#pragma comment（lib，“./mydll.lib”）;添加声明</li>
<li>静态库生成的.lib文件（声明和实现都在lib中）和动态库生成的.lib文件是不同的，动态库中的.lib只会放变量的声明和 导出函数的声明，函数实现体放在.dll中</li>
</ul>
</li>
<li>插入节点到链表中<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 	<span class="title">LinkNode</span> *<span class="title">newNode</span>=</span><span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct LinkNode));</span><br><span class="line">newNode-&gt;num =val;</span><br><span class="line">newNode-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">pTail-&gt;next=newNode;/更改指针指向</span><br><span class="line">pTail=newNode;<span class="comment">//更新新的尾节点指向</span></span><br></pre></td></tr></table></figure>
链表反转时 pNest的作用就是记录一下后边到哪了，因为pCurrent指针指向的是前边的链表<ul>
<li><img src="/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/C%E9%93%BE%E8%A1%A8.png" alt="avatar"></li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/21/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" data-id="ckp3bilin00054sueg03wbujw" data-title="C语言学习" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-Unity项目总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/19/Unity%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2021-04-19T00:22:30.279Z" itemprop="datePublished">2021-04-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/19/Unity%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/">Unity项目总结</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="UnityApp项目总结"><a href="#UnityApp项目总结" class="headerlink" title="UnityApp项目总结"></a>UnityApp项目总结</h2><h3 id="虚拟仿真项目"><a href="#虚拟仿真项目" class="headerlink" title="虚拟仿真项目"></a>虚拟仿真项目</h3><ol>
<li>开源模型：<a target="_blank" rel="noopener" href="https://opengameart.org/">https://opengameart.org/</a></li>
<li>防止无限生成AudioSource 注释掉这句<code>m_AudioSource.Play()</code>,静态的门是不会旋转的，只能旋转他的collider</li>
<li>unity加载视频和淡入淡出:</li>
</ol>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/itsxwz/article/details/82626930">https://blog.csdn.net/itsxwz/article/details/82626930</a></li>
<li><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/article/456c463b32b96e0a5931446b.html">https://jingyan.baidu.com/article/456c463b32b96e0a5931446b.html</a></li>
</ul>
<ol start="4">
<li>eulerAngles和rotation区别：eulerAngles的角度是不能随时变化的，是一个定值，而rotation的角度是可以增加的，eulerAngles用vector3来赋值，而rotation用Quaternion来赋值</li>
<li>语音主播名字<ul>
<li><img src="/Unity%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%9F%B3%E6%B2%B9%E9%A1%B9%E7%9B%AE%E8%AF%AD%E9%9F%B3%E4%B8%BB%E6%92%AD%E5%90%8D%E5%AD%97.png" alt="avatar"></li>
</ul>
</li>
<li>unity中最好不用while(true)函数调用update中的material循环调用offset，不适合使用单例模式Generate Colliders选项，然后即会自动在预支体或游戏物体中生成一个Mesh Collider组件，并添加了Mesh，若没有生成组件，可自行导入。</li>
<li>fps游戏优化：</li>
</ol>
<ul>
<li>视锥剔除(Frustum Culling) 在相机梯形的体积中的物体就会显示出来。因此：可以通过调节field of view 从60变成30，clipping planes 的far从1000变成300或者更小</li>
<li>遮挡剔除：空场景有默认的天空盒子tris为1.7k想遮挡的物体设置成静态，相机不设置静态，然后bake</li>
<li>平面不能添加mesh collider 点选Convex选项报错<code>[Physics.PhysX] ConvexHullBuilder::CreateTrianglesFromPolygons: convex hull</code></li>
</ul>
<ol start="8">
<li>功能点介绍：</li>
</ol>
<ul>
<li>使用HighlightingSystem插件实现鼠标移动到物体物体高亮效果</li>
<li>使用 背景音乐和音效管理模板</li>
<li>悠游课堂射线碰撞检测和loading界面加载 异步加载场景(loading界面)</li>
<li>简单地图导航循环长箭头实现(导入一张贴图，注意图片的 Wrap Mode 为 Repeat)</li>
<li>Updatel里间隔时间调用</li>
<li>切换到GUI场景鼠标就消失了用<code>Cursor.visible=(true);</code>光标就在中间不动了，怎么让光标移动？<code>m_MouseLook.SetCursorLock(false);</code></li>
<li>基础包 FirstPersonController下的MouseLook 脚本研究</li>
<li>优化 Occlusion和LOD Occlusion Culling遮挡剔除理解设置和地形优化应用</li>
<li>Stats窗口利用，tif格式窗户图片，可以有透明通道 jpg不行</li>
<li>法线翻转 <a target="_blank" rel="noopener" href="https://blog.csdn.net/ch080239/article/details/52099544">https://blog.csdn.net/ch080239/article/details/52099544</a></li>
<li>触发器开关门 注意：1门不能是static 2门父物体的名字唯一</li>
<li>小地图制作：<ul>
<li> 使用UGUI实现小地图</li>
<li> 制作小地图（Minimap）系统</li>
</ul>
</li>
</ul>
<ol start="9">
<li>IEnumerable和IEnumreator使用场合：</li>
</ol>
<ul>
<li>如果要迭代一个类可以使用方法GetEnumrerator()，其返回类型IEnumreator.如果要迭代一个类成员,例如一个方法，则使用IEnumerable</li>
<li>op1？？op2等价于op1==null？op2：op1</li>
<li>C#中this关键字可以用作构造函数初始化器</li>
</ul>
<ol start="10">
<li>抽象类和接口的区别：</li>
</ol>
<ul>
<li>抽象类主要用作对象系列的基类，共享某些主要特征，例如，共同的目的和结构</li>
<li>接口则主要用于类，这些类在基础水平上有所不同，但仍可以完成某些相同的任务</li>
</ul>
<ol start="11">
<li>C#和C++关于switch不一样，在C++中，可以在运行完一个Case语句后，再运行另一个case<br>C#中执行完一个case再执行另一个是非法的</li>
<li>接口就是把公共实例方法和属性结合起来，以封装特定功能的集合，接口这东西子类继承了 子类不用也要写出来，把常用的方法抽象出来，放到一个接口里，具体类按上接口后，再根据类的情况编写方法体。这是JAVA的重要编程思想：问题领域-&gt;对象模型中的对象-&gt;对象模型中的类-&gt;对象模型中的父类。注意最后从 对象模型中的类-&gt;对象模型中的父类 这一步，这样做的目的可提高两个系统间的松耦合。</li>
<li>获取子物体的唯一方法<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span> (Transform child <span class="keyword">in</span> transform)</span><br><span class="line">  &#123;</span><br><span class="line">   <span class="comment">//Debug.Log(child.gameObject.name);</span></span><br><span class="line">     target = child.gameObject;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li>常用缩写翻译： </li>
</ol>
<ul>
<li>CTS：Common Type System通用类型系统</li>
<li>CLR：Common Language Runtime 公共语言运行库，负责管理用.NET库开发的所有应用程序的执行</li>
<li>CTS：Common Type System 通用类型系统</li>
<li>CIL：Common Intermediate Language 通用中间语言</li>
<li>JIT：Just In Time 即时编译器</li>
<li>WPF：Windows Presentation Foundation 建立windows应用程序 其中Windows Forms模块是个控件库</li>
<li>ASP：Active Server Pages   可以通过Web Forms建立ASP.NET应用</li>
<li>WCF：Windows Communication Foundation web服务</li>
<li>ADO.NET：Active Data Objects </li>
<li>OOP：Object-Oriented Programming 面向对象编程</li>
<li>SEH：structured Exception Handling 结构化异常处理</li>
<li>UML：Unified Modeling language 统一建模语言</li>
<li>LINQ：Language Integrated Query</li>
</ul>
<ol start="15">
<li>查找物体方法：</li>
</ol>
<ul>
<li>unity获取所有子物体(不包括父物体)  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="keyword">foreach</span> (Transform item <span class="keyword">in</span> transform)</span><br><span class="line">  &#123;</span><br><span class="line">    Debug.Log(item.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>或者(包括了父物体)  <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">        Transform[] father = GetComponentsInChildren&lt;Transform&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> child <span class="keyword">in</span> father)</span><br><span class="line">        &#123;</span><br><span class="line">            Debug.Log(child.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">- 或者</span><br><span class="line">    ```c<span class="meta">#</span></span><br><span class="line">    <span class="keyword">public</span> Transform father;</span><br><span class="line">      <span class="function"><span class="keyword">void</span> <span class="title">Start</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>      &#123;</span><br><span class="line">        <span class="comment">/* GameObject name2 = GameObject.FindGameObjectWithTag(&quot;erzi&quot;);*/</span></span><br><span class="line">         GameObject[] name3 = GameObject.FindGameObjectsWithTag(<span class="string">&quot;erzi&quot;</span>);</span><br><span class="line">        <span class="comment">// Debug.Log(name2);</span></span><br><span class="line">         <span class="keyword">foreach</span>(<span class="keyword">var</span> son <span class="keyword">in</span> name3)</span><br><span class="line">         &#123;</span><br><span class="line">             Debug.Log(son.name);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">- 可以遍历所有子物体，以及孙物体</span><br><span class="line">  ``<span class="keyword">foreach</span>(Transform child <span class="keyword">in</span> obj.GetComponentsInChildren&lt;Transform&gt;()) ``</span><br><span class="line">  - ``<span class="number">1.</span>GameObject.FindGameObjectWithTag``获取不到隐藏的物体，``Debug.Log(zimu2.Length);``打印数组个数只有gameobject可见，</span><br><span class="line">  - 把所有你要找的东西放在一个对象下面，不就容易找了吗，或者工程启动时直接查找然后再把要关的关上</span><br><span class="line"><span class="number">16.</span> PhotonServer的单服聊天&amp;AB打包和加载注意事项</span><br><span class="line">  - MyServer.cs和MyClient.cs是服务器端的两个类</span><br><span class="line">  - 异步加载需要等待异步加载完成(返回的request)同步的方法就不用<span class="keyword">yield</span>暂停了，他会等待方法加载完才返回``AssetBundleCreateRequest reqeust = AssetBundle.LoadFromMemoryAsync(File.ReadAllBytes(path));<span class="keyword">yield</span> <span class="keyword">return</span> request;AssetBundle ab =request.assetbundle;``第一步异步加载 第二步等待加载完成 第三步加载对象 然后使用里边资源</span><br><span class="line">  - photon server下载安装</span><br><span class="line">    - https:<span class="comment">//www.photonengine.com/en/PUN -&gt;右上角的SDKs-&gt;下边的Server下载</span></span><br><span class="line">    - 点击右上角的头像 -&gt;Your servers</span><br><span class="line">  - 安装Apache和Mysql使用的命令符是在管理员模式下</span><br><span class="line">  - https:<span class="comment">//blog.csdn.net/missing2011/article/details/81474857</span></span><br><span class="line">不用设置环境变量</span><br><span class="line">  - lua安装时需把lua53.exe改成lua.exe</span><br><span class="line">  - 安装Redishttp:<span class="comment">//www.runoob.com/redis/redis-install.html</span></span><br><span class="line">  - php redis 扩展：http:<span class="comment">//pecl.php.net/package/redis/4.1.1/windows</span></span><br><span class="line"><span class="meta">## Unity游戏</span></span><br><span class="line"><span class="meta">### 微信飞机&amp;贪吃蛇&amp;俄罗斯方块技术细节</span></span><br><span class="line"><span class="number">1.</span> GameObject和gameObject的区别（大写是类，小写是对象）</span><br><span class="line">    <span class="number">1.</span> gameObject好理解一点，就是你脚本挂着的那个物体。这个实例化过程是Unity帮你实现的，不用在写代码实例化。<span class="keyword">this</span>.gameObject默认函数，脚本一创建直接就<span class="keyword">get</span>到了。例如，有一个A物体。你给它挂载一个脚本里写<span class="keyword">this</span>.gameObject。那就等于是直接获取（实例化）A这个物体了，你直接可以引用它下面挂载的属性。</span><br><span class="line">    <span class="number">2.</span> GameObject不是对象，通常需要获取一个对象，就像你定义一个<span class="keyword">public</span> GameObject A；那么属性里就会出现一个可托选的框，那就是Unity告诉你，你定义的这个物体是哪个物体要你选择，无论你拖拽也好，脚本里获取也好，都是要给A赋予对象的。</span><br><span class="line">    <span class="number">3.</span> GameObject代表类（人民币），gameObject代表对象（你兜里的人民币） </span><br><span class="line"><span class="number">2.</span> ``InvokeRepeating(<span class="string">&quot;Move&quot;</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>);``类似于委托 三个参数分别是 调用的函数 第一次调用时间 每隔多久再调用一次 cancelInvoke取消所有调用</span><br><span class="line"><span class="number">3.</span> ``GameObject g = (GameObject)Instantiate(tailPrefab,v,Quaternion.identity); ``动态生成预制体（必须是预制体） 同时也是实例化GameObject类 三个参数分别是 预制体 位置 角度 identity是默认角度 !!!先获取预制体<span class="keyword">public</span> GameObject prefab； </span><br><span class="line"><span class="number">4.</span> ```c<span class="meta">#</span></span><br><span class="line">   List&lt;Transform&gt; tail = <span class="keyword">new</span> List&lt;Transform&gt;();</span><br><span class="line">   <span class="comment">//Add to front of list, remove from the back</span></span><br><span class="line">   tail.Insert(<span class="number">0</span>, tail.Last());将元素添加到指定索引处</span><br><span class="line">   tail.RemoveAt(tail.Count - <span class="number">1</span>);移除最后一个元素 Count比index总是多一</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li>```c#<br>public Action OnLose;发送消息-&gt;using System;<br> void OnLose()<br> {<pre><code> textLose.text = &quot;You lose.&quot;;
 textLose.gameObject.SetActive(true);
 Time.timeScale = 0;//一切停止
</code></pre>
 } <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">2. spawn 孵化器的意思，空物体叫spawn，用来动态生成prefab物体 spawner生成器</span><br><span class="line">3. 在Update函数中的&#96;&#96;this.GetComponent&lt;SpriteRenderer&gt;().sprite&#x3D;sprites[frame];&#96;&#96;这样每一帧都需要get查询一下，所以优化时将get写到start中 &#96;&#96;spriteRenderer&#x3D;this.GetComponent&lt;SpriteRenderer&gt;();&#96;&#96;在update中直接调用属性 &#96;&#96;spriteRenderer.sprite&#x3D;sprtes[frame];&#96;&#96;</span><br><span class="line">4. 第一次是不能移动的，因为手指移动了 才可以移动 然后每次都归零</span><br><span class="line">   &#96;&#96;&#96;c#</span><br><span class="line">   if(isMouseDown)</span><br><span class="line">    &#123;</span><br><span class="line">	    if(lastMousePosition!&#x3D;Vector3.Zero)</span><br><span class="line">    &#123;</span><br><span class="line">	    Vector3 offset&#x3D;Camera.main.ScreenToWorldPoint(Input.mousePosition)-lastMousePosition;</span><br><span class="line">	    transform.Position&#x3D;transform.position+offset;</span><br><span class="line">    &#125;</span><br><span class="line">	    lastMousePosition&#x3D;Camera.main.ScreenToWorldPoint(Input.mousePosition);</span><br><span class="line">    &#125;</span><br><span class="line">    然后在</span><br><span class="line">    if（Input.GetMouseButtonUp(0)）</span><br><span class="line">    &#123;</span><br><span class="line">	    isMouseDown&#x3D;false;</span><br><span class="line">	    lastMousePosition&#x3D;Vector3.zero;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><code>transform.Position=new Vector3(x,y,0);</code>transform是个结构体不是对象 不能直接.y</li>
<li>注意触发器是[Collider2D collision],碰撞器是[Collision2D collision]<br>脚本挂在Bullet物体上<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter2D</span>(<span class="params">Collider2D other</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">if</span>(other.tag==<span class="string">&quot;Enemy&quot;</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  other.gameObject.SendMessage(<span class="string">&quot;BeHit&quot;</span>);</span><br><span class="line">  GameObject.Destory(<span class="keyword">this</span>.gameObject);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这里边有两个gameObject，第一个是Enemy的，第二个是Bullet的，SendMessage是调用other.gameObject身上所有脚本中叫BeHit的方法，其中other代表Enemy</li>
<li>box collider2D继承了Collider2D，获取collider物体上的Award脚本<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>（collider.tag==<span class="string">&quot;Award&quot;</span>）</span><br><span class="line">&#123;</span><br><span class="line"> Award award=collider.GetComponent&lt;Award&gt;();</span><br><span class="line"> <span class="keyword">if</span>(award.type==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">  superGunTime=resetSuperGunTime;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>this和this.gameobject区别：this是代码本类，this.gameobject代表代码挂在的对象<code>transform=this.transform=this.gameobject.transform=this.gameobject.getComponent&lt;transform&gt;()</code><h3 id="马舜的保卫萝卜MVC框架和flyBird面向对象思想"><a href="#马舜的保卫萝卜MVC框架和flyBird面向对象思想" class="headerlink" title="马舜的保卫萝卜MVC框架和flyBird面向对象思想"></a>马舜的保卫萝卜MVC框架和flyBird面向对象思想</h3></li>
<li>GameObject的Find方法只能找到可见对象，所以先去查找父节点然后再查找子节点<br><code>GameObject.Find(&quot;Canvas&quot;).transfrom.Find(&quot;UICountDown&quot;).GetComponent&lt;UICountDown&gt;()</code></li>
<li>unity协程用单线程模拟多线程比较安全,unity没办法让面板显示属性，但是可以让字段用public显示,枚举的本质就是int类型</li>
<li>Sorting Layers和Layers的区别:</li>
<li>Sorting Layers层针对是2D 越在下边(defout是最底下一层)，显示越在最上边 和 Hierarchy层一样 </li>
<li>Layers层是逻辑层针对物理检测</li>
<li>unity的2D图集处理 并切割出一张张小图片，ACT战斗游戏建议多放  CG一镜到底，unity GI光照缓存目录 C:\Users\HYY\AppData\LocalLow\Unity\Caches(10G)</li>
<li>Update()内部使用的是反射的机制，重命名关键字 Ctrl+R，R。抽象类不可以实例化</li>
<li>组件信息传递：他们三个都会发送当前对象</li>
<li>SendMessage：发送到自己及自己的兄弟组件（这些组件都在同一个对象上）</li>
<li>SendMessageUpWards：发送到自己所在对象以及父对象和这个根上所有的对象上的组件</li>
<li>BroadcastMessage：发送到自己以及所有的子对象</li>
<li>unity状态机中Parameters中的bool和trigger区别：<br>把bool设置为true时想变回false，需要手动还原，trigger可以自动还原（优势）</li>
<li>事件归零小技巧：while（HpChanged！=null）{HpChanged-=HpChanged}</li>
<li>2D游戏中Math.Atan和Math.Atan2函数：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">float</span> angle=Mathf.Atan（dy/dx）表示<span class="number">-90</span>和+<span class="number">90</span>度之间，</span><br><span class="line"><span class="built_in">float</span> angle=Math.Atan2（dy,dx）表示<span class="number">-180</span>到+<span class="number">180</span>度之间</span><br><span class="line"><span class="comment">//欧拉角是个角度值    angle是弧度角 需要乘以Mathf.Rad2Deg变成角度</span></span><br><span class="line">Vector3 enlurAngles =transform.enlerAngles;</span><br><span class="line">culerAngles.z = angle * Mathf.Rad2Deg;（有的物体默认是向上的所以要减去<span class="number">90</span>度回到朝向右侧）</span><br><span class="line">transform.enlerAngles = eulerAngles;</span><br></pre></td></tr></table></figure></li>
<li>flyBird：<ol>
<li>unity中要常用事件来间解耦合 并且事件不会影响性能 分三步 定义事件 触发事件 监听事件</li>
<li>!!!foreach（Transform child in obs）其中obs不是集合，但是是父物体，能用foreach不要看是不是集合而是看这个类能不能实现IEnumerable这个接口，而Transform组件实现了，所以可以使用foreach</li>
<li>unity中cursor 用作鼠标的光标图片 unity 高级工具系统的”V键吸附工具”</li>
<li>碰撞检测:<ol>
<li>string a1=child.name;//主键名字 name是个属性 用name的时候还是会访问gameObject</li>
<li>string a2 =child.gameObject.name;//游戏对象也有名字</li>
<li>unity为了提供方便用第一个，结果是一样</li>
</ol>
</li>
<li>C#基础知识:<ol>
<li>类型泛型的约束用where<code>public abstruct Class Singleton&lt;T&gt;:MonoBehaviour where T:MonoBehaviour</code></li>
<li>object是C#中的。Object是unity中的</li>
<li>Canvas中Transform的2D组件Rest Transform 。Transform的3D组件是Transform<h3 id="悠游笔记"><a href="#悠游笔记" class="headerlink" title="悠游笔记"></a>悠游笔记</h3></li>
</ol>
</li>
</ol>
</li>
<li>技术细节：<ol>
<li>PlayerPrefs类似一个字典，可以从中getstring 也可以setstring</li>
<li>创建一个域，#region #endregion</li>
<li>枚举转字符串 .ToString()</li>
<li>抽象基类不准许实例化 必须由他的基类实例化，状态是需要每帧都执行的</li>
<li>动画控制器(Animator)和有线状态机不同点：<ol>
<li>战斗待机和普通待机</li>
<li>有限状态机：只有待机</li>
</ol>
</li>
<li>人型动画的优势：当一个角色动画有位移的时候，如果使用人形动画可以让这个角色控制器跟随这个动画走，一般动画达不到这个效果</li>
<li>乘法的效率要比除法高 所以要*0.01 而不是/100</li>
<li>(模型+动画)是一体都在模型上的状态机：<ol>
<li>legacy旧版本 play是正常的播放 CrossFade是用动画融合的方式</li>
<li>Generic新版本 动画控制器系统是通过连线的方式，后边的角色是通过动画重定向就不用重新连线了</li>
</ol>
</li>
<li><ol>
<li> 单例：普通类（实例化）和继承MonoBehaviour的类（创建一个物体）</li>
<li> 协程：停止某个携程是要用StopCoroutine(“test”)；不是StopCoroutine(test());</li>
</ol>
</li>
<li> NGUI中GetComponetsInChildren<UIButton>(true);其中的true代表包含隐藏的按钮<br>UIEventLIstener.Get(btnArr[i].gameObject).onClick=BtnClick;其中onclick传入gameObject</li>
<li>新建一个单独”.cs”文件，里边只存枚举都是public类型，相当于定义在总的命名空间上了</li>
<li>函数参数如果写这个bool cache = false，说明这个参数可填可不填,调用者需要在函数中传入（cache：true）</li>
<li>定义泛型时，如果是普通类就没有什么要求，如果是继承MonoBehaviour需要注意他的约束也必须继承<code>MonoBehaviour：UISceneBase&lt;T&gt;:MonoBehaviour where T:MonoBehaviour</code></li>
<li>克隆预设体：<code>Instantiate(m_BoxPrefab) as GameObject</code>用来读取存储的键值对<code>int number=PlayerPrefs.GetInt(&quot;m_Boxkey&quot;，0)；</code>参数是键值对</li>
<li>射线:<ol>
<li> 直线型 球形</li>
<li> Mathf.Infinity；无限大 Infinity表示float最大值 radius 半径</li>
<li> 层作为参数的写法，1&lt;&lt;LayerMask.NameToLayer(“Item”); item层</li>
<li> 相机到平面的射线：<code>Debug.DrawLine(Camera.main.transform.position, m_TargetPos);</code></li>
<li>把主角的碰撞半径画出来：<pre><code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Gizmos.color=Color.Red;</span><br><span class="line">Gizmos.DrawWireSphere(transform.position,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
</ol>
</li>
</ol>
</li>
<li>碰撞分为两种：碰撞器 触发器<ol>
<li>碰撞脚本绑定在箱子上，然后撞到地面 （1，所在层进行碰撞，2，其中一个物体必须是刚体）</li>
<li>碰撞：OnCollisionEnter(Collision info)，Collision中的Collider代表要撞到的碰撞体info.collider.gameobject.name;  Collision不是组件</li>
<li>触发：OnTriggerEnter(Collider other)，other.gameobject.name;  other直接就是collider组件</li>
<li>角色碰撞器：Character Controller 自带刚体（Rigidbody）不能设置触发。</li>
<li>Character Controller和collider碰撞时，只能检测触发，不能检测到碰撞信息，但是可以产生碰撞</li>
</ol>
</li>
<li>摄像机结构:四层文件夹中包含一个主相机<ol>
<li>CameraFollowAndRotate 修改旋转轴的Y轴 根目录需要加标记 添加脚本 并且运OnDrawGizmos()方法</li>
<li>CameraUpAndDown 修改旋转轴的Z轴 </li>
<li>temp1 方便查看  临时建一个空物体 加标记 这样旋转 就可以查看转动相机 red</li>
<li>CameraZoomContainer 改变x 然后拉出一段距离 然后照着主角  自身标记green</li>
<li>temp2 方便查看  临时建一个空物体 加标记 这样旋转 就可以查看转动相机 blue</li>
<li>CameraContainer 修改位置坐标的 Z坐标  </li>
<li>Main Camera   实现震屏 摄像机动画的功能（需要transform都是0才行）</li>
</ol>
</li>
<li>UI逻辑： 管理器都继承泛型单例类<ol>
<li>ResourceMgr 资源管理器</li>
<li>LogOnSceneCtrl 登陆UI场景控制器 调用SceneUIMgr中的登陆型UI 绑在空物体上 生成 UI Root</li>
<li>SceneUIMgr 场景UI管理器 包含各种型UI 登陆型UI 主城型UI loading型UI</li>
<li>UISceneLogonCtrl UI场景加载控制器 调用WindowUIMgr中的登陆窗口UI 绑在UI Root上 生成panLogOn</li>
<li>WindowUIMgr 窗口型UI管理器</li>
<li>UIlogonCtrl UI加载控制器 绑定panLogOn上 控制button</li>
<li>UIRegCtrl UI注册控制机 绑定在panReg上 控制button</li>
</ol>
</li>
<li>缓存的应用  运用键值对 可以存放地址和资源镜像(clone)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义哈希表(键值对)</span></span><br><span class="line"><span class="keyword">private</span> Hashtable m_PrefabTable;</span><br><span class="line"><span class="comment">//在构造函数中实例化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ResourcesMgr</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">m_PrefabTable=<span class="keyword">new</span> Hashtable();</span><br><span class="line">&#125;</span><br><span class="line">GameObject obj =<span class="literal">null</span>;</span><br><span class="line"><span class="keyword">if</span>(m_PrefabTable;.Contains(path))&#123;</span><br><span class="line">obj=m_PrefabTable;[path]<span class="keyword">as</span> GameOject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">obj=Resources.Load(sbr.ToString())asGameObject;</span><br><span class="line"><span class="keyword">if</span>(cache)&#123;</span><br><span class="line">m_PrefabTable.Add(path,obj);</span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure></li>
<li>泛型&amp;单例 声明所有单例的基类Singleton.cs  定义一个泛型 所有子类继承它时会传给子类一个类型<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&lt;T&gt; where T :new()&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> T instance;</span><br><span class="line"><span class="keyword">public</span> staitc T Instance&#123;</span><br><span class="line"><span class="keyword">get</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance==<span class="literal">null</span>)</span><br><span class="line">&#123;instance =<span class="keyword">new</span> T();&#125;</span><br><span class="line"><span class="keyword">return</span> instance;&#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用时</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ResourcesMgr</span> :<span class="title">Singleton</span>&lt;<span class="title">ResourcesMgr</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> GameObject <span class="title">load</span> (<span class="params">String path</span>)</span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> Resources.Load(path) <span class="keyword">as</span> GameObject;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>协程：<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> IEnumerator <span class="title">Test</span>(<span class="params"><span class="built_in">int</span> x ,<span class="built_in">int</span> y</span>)</span>&#123;<span class="comment">//yield return new WaitForSeconds(2f);</span></span><br><span class="line"><span class="comment">//代表等待执行的秒数</span></span><br><span class="line">debug.log(<span class="string">&quot;1&quot;</span>);<span class="keyword">yield</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">m_Ret=x*y;debug.log(<span class="string">&quot;2&quot;</span>);&#125;</span><br></pre></td></tr></table></figure>
执行顺序 1-&gt;updata -&gt;updata-&gt;2<br>然后在Update中启动协程StartCoroutine(Test());<br>终止所有协程StopAllCoroutine();<br>终止协程StopCoroutine();</li>
<li>值传递直接改栈上边的地址就可以<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a =<span class="number">10</span>;</span><br><span class="line"><span class="built_in">int</span> b = a;</span><br><span class="line">a =<span class="number">20</span>; </span><br><span class="line">debug a=<span class="number">20</span> b=<span class="number">10</span>；</span><br></pre></td></tr></table></figure>
引用传递需要先将地址(引用)指向，然后根据地址再改堆中的东西(stirng类型可以按照引用类型的方法传递)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BoxEntity entity=<span class="keyword">new</span> BoxEntity();</span><br><span class="line">entity.BoxSize=<span class="number">20</span>;</span><br><span class="line"><span class="comment">//将entity引用赋值给entity2，然后修改引用对应堆中的值</span></span><br><span class="line">BoxEntity entity2 =entity;</span><br><span class="line">entity2.BoxSize=<span class="number">30</span>;</span><br><span class="line">debug entity=<span class="number">30</span></span><br></pre></td></tr></table></figure>
String 字符串不可变性 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//string StrPath=string.Empty;</span></span><br><span class="line">StringBuilder sbr=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">switch</span>(type)&#123;</span><br><span class="line"><span class="keyword">case</span> ResourceType.UIScene;</span><br><span class="line">	<span class="comment">//StrPath=     </span></span><br><span class="line">	sbr.Append(<span class="string">&quot;UIPrefab/UIScene/&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
[SerializeField] 将成员变量 在Inspector中显示<br><code>private Transform m_CameraUpAndDown;</code></li>
<li>扩展方法：StringUtil工具脚本 要求类是静态类<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scene类中<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">Test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="built_in">string</span> a =<span class="string">&quot;10&quot;</span>;</span><br><span class="line"><span class="built_in">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span>.TryParse(a,<span class="keyword">out</span> temp);</span><br><span class="line">&#125;每次都要这么做有点啰嗦所以写在StringUtil类中</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">StringUtil</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">int</span> <span class="title">ToInt</span>(<span class="params"><span class="keyword">this</span> <span class="built_in">string</span> str</span>)</span>&#123;</span><br><span class="line"><span class="built_in">int</span> temp=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span>.TryParse(a,<span class="keyword">out</span> temp);</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>单例模式：每个类中都可以调用自己的单例 SceneMgr代表返回类型<ol>
<li>没有继承MonoBehaviour类时的写法 <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SceneMgr _Instance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SceneMgr <span class="title">Instance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;<span class="keyword">if</span>(_Instance==<span class="literal">null</span>)</span><br><span class="line">&#123;_Instance=<span class="keyword">new</span> SceneMgr();&#125;</span><br><span class="line"><span class="keyword">return</span> _Instance;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestLog</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
然后在TestSence类中<code>SceneMgr.Instance.TestLog();</code></li>
<li>MonoBehaviour类的单例写法（就是当SceneCtrl类继承MonoBehaviour时）:<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> BoxCtrl _Instance;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BoxCtrl <span class="title">Instance</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">get</span></span><br><span class="line">&#123;<span class="keyword">if</span>(_Instance==<span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//新建空物体</span></span><br><span class="line">GameObject obj =<span class="keyword">new</span> GameObject(<span class="string">&quot;BoxCtrl&quot;</span>);</span><br><span class="line"><span class="comment">//添加脚本组件</span></span><br><span class="line"> _Instance =obj.AddComponent&lt;BoxCtrl&gt;();</span><br><span class="line"><span class="comment">//跨场景物体不释放</span></span><br><span class="line">DontDestroyOnLoad(obj);</span><br><span class="line">&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>MonoBehaviour类的单例快捷写法（就是当SceneCtrl类继承MonoBehaviour时）：条件：物体是场景中唯一的物体比如主摄像机，而且这个脚本只在唯一物体上<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> SceneCtrl Instance;</span><br><span class="line">在Awake()&#123;&#125;中Instance=<span class="keyword">this</span>; </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li>委托：(命名时前边都加On)<ol>
<li>委托原型： <figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="built_in">delegate</span> <span class="keyword">void</span> <span class="title">OnHitHandler</span>(<span class="params">GameObject obj</span>)</span>;</span><br><span class="line"><span class="comment">//定义委托</span></span><br><span class="line"><span class="keyword">public</span> OnHitHandler OnHit;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hit</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure></li>
<li>快捷定义(使用system.Action快捷定义委托)：<ol>
<li>多个发布者对应一个监听者 在BoxCtrl中发布委托，在SceneCtrl中监听委托，BoxCtrl在SceneCtrl中不段实例化(克隆)<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//!!!当箱子被点击的时候执行Hit()方法 然后方法中执行委托</span></span><br><span class="line">BoxCtrl类中  <span class="keyword">public</span> System.Action&lt;GameObject&gt;OnHit; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Hit</span>(<span class="params"></span>)</span>&#123;<span class="keyword">if</span>(OnHit!=<span class="literal">null</span>)&#123;OnHit(GameObject);&#125;&#125;</span><br><span class="line">SceneCtrl类中 </span><br><span class="line">BoxCtrl boxCtrl=objClone.GetComponent&lt;BoxCtrl&gt;();</span><br><span class="line"><span class="keyword">if</span>(boxCtrl!=<span class="literal">null</span>)&#123;</span><br><span class="line"><span class="comment">//当委托触发时才会执行这行</span></span><br><span class="line">boxCtrl.OnHit=BoxHit;</span><br><span class="line">m_CurrCount++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> 	<span class="keyword">void</span> <span class="title">BoxHit</span>(<span class="params">GameObject obj</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">GameObject.Destory(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>一个发布者多个监听者 在SceneCtrl中发布委托<code>(public System.Action&lt;GameObject&gt;OnChange;)</code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updata中判断<span class="keyword">if</span>(OnChange!=<span class="literal">null</span>)&#123;OnChange&#125;</span><br><span class="line">在BoxCtrl监听委托Scenectrl.Instance.Onchange+=change;<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">change</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">因为箱子会销毁所以<span class="function"><span class="keyword">void</span> <span class="title">OnDestory</span>(<span class="params"></span>)</span>&#123;Scenectrl.Instance.Onchange-=change;&#125; </span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li>事件：是特殊的委托<br>快捷定义：在Scenesctrl中发布事件<code>(public Event System.Action&lt;GameObject&gt;Onhit)</code><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在BoxCtrl中监听事件</span><br><span class="line">SceneCtrl.Instance.Onchange+=Instance_OnChange;（按tab自动弹出）</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Instance_OnChange</span>(<span class="params"></span>)</span>&#123;transform.localScale=<span class="keyword">new</span> Vector3(Random.Range(<span class="number">0.3f</span>,<span class="number">3.5f</span>),Random.Range(<span class="number">0.3f</span>,<span class="number">3.5f</span>),Random.Range(<span class="number">0.3f</span>,<span class="number">3.5f</span>))&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OnDestory</span>(<span class="params"></span>)</span>&#123;Scenectrl.Instance.Onchange-=Instance_OnChange;&#125;</span><br></pre></td></tr></table></figure></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/19/Unity%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/" data-id="ckp3bilir000a4sue3e1fffa2" data-title="Unity项目总结" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-UnityAR_VR_IOS_UI" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/18/UnityAR_VR_IOS_UI/" class="article-date">
  <time class="dt-published" datetime="2021-04-18T12:40:39.303Z" itemprop="datePublished">2021-04-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/04/18/UnityAR_VR_IOS_UI/">UnityAR_VR_IOS_UI</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="AR"><a href="#AR" class="headerlink" title="AR"></a>AR</h2><ol>
<li>高通Vuforia官方文档</li>
<li><code>报错：CommandInvokationFailure: Android Asset Packaging Tool failed. D:\android-sdk1\android-sdk_r24.4.1-windows\android-sdk-windows\build-tools\26.0.1\aapt.exe package -v -f -F assets.ap_ -A assets --ignore-assets &quot;!.svn:!.git:!.ds_store:!*.scc:.*:!CVS:!thumbs.db:!picasa.ini:!*~&quot;</code><br>是因为APK超过两个G</li>
</ol>
<h2 id="VR"><a href="#VR" class="headerlink" title="VR"></a>VR</h2><ol>
<li>VR Tools Kit中touch和press区别就是touch碰到就会触发，press需要按到底</li>
<li>UGUI：Canvas-&gt;Render Mode中World Space，可以让UI旋转 适用于VR<br>Image-&gt;Rect Transform-&gt;点击左侧的锚点选择，然后按住“Alt键”可以直接将image移动到左上角</li>
<li>旋转：x值变代表绕着x轴旋转</li>
<li>Area Light：不影响实时的光照环境，只有在烘培之后才会显示，用于制作窗户射向屋子里的光,使用Area Light，需要将被照射的物体调成静态</li>
<li>Light Probes组件：(plane地面是static，cube是动态的 ，烘培之后通过开关查看效果)通过调整参数去影响场景中动态物体的明暗程度来适应整个大场景，让物体在新的场景中变得协调<ul>
<li><img src="/UnityAR_VR_IOS_UI/VR1.png" alt="avatar"></li>
</ul>
</li>
<li>Reflection Probes组件：表现场景中物体的反射程度（针对天花板隧道这种会挡住天空盒子，用探头对周围进行取样，将结果写到一个立方体贴图，并让周围经过的物体得到环境反射影像），提高场景真实度，并且要将参与提供反射信息的物体设置成静态<ul>
<li><img src="/UnityAR_VR_IOS_UI/VR2.png" alt="avatar"> </li>
</ul>
</li>
</ol>
<h2 id="Unity移动和Shader"><a href="#Unity移动和Shader" class="headerlink" title="Unity移动和Shader"></a>Unity移动和Shader</h2><ol>
<li>Unity点击按钮控制物体移动 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_41071087/article/details/79070894">https://blog.csdn.net/weixin_41071087/article/details/79070894</a></li>
<li>unity双面材质攻略 <a target="_blank" rel="noopener" href="http://blog.csdn.net/u012842807/article/details/46806311">http://blog.csdn.net/u012842807/article/details/46806311</a></li>
<li>shader打包时，Edit=&gt;project setting=&gt;Graphics=&gt;always included shaders中添加shader</li>
<li>GetMouseButtonDown按下只触发一次，GetMouseButton会一直触发</li>
<li>D3D Shader真机调试 <a target="_blank" rel="noopener" href="https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html">https://docs.unity3d.com/Manual/SL-DebuggingD3D11ShadersWithVS.html</a></li>
<li>shader遍历<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Shader holoShader = <span class="literal">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ShowHologram</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;        </span><br><span class="line">        effectOn = holoOn = <span class="literal">true</span>;</span><br><span class="line">        originalObjetShaders = <span class="keyword">new</span> List&lt;Shader&gt;();</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function">Renderer singleRenderer <span class="keyword">in</span> <span class="title">GetComponentsInChildren</span>&lt;<span class="title">Renderer</span>&gt;(<span class="params"></span>))</span></span><br><span class="line"><span class="function">            <span class="title">foreach</span> (<span class="params">Material singleMaterial <span class="keyword">in</span> singleRenderer.materials</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                originalObjetShaders.Add(singleMaterial.shader);</span><br><span class="line">                singleMaterial.shader = holoShader;</span><br><span class="line">                SetAllMaterialProperties(singleMaterial);</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">HideHologram</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        effectOn = holoOn = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="function">Renderer singleRenderer <span class="keyword">in</span> <span class="title">GetComponentsInChildren</span>&lt;<span class="title">Renderer</span>&gt;(<span class="params"></span>))</span></span><br><span class="line"><span class="function">            <span class="title">foreach</span> (<span class="params">Material singleMaterial <span class="keyword">in</span> singleRenderer.materials</span>)</span></span><br><span class="line"><span class="function"></span>            &#123;</span><br><span class="line">                singleMaterial.shader = originalObjetShaders[i++];</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li>32位exr格式图片在PScc中转换成8位通道选择不合并，然后转成png或者tga，或者把8192的exr转成4096的exr</li>
<li>前后的shader分开</li>
</ol>
<ul>
<li><img src="/UnityAR_VR_IOS_UI/%E5%89%8D%E5%90%8E%E7%9A%84shader%E5%88%86%E5%BC%80.png" alt="avatar"></li>
</ul>
<ol start="9">
<li>更换shader，把其中的代码换掉，在11行后加cull off shader的名字是Hog’s shaders/BumpSpec_Twoside</li>
</ol>
<ul>
<li><img src="/UnityAR_VR_IOS_UI/%E6%9B%B4%E6%8D%A2shader.png" alt="avatar"></li>
</ul>
<ol start="10">
<li>UGUI框架：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/LiuGuozhu/p/6421685.html">http://www.cnblogs.com/LiuGuozhu/p/6421685.html</a><h2 id="发布IOS全过程"><a href="#发布IOS全过程" class="headerlink" title="发布IOS全过程"></a>发布IOS全过程</h2></li>
<li>登录Apple Develop账号，清空里边所有信息，Devices中信息无法删掉。登录钥匙串清空我的证书中所有证书。发布证书可以配置三个，开发证书可以配置两个(Xcode9.3有ipad6th)</li>
<li>选择Certificates新建证书，选择Production中的APP store and Ad Hoc，然后需要获取CSR文件，通过钥匙串下载CSR文件，然后Apple账号上自动生成Yang Han(dig的MacBook Air)类型Development，然后下一步生成Yang Han类型IOS Distribution</li>
<li>将Yang Han Download，然后在钥匙串中双击这个证书，钥匙串中我的证书中会出现和AppleDevelop中一样的两个证书</li>
<li>新建App ID，Name：HaiDian，Bundle ID：com.digsur.HaiDian新建描述文件,选择Ad Hoc，Profile Name：HaidianPN，然后打开xcode,双击描述文件</li>
<li>Xcode中只需要修改project和TARGETS中的Unity-phone中的参数，target中的unity-phone中General中Signing中勾选Automatically manage signing，Team选择Yang Han，bundle ID对应上。</li>
<li>选择Product中的Archive，成功之后，可以在window中的Organizer中查看历史记录，选择右侧的Export，选择Ad Hoc，选择ipad6代并且勾选Rebuild from BitCode，然后勾选Manually manage signing选项，选择证书Default（IOS Distribution - Created）（这个自动生成的证书）。HaiDian app 选择对应ID HaiDianPN</li>
<li>打包ipa时logo用jpg的，打包apk时logo可以用png的,macOs unity5.6.1f</li>
<li>ios中的unity快捷方式不见了，可以点击unitypackage,air笔记本内存不够用，是在默认盘中的生成的工程文件过多，每生成一次ipa都会生成一个大文件，可以删掉,pad是最新2018版，所以xcode必须是最新版本，发布ipad 6代</li>
<li>Unity工程从一个电脑转移到另一台电脑时候会出现一些材质粉红色情况，处理方法是：<br>File-&gt;buildsettings:然后进入Other Settings勾掉这个<br> <img src="/UnityAR_VR_IOS_UI/StaticBatching.png" alt="avatar"></li>
<li>苹果真机调试证书获取<ol>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/qq992817263/article/details/53783192">http://blog.csdn.net/qq992817263/article/details/53783192</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/Zzy_Genesis/article/details/70209404">http://blog.csdn.net/Zzy_Genesis/article/details/70209404</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/liuxiongtao_1124/article/details/72373800">http://blog.csdn.net/liuxiongtao_1124/article/details/72373800</a><h2 id="UGUI和相机的问题"><a href="#UGUI和相机的问题" class="headerlink" title="UGUI和相机的问题"></a>UGUI和相机的问题</h2></li>
</ol>
</li>
<li>Canvas-&gt;Render Mode:<ol>
<li>Screen Space-Overlay:这种模式层级视图中不需要任何的摄像机，且UI出现在所有摄像机的最前面。</li>
<li>Screen Space-Camera:这种模式需要绑定一个UICamrea,它支持UI前面显示3D对象和粒子系统</li>
<li>World Space:这种模式，UI和3d对象完全一样</li>
</ol>
</li>
<li>Canvas Scaler三种模式:<ol>
<li>Constant Pixel Size像素大小始终不变：Scale Factor是表示缩放倍数</li>
<li>Scale With Screen Size Reference Resolution是开发时的分辨率。以后缩放就参考它Screen Match Mode 又包含三种模式：1-Match Width Or Height 2-Expand 缩放不剪切3-Shrink 缩放剪切</li>
<li>Constant Physical Size 保持物理上不变的方式</li>
<li>Scale Factor是表示缩放倍数 1920<em>1080-&gt;1600</em>900只需要把Scale Factor改成0.833</li>
</ol>
</li>
<li>摄像机Depth属性设置相机渲染顺序，越大越后渲染，显示在上边。</li>
<li>Clear Flags 清除标记：<ol>
<li>每个相机在渲染时会存储颜色和深度信息。屏幕的未绘制部分是空的，默认情况下会显示天空盒</li>
<li>Solid Color 纯色 ： 屏幕上的任何空的部分将显示当前相机的背景颜色。</li>
<li>Depth Only 仅深度：如果你想绘制一个玩家的枪而不让它在环境内部得到裁剪，你要设置两个摄像机，UI一个摄像机，场景一个摄像机，然后将UI摄像机的深度大于场景摄像机的深度，设置一个深度为0的相机来绘制环境，还要另一个深度为1的相机单独绘制武器。该武器相机的清除标记应设置为仅深度。这将保持环境的图形显示在屏幕上，但会丢弃所有关于每个对象在三维空间中的位置的信息。当枪被绘制出来，不透明的部分将完全覆盖任何已绘制的事物，而不管枪到墙之间如何接近。</li>
</ol>
</li>
<li>Culling Mask 剔除遮罩：<ol>
<li>剔除遮罩使用层有选择地渲染一组对象。有关使用层的信息如右图通常好的做法，是把用户界面放到不同的层，然后用一个独立相机单独渲染UI层。为了使UI显示在其他相机视角的顶部，你还需要设置清除标记为Depth only，并确保UI相机的深度比其他相机高<ol>
<li>Creating Layers 创建层</li>
<li>Assigning Layers 分配层</li>
<li>Casting Rays Selectively 选择性地投射光线</li>
<li><img src="/UnityAR_VR_IOS_UI/CullingMask%E5%89%94%E9%99%A4%E9%81%AE%E7%BD%A9.jpg" alt="avatar"></li>
</ol>
</li>
</ol>
</li>
<li>Unity中的layer和tag<br>layer和tag均用于标识不同类别的gameobject，侧重点不同Layer 1-用于camera 2-用于raycast 3-用于灯光Tag 可以通过GameObject.FindWithTay()快速搜索到相关物体</li>
<li>Unity UGUI 按钮绑定事件的 4 种方式：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/isayes/p/6370168.html">http://www.cnblogs.com/isayes/p/6370168.html</a><h3 id="UI和TimeLine"><a href="#UI和TimeLine" class="headerlink" title="UI和TimeLine"></a>UI和TimeLine</h3></li>
<li>UI轮播图设计<ul>
<li><code>Button btn = this.GetComponent&lt;Button&gt;();中“this”代表当前挂在脚本物体(可以省略)“ buttonobj= GameObject.Find(&quot;Button&quot;);”</code> </li>
<li>Unity UGUI入门教程ScrollRect和Toggle配合使用<br><a target="_blank" rel="noopener" href="https://jingyan.baidu.com/album/5d6edee2dba9d999eadeeca9.html?picindex=2">https://jingyan.baidu.com/album/5d6edee2dba9d999eadeeca9.html?picindex=2</a></li>
<li>Dotween插件总结<ul>
<li>键值对集合中包含泛型集合<code>Dictionary&lt;string, List&lt;List&lt;Sprite&gt;&gt;&gt; spritePath = new Dictionary&lt;string, List&lt;List&lt;Sprite&gt;&gt;&gt;();</code></li>
<li>通过name索引把spriteOneList赋值给spriteList<code>spritePath.TryGetValue(ImageName.ToString(), out spriteList);</code></li>
<li>unity从project中直接拖入Hierarchy，而不是场景中，模型位置不会随机变</li>
<li>shader中渲染设置选择Transparent透明格式，然后再light中添加反射探头</li>
<li>Hierarchy 层级面板中排列顺序越往下，渲染顺序就越后，也就是图形会覆盖在先前的图形上</li>
<li>onClick无法调用静态方法，比如<code>public static void You(); </code>动态函数无法调用静态函数</li>
<li>Transform继承了IEnumberable，是可以使用foreach遍历的。<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestTransFind</span> : <span class="title">MonoBehaviour</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Transform parent;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Start</span> (<span class="params"></span>)</span> &#123;</span><br><span class="line">  Debug.Log(parent.transform.name);</span><br><span class="line">  <span class="keyword">foreach</span> (Transform item <span class="keyword">in</span> parent.transform)</span><br><span class="line">  &#123;</span><br><span class="line">      Debug.Log(item.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>一个插件的底层代码分几部分  委托定义，常量定义，属性定义，委托方法，各种字段定义(包括委托字段)，Awake各种初始化 load各种动态资源，加载各种方法，start（），最后就是各种方法什么点击、缩放方法，类之间字段传递用static 类中用public </li>
<li><code>调用另一个类中的成员时，另一个类中的成员需要public static不能是private static，并且引用时需要&quot;类名.方法（属性）&quot;。</code></li>
<li><code>Gallary画廊 Curve曲线 Flip翻转 Diagonal对角线 Layout布局 thumbnail缩略图 Inspector属性面板 according to根据 computes计算 Epsilon小量 positive Infinity正无穷 duration持续时间 elapsed time 经过的时间 template模版 offsets偏移 cached缓存 recursively 递归 recenter 接收 raw原始的</code></li>
<li><code>GameObject.CreatePrimitive(PrimitiveType.Cube)</code>创建基本体,<code>Instantiate(brick, new Vector3(x, y, 0), Quaternion.identity)</code> 实例化预设,<code>SceneManager.LoadScene(&quot;&quot;);</code>切换场景</li>
<li>TimeLine 人形动画播放模型会回到原点的问题解决<ul>
<li>主角位置 必须在0,0,0主角有animation动画，其中勾选Apply root motion这样动画才能融合</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qqqqqqqzz/article/details/104845620?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2&amp;spm=1001.2101.3001.4242">https://blog.csdn.net/qqqqqqqzz/article/details/104845620?utm_medium=distribute.pc_relevant.none-task-blog-baidujs-2&amp;spm=1001.2101.3001.4242</a></li>
</ul>
</li>
<li>就性能而言 不建议使用GUI，有点像Updata不断地刷新界面</li>
<li>GUI与GUILayout的区别:在GUI中，控件的显示区域是通过rect()方法来实现GUILayout无需设定显示区域，系统会自动帮我们计算控件显示区域</li>
<li><code>EventTrigger eventTri = insButton.GetComponent&lt;EventTrigger&gt;();</code><br>获取实例化按钮下的EventTrigger组件<ul>
<li>Event Trigger的触发事件方法（2D 3D）<ul>
<li><img src="/UnityAR_VR_IOS_UI/EventTrigger%E8%A7%A6%E5%8F%91%E4%BA%8B%E4%BB%B6%E6%96%B9%E6%B3%95.png" alt="avatar"></li>
</ul>
</li>
<li>Untiy引擎执行顺序<ul>
<li><img src="/UnityAR_VR_IOS_UI/Unity%E5%BC%95%E6%93%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.jpg" alt="avatar"></li>
</ul>
</li>
<li>贴图LOD可以减少33%内存<ul>
<li><img src="/UnityAR_VR_IOS_UI/4%EF%BF%BDLOD%EF%BF%BD%EF%BF%BD%EF%BF%BD%1133%25%EF%BF%BDX.png" alt="avatar"></li>
</ul>
</li>
<li>trigger和Collider区别<ul>
<li><img src="/UnityAR_VR_IOS_UI/trigger%E5%92%8CCollider%E5%8C%BA%E5%88%AB.png" alt="avatar"></li>
</ul>
</li>
<li>Selectable组件的使用（color multiplier的属性指的是颜色的强度，Fade duration是变化响应反应时间）<ul>
<li><img src="/UnityAR_VR_IOS_UI/Selectable%E5%9F%BA%E7%A1%80%E5%B1%9E%E6%80%A7.png" alt="avatar"></li>
</ul>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/18/UnityAR_VR_IOS_UI/" data-id="ckp3bilif00014sue2tf5291k" data-title="UnityAR_VR_IOS_UI" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/">Linux网络编程-libevent框架开发</a>
          </li>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">Linux网络编程-高并发服务器</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/">Linux系统编程-信号</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/">守护进程-线程-网络基本概念</a>
          </li>
        
          <li>
            <a href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>