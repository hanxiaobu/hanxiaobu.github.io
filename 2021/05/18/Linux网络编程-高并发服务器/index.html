<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Linux网络编程-高并发服务器 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Linux网络编程-高并发服务器 三次握手：三次握手：建立连接需要三次握手过程四次挥手：断开连接需要四次挥手过程win 4096表示我这边接收缓冲区可用4096，mss 1460 告诉对方我这边一次性可以接收数据长度最大为1460函数封装思想：阻塞函数在阻塞期间若收到信号，会被信号中断，errno设置为EINTR，这个错误不应该看成一个错误const void * vptr vptr代表缓冲区 指">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程-高并发服务器">
<meta property="og:url" content="http://example.com/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Linux网络编程-高并发服务器 三次握手：三次握手：建立连接需要三次握手过程四次挥手：断开连接需要四次挥手过程win 4096表示我这边接收缓冲区可用4096，mss 1460 告诉对方我这边一次性可以接收数据长度最大为1460函数封装思想：阻塞函数在阻塞期间若收到信号，会被信号中断，errno设置为EINTR，这个错误不应该看成一个错误const void * vptr vptr代表缓冲区 指">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%AB%98%E5%B9%B6%E5%8F%917.png">
<meta property="article:published_time" content="2021-05-17T16:51:53.298Z">
<meta property="article:modified_time" content="2021-05-18T01:07:56.963Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%AB%98%E5%B9%B6%E5%8F%917.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux网络编程-高并发服务器" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T16:51:53.298Z" itemprop="datePublished">2021-05-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Linux网络编程-高并发服务器
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Linux网络编程-高并发服务器"><a href="#Linux网络编程-高并发服务器" class="headerlink" title="Linux网络编程-高并发服务器"></a>Linux网络编程-高并发服务器</h2><ol>
<li><p>三次握手：<br>三次握手：建立连接需要三次握手过程<br>四次挥手：断开连接需要四次挥手过程<br>win 4096表示我这边接收缓冲区可用4096，<br>mss 1460 告诉对方我这边一次性可以接收数据长度最大为1460<br>函数封装思想：<br>阻塞函数在阻塞期间若收到信号，会被信号中断，errno设置为EINTR，<br>这个错误不应该看成一个错误<br><code>const void * vptr</code> vptr代表缓冲区 指针</p>
</li>
<li><p>解决粘包问题：</p>
<ol>
<li>报头+数据<br>报头可以用四个字节长度：例如：0010(四个字符的字符串) 四个字节长度+数据部分<br>0010 0123456789<br>0007 abcdefg</li>
<li>添加结尾标记</li>
<li>数据包定长<br>事先协商好：相当于协议的意思，底层称之为协议，数据部分协议我们称之为接口，接口简单文档看懂了就可以写，业务逻辑比较难<br>如：发送20个字节的定长数据： 0010xiaozhaobeijing027<br>注意：如果发送的数据是整型需要转换 大端转换 发送是字符串不需要转换</li>
</ol>
</li>
<li><p>重大报错：<br>gcc编译多线程服务器时<br><code>gcc -o thread 02-mult-thread.c wrap.c</code><br>出现报错：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">   /tmp/ccQ5k9fI.o: In function `main<span class="number">&#x27;</span>:</span><br><span class="line">   <span class="number">02</span>-mult-thread.c:(.text+<span class="number">0x1e7</span>): undefined reference to `pthread_create<span class="number">&#x27;</span></span><br><span class="line">   <span class="number">02</span>-mult-thread.c:(.text+<span class="number">0x1f3</span>): undefined reference to `pthread_detach<span class="number">&#x27;</span></span><br><span class="line">   collect2: error: ld returned <span class="number">1</span> <span class="built_in">exit</span> status</span><br><span class="line">   ```  </span><br><span class="line">   解决办法：  </span><br><span class="line">   故在使用gcc编译的时候应该是：``gcc xxx -pthread``  </span><br><span class="line">   一定要加上“-lpthread”,这样才可以编译通过   </span><br><span class="line">   ``gcc -o thread <span class="number">02</span>-mult-thread.c wrap.c -pthread``</span><br><span class="line"><span class="number">4.</span> <span class="string">&quot;\&quot;续行符，写代码的时候一行写不下，写两行  </span></span><br><span class="line"><span class="string">   ``int lfd = Socket(AF_INET, SOCK_STREAM, 0);\``  </span></span><br><span class="line"><span class="string">   可以改成这样：  </span></span><br><span class="line"><span class="string">   ``int lfd = Socket(AF_INET,``  </span></span><br><span class="line"><span class="string">   ``SOCK_STREAM, 0);``  </span></span><br><span class="line"><span class="string">   当read读文件描述符为非阻塞状态的时候,   </span></span><br><span class="line"><span class="string">   若对方没有发送数据, 会立刻返回, errno设置为EAGAIN, 这个错误我们要忽略.</span></span><br><span class="line"><span class="string">5. len写在循环里 是因为len每次都会改.因为端口会改，所以client会变  </span></span><br><span class="line"><span class="string">   len是输入输出参数  </span></span><br><span class="line"><span class="string">   read函数遇到出错cfd返回-1，对方关闭连接返回0  </span></span><br><span class="line"><span class="string">   bind error :Address already in use报错  </span></span><br><span class="line"><span class="string">   int opt = 1;  </span></span><br><span class="line"><span class="string">   setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));  </span></span><br><span class="line"><span class="string">   ![avatar](/Linux网络编程-高并发服务器/高并发1.png)</span></span><br><span class="line"><span class="string">   return是返回调用者的位置，  </span></span><br><span class="line"><span class="string">   return和exit还有break都在线程中效果一样，但是在函数中exit函数才是退出进程或者线程  </span></span><br><span class="line"><span class="string">   父子进程可以共享的：</span></span><br><span class="line"><span class="string">   1. 文件描述符 </span></span><br><span class="line"><span class="string">   2. mmap共享映射区</span></span><br><span class="line"><span class="string">   3. 每个子进程中的变量是互不影响的</span></span><br><span class="line"><span class="string">   4. 在fork之前的变量、函数都会被复制，但是函数不会执行，fork前的函数被父进程调用时还没有子进程。</span></span><br><span class="line"><span class="string">      1. ![avatar](/Linux网络编程-高并发服务器/高并发2.png)</span></span><br><span class="line"><span class="string">      2. ![avatar](/Linux网络编程-高并发服务器/高并发3.png)</span></span><br><span class="line"><span class="string">6. if语句括号中的表达式需要先执行在判断  </span></span><br><span class="line"><span class="string">   所以这个函数的理解是，  </span></span><br><span class="line"><span class="string">   在while中，先执行if语句括号中的表达式得到nread，然后判断nread&lt;0，或者nread==0，最后默认是nread&gt;0的操作  </span></span><br><span class="line"><span class="string">   if的用法是先判断错误的，默认走正确的代码  </span></span><br><span class="line"><span class="string">   my_read函数每次读取一个字符，并将字符地址指向后方  </span></span><br><span class="line"><span class="string">   readline 函数每次读取一行，并且读完将执指针指向行首  </span></span><br><span class="line"><span class="string">      1. ![avatar](/Linux网络编程-高并发服务器/高并发4.png)</span></span><br><span class="line"><span class="string">      2. ![avatar](/Linux网络编程-高并发服务器/高并发5.png)</span></span><br><span class="line"><span class="string">      3. ![avatar](/Linux网络编程-高并发服务器/高并发6.png)</span></span><br><span class="line"><span class="string">7. 多进程服务器版本思路  </span></span><br><span class="line"><span class="string">   ```c</span></span><br><span class="line"><span class="string">   while(1)</span></span><br><span class="line"><span class="string">   &#123;</span></span><br><span class="line"><span class="string">      	cfd = accept();</span></span><br><span class="line"><span class="string">      	</span></span><br><span class="line"><span class="string">      	while(1)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		n = read(cfd, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">      		if(n&lt;=0)</span></span><br><span class="line"><span class="string">      		&#123;</span></span><br><span class="line"><span class="string">      			break;</span></span><br><span class="line"><span class="string">      		&#125;</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">   ```  </span></span><br><span class="line"><span class="string">   解决办法1:  </span></span><br><span class="line"><span class="string">   将cfd设置为非阻塞: fcntl  </span></span><br><span class="line"><span class="string">   假如有多个客户端连接请求, cfd只会保留最后一个文件描述符的值  </span></span><br><span class="line"><span class="string">   解决方法2:  </span></span><br><span class="line"><span class="string">   使用多进程: 让父进程监听接受新的连接, 子进程处理新的连接(接收和发送数据);  </span></span><br><span class="line"><span class="string">   父进程还负责回收子进程  </span></span><br><span class="line"><span class="string">   还需要添加的功能: 父进程使用SIGCHLD信号完成对子进程的回收  </span></span><br><span class="line"><span class="string">   注意点: accept或者read函数是阻塞函数, 会被信号打断, 此时不应该视为一个错误.errno=EINTR</span></span><br><span class="line"><span class="string">8. 处理流程:</span></span><br><span class="line"><span class="string">	1. 创建socket, 得到一个监听的文件描述符lfd---socket()</span></span><br><span class="line"><span class="string">	2. 将lfd和IP和端口port进行绑定-----bind();</span></span><br><span class="line"><span class="string">	3. 设置监听----listen()</span></span><br><span class="line"><span class="string">    ```c</span></span><br><span class="line"><span class="string">    进入while(1)</span></span><br><span class="line"><span class="string">	&#123;</span></span><br><span class="line"><span class="string">      	//等待有新的客户端连接到来</span></span><br><span class="line"><span class="string">        //子程序不执行这个函数（父进程执行一次），因为fork在后边，但是cfd和lfd值，</span></span><br><span class="line"><span class="string">        //父子进程是一样的</span></span><br><span class="line"><span class="string">      	cfd = accept();	  </span></span><br><span class="line"><span class="string">      	//fork一个子进程, 让子进程去处理数据</span></span><br><span class="line"><span class="string">      	pid = fork();</span></span><br><span class="line"><span class="string">      	if(pid&lt;0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		exit(-1);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">      	else if(pid&gt;0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		//关闭通信文件描述符cfd</span></span><br><span class="line"><span class="string">      		close(cfd);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">      	else if(pid==0)</span></span><br><span class="line"><span class="string">      	&#123;</span></span><br><span class="line"><span class="string">      		//关闭监听文件描述符</span></span><br><span class="line"><span class="string">      		close(lfd);	  		</span></span><br><span class="line"><span class="string">      		//收发数据</span></span><br><span class="line"><span class="string">      		while(1)</span></span><br><span class="line"><span class="string">      		&#123;</span></span><br><span class="line"><span class="string">      			//读数据</span></span><br><span class="line"><span class="string">      			n = read(cfd, buf, sizeof(buf));</span></span><br><span class="line"><span class="string">      			if(n&lt;=0)</span></span><br><span class="line"><span class="string">      			&#123;</span></span><br><span class="line"><span class="string">      				break;</span></span><br><span class="line"><span class="string">      			&#125;</span></span><br><span class="line"><span class="string">      			//发送数据给对方</span></span><br><span class="line"><span class="string">      			write(cfd, buf, n);</span></span><br><span class="line"><span class="string">      		&#125;</span></span><br><span class="line"><span class="string">      		close(cfd);	  		</span></span><br><span class="line"><span class="string">      		//下面的exit必须有, 防止子进程再去创建子进程</span></span><br><span class="line"><span class="string">      		exit(0);</span></span><br><span class="line"><span class="string">      	&#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">	close(lfd);</span></span><br></pre></td></tr></table></figure></li>
<li><p>多线程版本的服务器开发流程:</p>
<ol>
<li>创建socket，得到一个监听的文件描述符lfd—socket()</li>
<li>将lfd和IP和端口port进行绑定—–bind();</li>
<li>设置监听—–listen()</li>
<li>```c<br>while(1)<br>{<br>  //接收新的客户端连接请求<br>  cfd = accept();<br>  //创建一个子线程<br>  pthread_create(&amp;threadID, NULL, thread_work, &amp;cdf);<br>  //设置分离属性 也可以设置pthread_create函数的第二个参数<br>  pthread_detach(threadID);<br>}<br>close(lfd);  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">      子线程执行函数：  </span><br><span class="line">      &#96;&#96;&#96;c</span><br><span class="line">      void *thread_work(void *arg)</span><br><span class="line">      &#123;</span><br><span class="line">        &#x2F;&#x2F;获得参数：通讯文件描述符</span><br><span class="line">        int cfd &#x3D; *(int *)arg;</span><br><span class="line">        sleep(1);</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">          &#x2F;&#x2F;读数据</span><br><span class="line">          n&#x3D;read(cfd, buf, sizeof(buf)); </span><br><span class="line">          if(n&lt;&#x3D;0)</span><br><span class="line">          &#123;</span><br><span class="line">            break;</span><br><span class="line">          &#125;</span><br><span class="line">          &#x2F;&#x2F;发送数据</span><br><span class="line">          write(cfd, buf, n);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      close(cfd);</span><br><span class="line">      &#96;&#96;&#96;  </span><br><span class="line">      注意：  </span><br><span class="line">      如果同时五个线程连过来，由于创建子线程有先有后（谁先抢到cpu时间片谁先执行）  </span><br><span class="line">      sleep写在“int cfd &#x3D; *(int *)arg;”下边，cfd会在sleep(1)这一秒中，变成最终值  </span><br><span class="line">      但是sleep加在上边时，由于创建子线程有先有后，就会分开12345秒  </span><br><span class="line">10. 多线程版本的服务器开发问题:</span><br><span class="line">	1. 子线程能否关闭lfd?</span><br><span class="line">		子线程不能关闭监听文件描述符lfd,原因是子线程和主线程共享文件描述符</span><br><span class="line">		而不是复制的.</span><br><span class="line">	2. 主线程能否关闭cfd?</span><br><span class="line">		主线程不能关闭cfd, 主线程和子线程共享一个cfd, 而不是复制的, close之后cfd就会</span><br><span class="line">		被真正关闭.</span><br><span class="line">	3. 多个子线程共享cfd, 会有什么问题发生?  </span><br><span class="line">    &#96;&#96;&#96;c</span><br><span class="line">    struct INFO</span><br><span class="line">    &#123;</span><br><span class="line">    	int cfd;</span><br><span class="line">    	pthread_t threadID;</span><br><span class="line">    	struct sockaddr_in client;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct INFO info[100];</span><br><span class="line">    struct INFO</span><br><span class="line">    &#123;</span><br><span class="line">    	int cfd;</span><br><span class="line">    	pthread_t threadID;</span><br><span class="line">    	struct sockaddr_in client;</span><br><span class="line">    &#125;;</span><br><span class="line">    struct INFO info[100];</span><br><span class="line">    &#x2F;&#x2F;初始化INFO数组</span><br><span class="line">    for(i&#x3D;0; i&lt;100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	info[i].cfd&#x3D;-1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i&#x3D;0; i&lt;100; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    	if(info[i].cfd&#x3D;&#x3D;-1)</span><br><span class="line">    	&#123;</span><br><span class="line">    		&#x2F;&#x2F;这块内存可以使用</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if(i&#x3D;&#x3D;100)</span><br><span class="line">    &#123;</span><br><span class="line">    	&#x2F;&#x2F;拒绝接受新的连接</span><br><span class="line">    	close(cfd);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>心跳包：<br>什么是心跳包?<br>用于监测长连接是否正常的字符串.<br>在什么情况下使用心跳包?<br>主要用于监测长连接是否正常.<br>如何使用心跳包?<br>通信双方需要协商规则(协议), 如4个字节长度+数据部分<br>发送心跳包的过程：<br>服务A给B发送数据AAAA(这个是协议)，服务B收到AAAA之后，给A回复BBBB，此时A收到BBBB之后，链接正常。<br>假如A连续发送多次(如3-5次)之后，仍然没有收到B的回复，则认为连接异常；<br>异常之后，A应该重新建立连接：<br>先close原来的链接(这样不会粘包)，然后再重新connect连接就可以了<br>如何让心跳数据和正常的业务数据不混淆？<br>双方可以协商协议，如4个字节长度+具体数据<br>如果发送心跳数据应该：0004AAAA<br>如果发送业务数据：00100123456789<br>对方收数据的时候先收4个字节的报头数据，然后计算长度，若最后计算长度为4，且数据为AAAA，则认为是心跳数据，则B服务会组织应答数据给A：0004BBBB</p>
</li>
<li><p>TCP状态转换图：  </p>
<ol>
<li>三次捂手过程：<br>客户端：SYN_SENT—connect()<br>服务端：LISTEN–listen() SYN_RCVD<br>当三次握手完成后，都处于ESTABLISHED状态  </li>
<li>数据传输过程中状态不发生变化， 都是ESTABLISHED状态  </li>
<li>四次挥手过程：  </li>
</ol>
<p>主动关闭方：FIN_WAIT_T, FIN_WAIT_2, TIME_WAIT<br>被动关闭方： CLOSE_WAIT  LAST_ACK<br>思考题?</p>
<ol>
<li>SYN_SENT状态出现在哪一方? 客户端</li>
<li>SYN_RCVD状态出现在哪一方? 服务端</li>
<li>TIME_WAIT状态出现在哪一方?  主动关闭方</li>
<li>在数据传输的时候没有状态变化.  </li>
</ol>
<p>TIME_WAIT是如何出现的:<br>启动服务端, 启动客户端, 连接建好, 而且也可以正常发送数据;<br>然后先关闭服务端, 服务端就会出现TIME_WAIT状态.<br>为什么需要2MSL：</p>
<ol>
<li>留点时间 让四次挥手的过程更可靠, 确保最后一个发送给对方的ACK到达;</li>
<li>为了保证在2MSL时间内, 不能启动相同的SOCKET-PAIR，如果启动相同的会产生粘包问题  </li>
</ol>
<p>***客户端不绑定端口可以避免2MSL，因为端口不固定 不同的socket-pair<br>相同的socket-pair代表 相同的ip和端口</p>
</li>
<li><p>设置端口复用：<br><code>int opt = 1；</code><br><code>setsockopt(lfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(int));</code><br>半关闭的概念:<br>如果一方close, 另一方没有close, 则认为是半关闭状态, 处于半关闭状态的时候, 可以接收数据, 但是不能发送数据. 相当于把文件描述符的写缓冲区操作关闭了.<br>注意: 半关闭一定是出现在主动关闭的一方. —–半关闭是向下关闭<br>shutdown和close的区别：  </p>
<ol>
<li>shutdown可以实现半关闭，close不行  </li>
<li>2 shutdown关闭的时候，不考虑文件描述符的引用计数，是直接彻底关闭  </li>
</ol>
<p>close考虑文件描述符的引用计数，调用一次close只是将引用数减1，<br>只有减少到0的时候才会真正的关闭<br>注意：当关闭一方，内核操作的ack确认信号还是能发回去的，只不过用户层面不发回去<br>长连接和端连接的概念:<br>长连接: 连接建立好之后,一直保持连接不关闭<br>短连接: 连接使用完之后就立刻关闭.</p>
</li>
<li><p>阻塞有点像qt中的模态对话框<br>阻塞就是在等待一个条件的成立，比如read在等待输入<br>ulimit -a 查看各个内存大小<br>FD_SETSIZE=1024  fd_set使用了该宏, 当然可以修改内核, 然后再重新编译内核, 一般不建议这么做.<br>errno==ECONNABORTED   连接异常<br>errno==EINTR               被信号打断</p>
</li>
<li><p>多路IO复用技术：select函数介绍<br><code>int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);</code><br>函数作用：<br>委托内核监控可读，可写，异常事件<br>函数参数：<br>nfds：输入参数，告诉内核要监控文件描述符的范围，一般取值为最大文件描述符+1<br>readfds：<br>-输入参数：告诉内核要监控哪些文件描述符<br>-输出参数：内核告诉应用程序哪些文件描述符有变化<br>writefds：<br>-输入参数：告诉内核要监控哪些文件描述符<br>-输出参数：内核告诉应用程序哪些文件描述符有变化<br>Exceptfds：<br>-输入输出参数，一般表示异常事件<br>Timeout：<br>超时时间：<br>NULL：表示永久堵塞，直到有事件发生<br>0：表示不阻塞，不管有没有事件发生，都会立刻返回<br>0：表示阻塞的时长，若没有超过时长，则一直堵塞<br>若在时间内，有事情发生，则立刻返回，<br>若超过时长，则立刻返回<br>返回值：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">       <span class="comment">///成功返回发生变化的文件描述符</span></span><br><span class="line">       fd_set <span class="built_in">set</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：从set集合中清除fd</span></span><br><span class="line">       <span class="function"><span class="keyword">int</span>  <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：判断fd是否在set集合中</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：将fd添加到set集合中</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set *<span class="built_in">set</span>)</span></span>;</span><br><span class="line">       <span class="comment">//说明：清空文件描述符集</span></span><br><span class="line">    ```  </span><br><span class="line">    注意：select主要用于服务端，客户端也可以用比如让select监控标准输入，  </span><br><span class="line">    只是文件文件描述符都可以监控，管道也行  </span><br><span class="line">    数据类型fd_set: 文件描述符集合--本质是位图(关于集合可联想一个信号集<span class="keyword">sigset_t</span>)其中位图类似未决信号集</span><br><span class="line"><span class="number">16.</span> 使用select的开发服务端流程：   </span><br><span class="line">    <span class="number">1.</span> 创建socket，得到监听文件描述符lfd----socket()</span><br><span class="line">    <span class="number">2.</span> 设置端口复用----setsockopt()</span><br><span class="line">    <span class="number">3.</span> 将lfd和IP  PORT绑定----bind()</span><br><span class="line">    <span class="number">4.</span> 设置监听--- listen()</span><br><span class="line">    <span class="number">5.</span> 需要内核监听 客户端发的链接或者发的数据  </span><br><span class="line">   <span class="comment">//readfds: 读集合, 是一个传入传出参数  </span></span><br><span class="line">   <span class="comment">//传入: 指的是告诉内核哪些文件描述符需要监控  </span></span><br><span class="line">   <span class="comment">//传出: 指的是内核告诉应用程序哪些文件描述符发生了变化  </span></span><br><span class="line">   fd_set readfds；<span class="comment">//定义文件描述符集变量  </span></span><br><span class="line">   fd_set tmpfds; <span class="comment">//对于传入传出变量我们需要定义一个中间变量  </span></span><br><span class="line">   FD_ZERO(&amp;readfds); <span class="comment">//清空文件描述符集变量  </span></span><br><span class="line">   FD_SET(lfd, &amp;readfds); <span class="comment">//将lfd加入到readfds集合中</span></span><br><span class="line">   ```c</span><br><span class="line">   maxfd = lfd; </span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">   &#123;</span><br><span class="line">          <span class="comment">//这样传入的是readfds，传出变化的是tmpfds </span></span><br><span class="line">          <span class="comment">//如果select中用readfds，那么上边的FD_SET(lfd, &amp;readfds);中readfds就变了</span></span><br><span class="line">          tmpfds=readfds;         </span><br><span class="line">          <span class="comment">//readfds是传入传出参数，tmpfds每次都改，只要select返回，tmpfds就改。</span></span><br><span class="line">          <span class="comment">//假如有3个客户端请求和2个客户端发来数据，nready=5，</span></span><br><span class="line">          <span class="comment">//所以说只要内核监听到连接(nready！=0)，select函数有返回，tmpfds比变化</span></span><br><span class="line">          nready = select(maxfd+<span class="number">1</span>, &amp;tmpfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">          <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">if</span>(error==EINTR) <span class="comment">//被信号中断</span></span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;  </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//发生变化的文件描述符有两类，一类是监听的，一类是用于数据通信的</span></span><br><span class="line">          <span class="comment">//监听文件描述符有变化，有新的连接到来，则accept新的连接</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">//有客户端连接请求到来  tmpfds是内核返回的值，才可以知道有没有可读事件发生</span></span><br><span class="line">          <span class="comment">//FD_ISSET判断有lfd才会有accept生成cfd，下边FD_ISSET有cfd才会通信</span></span><br><span class="line">          <span class="keyword">if</span>(FD_ISSET(lfd, &amp;tmpfds))</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">//接受新的客户端连接请求</span></span><br><span class="line">              cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">              <span class="comment">//将cfd加入到readfds集合中</span></span><br><span class="line">              FD_SET(cfd, &amp;readfds);</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span>(max&lt;cfd)</span><br><span class="line">              &#123;</span><br><span class="line">                  maxfd = cfd;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">continue</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//有客户端数据发来 可能多个客户端需要用for</span></span><br><span class="line">          <span class="keyword">for</span>(i=lfd+<span class="number">1</span>; i&lt;=maxfd; i++)</span><br><span class="line">          &#123;</span><br><span class="line">             <span class="keyword">if</span>(FD_ISSET(i, &amp;tmpfds))</span><br><span class="line">             &#123;</span><br><span class="line">                <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="comment">//read数据  </span></span><br><span class="line">                  <span class="comment">//***只要是内核告诉你有数据可读 就不会阻塞 还有accept也不会阻塞</span></span><br><span class="line">                  n=read(i, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">                  <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      close(i);</span><br><span class="line">                      <span class="comment">//将文件描述符i从内核中除去</span></span><br><span class="line">                      FD_CLR(i, &amp;readfds);</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">//write应答数据给客户端</span></span><br><span class="line">                  write(i, buf, n);</span><br><span class="line">                &#125;</span><br><span class="line">             &#125;</span><br><span class="line">          &#125;</span><br><span class="line">   close(lfd);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>代码优化方向：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> client [<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">for</span>()</span><br><span class="line">    &#123;</span><br><span class="line">       client[i]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="number">1</span>将<span class="string">&quot;通信&quot;</span>文件描述符保存到一个整型的数组中，使用一个变量记录数组中最大元素的下标maxi</span><br><span class="line">    <span class="number">2</span>如果数组中有无效的文件描述符，直接跳过</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先找位置，然后将新的连接的文件描述符保存到connfd数组中</span></span><br><span class="line">      <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;FD_SETSIZE;i++)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="keyword">if</span>(connfd[i]==<span class="number">-1</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            connfd[i] = cfd;</span><br><span class="line">    	      <span class="comment">//不加break会一直找到最后一个</span></span><br><span class="line">    	      <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">     ```  </span><br><span class="line">     ***为什么没在read函数里边加<span class="keyword">while</span>循环？如果加入<span class="keyword">while</span>循环可能进入阻塞，对方数据量比较大，可能没有一次行读完，希望读完，读完之后对方关闭，然后read阻塞，阻塞之后select函数不能执行到</span><br><span class="line"><span class="number">18.</span> 使用epoll模型开发服务器流程:  </span><br><span class="line">    ```c</span><br><span class="line">    <span class="number">1</span> 创建scoket，得到监听文件描述符lfd----socket()</span><br><span class="line">    <span class="number">2</span> 设置端口复用----setsockopt()</span><br><span class="line">    <span class="number">3</span> 绑定----bind()</span><br><span class="line">    <span class="number">4</span> 监听----listen()</span><br><span class="line">    <span class="number">5</span> 创建一棵epoll树</span><br><span class="line">      <span class="keyword">int</span> epfd = epoll_create();</span><br><span class="line">    <span class="comment">//将监听文件描述符lfd对应的事件节点上树</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">      ev.events = EPOLLIN; <span class="comment">//可读事件</span></span><br><span class="line">      ev.data.fd = lfd;</span><br><span class="line">      epoll_ctl(epfd, EPOLL_CTL_ADD, lfd, &amp;ev);</span><br><span class="line">      <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">events</span>[1024];</span></span><br><span class="line">      <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         <span class="comment">//循环等待事件的发生   </span></span><br><span class="line">         <span class="comment">//函数执行完内核就会把客户端的请求或者传送数据信息存到events数组中</span></span><br><span class="line">         nready = epoll_wait(epfd, events, <span class="number">1024</span>, <span class="number">-1</span>);</span><br><span class="line">         <span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(error == EINTR)<span class="comment">//信号被中断</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;nready; i++)</span><br><span class="line">         &#123;</span><br><span class="line">            sockfd = events[i].data.fd;</span><br><span class="line">            <span class="comment">//有客户端连接请求到来</span></span><br><span class="line">            <span class="keyword">if</span>(sockfd ==lfd)</span><br><span class="line">            &#123;</span><br><span class="line">               cfd==accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">               <span class="comment">//将cfd对应的读事件上epoll树</span></span><br><span class="line">               ev.data.fd = lfd;</span><br><span class="line">               ev.events = EPOLLIN;</span><br><span class="line">               epoll_ctl(epfd, EPOLL_CTL_ADD, cfd, &amp;ev);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有客户端发送数据来</span></span><br><span class="line">            n = Read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">            <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               close(sockfd);</span><br><span class="line">               <span class="comment">//将socket对应的事件节点从epoll树上删除</span></span><br><span class="line">               epoll_ctl(epfd, EPOLL_CTL_DEL, sockfd, <span class="literal">NULL</span>);</span><br><span class="line">               perror(<span class="string">&quot;read erroe or client closed&quot;</span>);</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">               <span class="comment">//printf(&quot;n==[%d],buf==[%s]\n&quot;, n,buf)</span></span><br><span class="line">               <span class="comment">//回车也算一个字符</span></span><br><span class="line">               write(sockfd, buf, n);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      Close(epfd);</span><br><span class="line">      close(lfd);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure></li>
<li><p>使用poll模型开发服务端流程:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket, 得到监听文件描述符lfd----socket()</span><br><span class="line"><span class="number">2</span> 设置端口复用----setsockopt()</span><br><span class="line"><span class="number">3</span> 绑定----bind()</span><br><span class="line"><span class="number">4</span> 监听----listen()</span><br><span class="line"><span class="number">5</span> <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">client</span>[1024];</span></span><br><span class="line">  client[<span class="number">0</span>].fd = lfd;</span><br><span class="line">  client[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">  <span class="keyword">int</span> maxi = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">  &#123;</span><br><span class="line">  	client[i].fd = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//将要监控的文件描述符拷贝到内核中，</span></span><br><span class="line">    <span class="comment">//并且内核那些程序文件描述符变化也要拷贝到参数中</span></span><br><span class="line">  	nready = poll(client, maxi+<span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">  	<span class="comment">//异常情况</span></span><br><span class="line">  	<span class="keyword">if</span>(nready&lt;<span class="number">0</span>)</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="keyword">if</span>(errno==EINTR)  <span class="comment">// 被信号中断</span></span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">break</span>;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">//有客户端连接请求到来</span></span><br><span class="line">  	<span class="keyword">if</span>(client[<span class="number">0</span>].revents==POLLIN)</span><br><span class="line">  	&#123;</span><br><span class="line">  		<span class="comment">//接受新的客户端连接</span></span><br><span class="line">  		cfd = accept(lfd, <span class="literal">NULL</span>, <span class="literal">NULL</span>);	</span><br><span class="line">  		<span class="comment">//寻找在client数组中可用位置</span></span><br><span class="line">        <span class="comment">//***寻找client数组中的可用位置 由于if条件已经确定client[0]是lfd，  </span></span><br><span class="line">        <span class="comment">//所以循环从1开始</span></span><br><span class="line">  		<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;<span class="number">1024</span>; i++)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">if</span>(client[i].fd==<span class="number">-1</span>)</span><br><span class="line">  			&#123;</span><br><span class="line">  				client[i].fd = cfd;</span><br><span class="line">  				client[i].events = POLLIN;</span><br><span class="line">  				<span class="keyword">break</span>;</span><br><span class="line">  			&#125;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//客户端连接数达到最大值</span></span><br><span class="line">  		<span class="keyword">if</span>(i==<span class="number">1024</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			close(cfd);</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="comment">//修改client数组下标最大值</span></span><br><span class="line">  		<span class="keyword">if</span>(maxi&lt;i)</span><br><span class="line">  		&#123;</span><br><span class="line">  			maxi = i;</span><br><span class="line">  		&#125;</span><br><span class="line">  		<span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="comment">//下面是有客户端发送数据的情况  0是监听文件描述符</span></span><br><span class="line">  	<span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=maxi; i++)</span><br><span class="line">  	&#123;</span><br><span class="line">  		sockfd = client[i].fd;</span><br><span class="line">  		<span class="comment">//如果client数组中fd为-1, 表示已经不再让你内核监控了, 已经close了</span></span><br><span class="line">  		<span class="keyword">if</span>(client[i].fd==<span class="number">-1</span>)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="keyword">continue</span>;</span><br><span class="line">  		&#125;	</span><br><span class="line">  		<span class="keyword">if</span>(client[i].revents==POLLIN)</span><br><span class="line">  		&#123;</span><br><span class="line">  			<span class="comment">//read 数据</span></span><br><span class="line">  			n = read(sockfd, buf, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">  			<span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">  			&#123;</span><br><span class="line">  				close(sockfd);</span><br><span class="line">  				client[i].fd = <span class="number">-1</span>;		</span><br><span class="line">  			&#125;</span><br><span class="line">  			<span class="keyword">else</span> </span><br><span class="line">  			&#123;</span><br><span class="line">  				<span class="comment">//发送数据给客户端</span></span><br><span class="line">  				write(sockfd, buf, n);</span><br><span class="line">  			&#125; 			</span><br><span class="line">	  		<span class="keyword">if</span>(--nready==<span class="number">0</span>)</span><br><span class="line">	  		&#123;</span><br><span class="line">	  			<span class="keyword">break</span>;</span><br><span class="line">	  		&#125;	</span><br><span class="line">  		&#125;  		</span><br><span class="line">  	&#125;  	</span><br><span class="line">  &#125;</span><br><span class="line">  close(lfd); </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li><p><code>int poll(struct pollfd *fds, nfds_t nfds, int timeout);</code><br>函数说明: 跟select类似, 委托内核监控可读, 可写, 异常事件<br>函数参数:  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">	 fds: 一个<span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span>结构体数组的首地址</span></span><br><span class="line"><span class="class">	   <span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">	      <span class="keyword">int</span>   fd;    <span class="comment">//要监控的文件描述符,如果fd为-1, 表示内核不再监控</span></span><br><span class="line">	      <span class="keyword">short</span> events; <span class="comment">//输入参数, 表示告诉内核要监控的事件,   </span></span><br><span class="line">          <span class="comment">//读事件, 写事件, 异常事件  </span></span><br><span class="line">	      <span class="keyword">short</span> revents;<span class="comment">//输出参数, 表示内核告诉应用程序有哪些文件描述符有事件发生    </span></span><br><span class="line">	   &#125;;</span><br><span class="line">	   events/revents:</span><br><span class="line">	   	 POLLIN:可读事件</span><br><span class="line">	   	 POLLOUT: 可写事件</span><br><span class="line">	   	 POLLERR: 异常事件</span><br><span class="line">	 nfds: 告诉内核监控的范围, 具体是: 数组下标的最大值+<span class="number">1</span> </span><br><span class="line">	 timeout: </span><br><span class="line">		=<span class="number">0</span>: 不阻塞, 立刻返回</span><br><span class="line">		<span class="number">-1</span>: 表示一直阻塞, 直到有事件发生</span><br><span class="line">		&gt;<span class="number">0</span>: 表示阻塞时长, 在时长范围内若有事件发生会立刻返回; </span><br><span class="line">			如果超过了时长也会立刻返回    </span><br><span class="line">     函数返回值:  </span><br><span class="line">      &gt;<span class="number">0</span>: 发生变化的文件描述符的个数  </span><br><span class="line">      =<span class="number">0</span>: 没有文件描述符发生变化  </span><br><span class="line">      <span class="number">-1</span>: 表示异常</span><br><span class="line">    ```  </span><br><span class="line">    ***poll和select区别就是：  </span><br><span class="line">    <span class="number">1.</span> 一个用集合位图结合具体的宏从变化中读取事件(FD_ISSET(lfd, &amp;tmpfds)确定的是读事件)，一个用结构体数组</span><br><span class="line">    <span class="number">2.</span> select需要将cfd加入到select监控的文件描述符集合中，FD_SET(cfd, &amp;rdfds);</span><br><span class="line">    <span class="number">3.</span> epoll会告诉具体哪个文件描述符发生变化</span><br><span class="line"><span class="number">21.</span> epoll模型  </span><br><span class="line">    ```c</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line">    函数说明：创建一棵epoll树，返回一个树根节点</span><br><span class="line">    函数参数：size：必须传一个大于<span class="number">0</span>的数</span><br><span class="line">    返回值：返回个文件描述符，这个文件描述符就表示epoll树的树根节点</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line">    函数说明：将fd上epoll树，从树上删除和修改</span><br><span class="line">    函数参数：epfd：epoll树的树根节点 </span><br><span class="line">       op：EPOLL_CTL_ADD: 添加事件节点到树上</span><br><span class="line">       EPOLL_CTL_DEL: 从树上删除事件节点 </span><br><span class="line">       EPOLL_CTL_MOD: 修改树上对应的事件节点</span><br><span class="line">       fd:要操作的文件描述符</span><br><span class="line">       event：</span><br><span class="line">          event.events: EPOLLIN 可读事件；EPOLLOUT 可写事件；EPOLLERR: 错误事件</span><br><span class="line">          event.fd：委托内核监控的文件描述符</span><br><span class="line">       <span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span>&#123;</span></span><br><span class="line">          <span class="keyword">void</span> *ptr;</span><br><span class="line">          <span class="keyword">int</span> fd;</span><br><span class="line">          <span class="keyword">uint32_t</span> u32;</span><br><span class="line">          <span class="keyword">uint64_t</span> u64;</span><br><span class="line">       &#125;<span class="keyword">epoll_data_t</span>;</span><br><span class="line">          <span class="comment">//结构体相当于一个事件节点 ，可以上树操作</span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span>&#123;</span></span><br><span class="line">          <span class="keyword">unit32_t</span> events; </span><br><span class="line">          <span class="keyword">epoll_data_t</span> data;</span><br><span class="line">       &#125;;</span><br><span class="line">       eg: <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>;</span></span><br><span class="line">          ev.events = EPOLLIN;</span><br><span class="line">          ev.data.fd = fd;</span><br><span class="line">          epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;ev);</span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> Timeout)</span></span>;</span><br><span class="line">    ```  </span><br><span class="line">    函数说明：委托内核监控epoll树的事件节点  </span><br><span class="line">    函数参数：epfd：epoll树根节点  </span><br><span class="line">    events：传出参数，结构体数组  传出参数, 调用epoll_ctl传递给内核什么值，  </span><br><span class="line">    当epoll_wait返回的时候, 内核就传回什么值,不会对<span class="class"><span class="keyword">struct</span> <span class="title">event</span>的结构体变量的值做任何修改但是<span class="title">select</span>和<span class="title">poll</span>会对内核中<span class="title">rdfds</span>改变 所以用临时变量<span class="title">tmpfds</span>  </span></span><br><span class="line"><span class="class">    <span class="title">maxevents</span>：<span class="title">events</span>数组大小  </span></span><br><span class="line"><span class="class">    <span class="title">Timeout</span>：-1 表示阻塞  0 表示不阻塞  &gt;</span><span class="number">0</span> 表示阻塞超时时长  </span><br><span class="line">    epoll_wait 返回的数组中的事件节点的值不会修改，是当时上epoll树的时候设置的值</span><br><span class="line"><span class="number">22.</span> epoll的LT和ET模式:</span><br><span class="line">	<span class="number">1.</span> epoll默认情况下是LT模式, 在这种模式下, 若读数据一次性没有读完,</span><br><span class="line">	  缓冲区中还有可读数据, 则epoll_wait还会再次通知</span><br><span class="line">	<span class="number">2.</span> 若将epoll设置为ET模式, 若读数据的时候一次性没有读完, 则epoll_wait不再通知,</span><br><span class="line">	  直到下次有新的数据发来.  </span><br><span class="line">     比如服务端只能读两个字节，但是客户端传<span class="number">1122334455</span>，ET模式下，第一次读<span class="number">11</span> 数据就不读了  </span><br><span class="line">     后边回车相当于发新的数据了，epoll_wait继续返回，读剩下的数据<span class="number">22</span>   </span><br><span class="line">     </span><br><span class="line">     思考:</span><br><span class="line">	<span class="number">1.</span> 在ET模式下, 如何在epoll_wait返回一次的情况下读完数据?</span><br><span class="line">		循环读数据, 直到读完数据, 但是读完数据之后会阻塞.</span><br><span class="line">	<span class="number">2.</span> 若能够一次性读完还需要设置什么? </span><br><span class="line">		将通信文件描述符设置为非阻塞模式</span><br><span class="line"><span class="number">23.</span> select支持跨平台  epoll不支持跨平台  </span><br><span class="line">    linux系统中用epoll   </span><br><span class="line">    unix环境下用select</span><br><span class="line">## 高并发服务器线程池源码分析</span><br><span class="line"><span class="number">1.</span> 调用offset函数测试结构体成员变量的偏移量  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">   <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">   	<span class="class"><span class="keyword">struct</span> <span class="title">s</span> </span></span><br><span class="line"><span class="class">   	&#123;</span></span><br><span class="line">   		<span class="keyword">int</span> i;</span><br><span class="line">   		<span class="keyword">char</span> c;</span><br><span class="line">   		<span class="keyword">double</span> d;</span><br><span class="line">   		<span class="keyword">char</span> a[<span class="number">1</span>];</span><br><span class="line">   	&#125;;</span><br><span class="line">   	<span class="comment">/* Output is compiler dependent */</span></span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;offsets: i=%zd; c=%zd; d=%zd a=%zd\n&quot;</span>,</span><br><span class="line">   			offsetof(struct s, i), offsetof(struct s, c),</span><br><span class="line">   			offsetof(struct s, d), offsetof(struct s, a));</span><br><span class="line">   	<span class="built_in">printf</span>(<span class="string">&quot;sizeof(struct s)=%zd\n&quot;</span>, <span class="keyword">sizeof</span>(struct s));</span><br><span class="line">   	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>udp通信服务端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">    cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 绑定-bind</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  n = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  sendto(cfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;client, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span> 关闭socket套接字</span><br><span class="line">  close(cfd);</span><br><span class="line">udp通信客户端开发流程：</span><br><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">    cfd = socket(AF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//发送数据</span></span><br><span class="line">  sendto(cfd, buf, n, <span class="number">0</span>, (struct sockaddr *)&amp;client, len);</span><br><span class="line">  <span class="comment">//读取数据</span></span><br><span class="line">  n = recvfrom(cfd, buf, <span class="keyword">sizeof</span>(buf), <span class="number">0</span>, (struct sockaddr *)&amp;client, &amp;len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">3</span> 关闭套接字</span><br><span class="line">    close(cfd);</span><br></pre></td></tr></table></figure></li>
<li><p>//模拟循环队列<br><code>int taskpos = (pool-&gt;job_push++)%pool -&gt;max_job_num;</code><br>addtask(thrPool);//添加任务到线程池结构体中的任务池结构体中<br>其中thrPool是共享结构体ThreadPool，需要加锁<br>if(thrPool-&gt;job_num)表示如果thrPool-&gt;job_num&gt;0满足条件<br>如果子线程设置分离属性，可以不用pthread_join函数<br>pthread_cond_wait函数的隐含操作：如果条件不满足阻塞解锁，条件满足加锁<br>用do while可以避免使用goto，而且do while可以使用break if语句不行<br>如果子线程设置非分离属性，主线程需要用pthread_join函数可以保证主线程比子线程后退出</p>
</li>
<li><p>UDP天然支持多个客户端 udp那个案例服务端只能收发 ，不能发收数据<br>本地socket通信：<br>隐含操作：当调用bind函数完成与一个文件绑定之后，会在本地创建一个文件，文件大小为0<br>本地域socket通信服务端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">  lfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 绑定</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> <span class="title">serv</span>;</span></span><br><span class="line">  bzero(&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line">  serv.sun_family = AF_UNIX;</span><br><span class="line">  <span class="comment">//这个文件不要求一开始就存在，如果一开始就存在反而会报错</span></span><br><span class="line">  <span class="built_in">strcpy</span>(serv.sun_path, <span class="string">&quot;./serv.sock&quot;</span>);</span><br><span class="line">  bind(lfd, (struct sockaddr*)&amp;serv, <span class="keyword">sizeof</span>(serv));</span><br><span class="line"><span class="number">3</span> 监听--- listen();</span><br><span class="line"><span class="number">4</span> 接收新的客户端连接---cfd = accept()</span><br><span class="line"><span class="number">5</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//读数据---read();</span></span><br><span class="line">   <span class="keyword">if</span>(error)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//发送数据---write();</span></span><br><span class="line">&#125;</span><br><span class="line">close(cfd);</span><br><span class="line">close(lfd);</span><br></pre></td></tr></table></figure></li>
<li><p>本地域socket通信客户端开发流程：  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 创建socket</span><br><span class="line">  lfd = socket(AF_UNIX, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="number">2</span> 连接服务端--connect</span><br><span class="line"><span class="number">3</span> <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//发送数据---write();</span></span><br><span class="line">   <span class="comment">//读数据---read();</span></span><br><span class="line">   <span class="keyword">if</span>(error)</span><br><span class="line">   &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="number">4</span> close(cfd);  </span><br></pre></td></tr></table></figure></li>
<li><p>UDP通信相关函数介绍:<br><code>ssize_t recvfrom函数是阻塞函数</code><br><code>ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,</code><br><code>struct sockaddr *src_addr, socklen_t *addrlen);</code><br><code>sockfd 套接字：调用socket返回的文件描述符 不是lfd和cfd</code> </p>
</li>
<li><p>#ifndef _THREADPOOL_H<br>避免重复包含<br>线程编译的时候要用末尾要加 -lpthread<br>客户端不绑定地址，服务器不会打印地址。不同于ip和端口绑定，客户端不用绑定，服务器端可以直接打印系统默认给客户端分配的ip和端口</p>
</li>
<li><p>线程池：<img src="/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/%E9%AB%98%E5%B9%B6%E5%8F%917.png" alt="avatar"></p>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" data-id="ckp3biliq00094sue66wd13x8" data-title="Linux网络编程-高并发服务器" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux网络编程-libevent框架开发
        
      </div>
    </a>
  
  
    <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux系统编程-信号</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/">Linux网络编程-libevent框架开发</a>
          </li>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">Linux网络编程-高并发服务器</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/">Linux系统编程-信号</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/">守护进程-线程-网络基本概念</a>
          </li>
        
          <li>
            <a href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>