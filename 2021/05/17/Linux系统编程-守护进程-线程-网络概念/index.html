<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>守护进程-线程-网络基本概念 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="守护进程和线程 线程：LWP(light weight process) 系统分配资源的最基本单位是：进程 系统调度最基本单位是：进程 线程的创建过程就是复制出一个PCB(文件描述符不同)，多个线程是共享文件描述符，不是复制出来的,是共享文件描述符共享：主线程和子线程都打开文件，子线程可以读到主线程写的文件，因为是同一个相当于在同一命名空间下，每个类中都可以共享一个static int name的">
<meta property="og:type" content="article">
<meta property="og:title" content="守护进程-线程-网络基本概念">
<meta property="og:url" content="http://example.com/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="守护进程和线程 线程：LWP(light weight process) 系统分配资源的最基本单位是：进程 系统调度最基本单位是：进程 线程的创建过程就是复制出一个PCB(文件描述符不同)，多个线程是共享文件描述符，不是复制出来的,是共享文件描述符共享：主线程和子线程都打开文件，子线程可以读到主线程写的文件，因为是同一个相当于在同一命名空间下，每个类中都可以共享一个static int name的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B2.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B3.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B4.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B5.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B6.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B7.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B8.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B9.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B10.png">
<meta property="og:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B11.png">
<meta property="article:published_time" content="2021-05-17T00:35:25.212Z">
<meta property="article:modified_time" content="2021-05-17T16:51:14.404Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B2.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Linux系统编程-守护进程-线程-网络概念" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/" class="article-date">
  <time class="dt-published" datetime="2021-05-17T00:35:25.212Z" itemprop="datePublished">2021-05-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      守护进程-线程-网络基本概念
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="守护进程和线程"><a href="#守护进程和线程" class="headerlink" title="守护进程和线程"></a>守护进程和线程</h2><ol>
<li>线程：LWP(light weight process)<ol>
<li>系统分配资源的最基本单位是：进程</li>
<li>系统调度最基本单位是：进程</li>
<li>线程的创建过程就是复制出一个PCB(文件描述符不同)，多个线程是共享文件描述符，不是复制出来的,是共享<br>文件描述符共享：主线程和子线程都打开文件，子线程可以读到主线程写的文件，因为是同一个<br>相当于在同一命名空间下，每个类中都可以共享一个static int name的全局变量，但是每个类中name不同</li>
<li>通过使用线程号来区分不同的线程</li>
<li>多个子线程和主线程共享一个地址空间 有一个PID(都在一个进程里，一块地址空间中) 一个地址空间只有一个pid</li>
<li>用户区中除了栈空间以外，其余资源都可以共享<br>特殊情况共享：<ol>
<li>这种共享是通过pthread_create函数的pthread_t参数传递指针出去的  比如 main中 int i 在子线程中可以用</li>
<li>假如在main中 “{ int arr[5]； }”这就代表arr生命周期到”}”就结束了，所以arr[5]在栈上就不能被子线程读取，<br>如果把“{ int arr[5]； }”中的括号去掉，代表arr和main一个生命周期，而且还sleep，所以可以被子线程读取</li>
<li>主要是说线程执行函数中每个子线程可以创建自己的变量，然后里边的变量是不能够被其他线程读取的 不提倡用全局变量指针</li>
<li>主要是这块内存的生存期足够长，在读取时有效就可以共享</li>
</ol>
</li>
<li>主线程和子线程谁先抢到CPU时间片，谁先执行</li>
<li>创建现成的函数不是系统调用，是C语言的库函数</li>
<li>对于内核而言有几个PCB就有几个线程</li>
<li>信号处理函数也共享<br>查看指定线程的LWP号： ps -Lf pid<br>线程非共享资源：    </li>
</ol>
   ****线程id是给程序员看的 线程号是给内核看的<br>   信号屏蔽字(很少在线程中使用信号，因为太复杂出了问题很难找到)<br>   errno变量（让别的线程共享不安全，因为一个线程改了别的线程也看到了结果，用strerror函数）<br>   一般开发中：1 做业务处理 数据库操作用进程 2 做数据通讯 网络通信用线程<br>   个人理解：可以理解为拥有不同的PCB线程在一个地址空间中，共享着进程里的资源  类似共享着全局变量<br>   也可以理解为在一个地址空间中复制出来拥有不同PCB的线程，他们的资源同步</li>
<li>线程相关函数:这一些列线程相关函数的返回值：都是成功返回0 失败返回错误号<ol>
<li>创建子线程：pthread_create函数<br>由于pthread_create的错误码不保存在errno中，因此不能直接用perror()打印错误信息，可以先用strerror()把错误码转换成错误信息再打印</li>
<li>线程退出：pthread_exit函数<br>在线程中进制调用exit函数，会将整个进程退出</li>
<li>回收子线程：pthread_join函数 阻塞的  </li>
</ol>
***写在主线程中 等待子进程退出之后再退出 保证主线程后退出。<br>&amp;p是&amp;t的二级指针 &amp;p指向&amp;t 也就是说p==&amp;t<ol start="4">
<li>设置子线程为分离属性：pthread_detach函数<br>如果子线程是分离状态，这样主线程在调用pthread_join函数就不会阻塞，立刻返回，但是不建议这么做<br>如果已经对一个线程调用了pthread_detach就不能再调用pthread_join了</li>
</ol>
</li>
<li>在创建线程的时候设置线程属性为分离属性：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">pthread_attr_t</span> attr;</span><br><span class="line">   pthread_attr_init(&amp;attr);</span><br><span class="line">   pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);</span><br><span class="line">   pthread_create(&amp;thread, &amp;attr, mythread, <span class="literal">NULL</span>);</span><br><span class="line">   pthread_attr_destroy(&amp;attr);</span><br><span class="line">   n = number ；</span><br><span class="line">   n++；</span><br><span class="line">   number = n ；</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;1：[%d]\n&quot;</span>,number)；</span><br><span class="line">   ```  </span><br><span class="line">   线程同步：  </span><br><span class="line">   互斥锁：线程A和线程B共同访问共享资源，当线程A想访问共享资源的时候，  </span><br><span class="line">   要先获得锁，如果锁被占用，则加锁不成功需要阻塞等待对方释放锁；  </span><br><span class="line">   若锁没有被占用，则获得锁成功--加锁，然后操作共享资源，操作完之后，  </span><br><span class="line">   必须解锁，同理B也是和A一样。  </span><br><span class="line">   --------&gt;也就是说，同时不能有两个线程访问共享资源，属于互斥操作  </span><br><span class="line">   注意：添加互斥锁时，两个线程中只有一个添加了锁，相当于没添加锁或者把钥匙给了另一个锁  </span><br><span class="line">   因为没添加锁的那线程默认mutex=<span class="number">1</span>，在添加锁的那个线程执行过程中还没执行完，交出cpu时间片，另一个线程也可以执行</span><br><span class="line"><span class="number">4.</span> 创建守护进程模型：</span><br><span class="line">   <span class="number">1.</span> 父进程fork子进程，然后父进程退出（<span class="keyword">if</span>（pid&gt;<span class="number">0</span>）&#123;<span class="number">1</span> <span class="keyword">return</span> <span class="number">0</span>、<span class="number">2</span> <span class="built_in">exit</span>(<span class="number">0</span>)、<span class="number">3</span> kill自己）  </span><br><span class="line">   目的是：子进程肯定不是组长进程，为后续调用setsid函数提供条件</span><br><span class="line">   <span class="number">2.</span> 子进程调用setsid函数创建一个新的会话  </span><br><span class="line">   目的是：  </span><br><span class="line">   - 该子进程成了该会话的会长</span><br><span class="line">   - 该子进程成了该组的组长进程</span><br><span class="line">   - 不在受控制终端的影响了</span><br><span class="line">   <span class="number">3.</span> 改变当前进程的工作目录，chdir-------不是必须的</span><br><span class="line">   <span class="number">4.</span> 重设文件掩码，umask（<span class="number">0000</span>） ------不是必须的</span><br><span class="line">   <span class="number">5.</span> 关闭STDIN_FILENO STDOUT_FILENO STDERR_FILENO   --------不是必须的</span><br><span class="line">   <span class="number">6.</span> 核心操作  </span><br><span class="line">   编写一个守护进程，每隔<span class="number">2</span>S钟获取一次系统时间，并将这个时间写入磁盘文件：  </span><br><span class="line">   分析：首先要按照<span class="number">1.3</span>介绍的守护进程的步骤创建一个守护进程  </span><br><span class="line">   每隔<span class="number">2</span>S钟：使用setitimer函数设置时钟，该时钟发送的是SIGALARM信号，  </span><br><span class="line">   信号操作：注册信号处理函数，signal或者sigaction，还有一个信号处理函数  </span><br><span class="line">   获取一次系统时间：time函数的使用，ctime函数的使用  </span><br><span class="line">   写入磁盘文件：文件操作函数： open write close  </span><br><span class="line">   优化：</span><br><span class="line">   - 不再频繁的打开和关闭文件</span><br><span class="line">   - 如何控制<span class="built_in">log</span>文件大小 test.<span class="built_in">log</span> test.<span class="built_in">log</span><span class="number">.1</span> test.<span class="built_in">log</span><span class="number">.2</span></span><br><span class="line">   - ![avatar](/Linux系统编程-守护进程-线程-网络概念/守护进程<span class="number">1.</span>png)</span><br><span class="line"><span class="number">5.</span> 守护进程的特点：</span><br><span class="line">   <span class="number">1.</span> 一个linux后台服务进程</span><br><span class="line">   <span class="number">2.</span> 不依赖于控制终端</span><br><span class="line">   <span class="number">3.</span>  周期性执行某些任务</span><br><span class="line">   <span class="number">4.</span> 不受用户登陆和注销的影响</span><br><span class="line">   <span class="number">5.</span> 一般以d结尾</span><br><span class="line">   <span class="number">6.</span> 不能和用户通过控制终端进行交换  </span><br><span class="line">   进程组和会话：  </span><br><span class="line">   进程组：一个进程组包含多个进程  </span><br><span class="line">   会话：多个组组成一个会话  </span><br><span class="line">   创建会话的进程不能是组长进程；  </span><br><span class="line">   一般创建会话是父进程先fork子进程，然后父进程退出，让子进程调用setsid函数创建一个会话，这个子进程即使会长也是组长。只要是创建会话，这个进程就脱离了控制终端的影响</span><br><span class="line"><span class="number">6.</span> <span class="keyword">return</span>和<span class="built_in">exit</span>的用法：</span><br><span class="line">   ```c</span><br><span class="line">   <span class="keyword">return</span>;<span class="comment">//不带返回值的return语句</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//带返回值的return语句,或者返回一个变量或一个函数。</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">1</span><span class="comment">//表示函数异常结束</span></span><br><span class="line">   <span class="keyword">return</span>;的作用相当于<span class="keyword">break</span>;用于中断循环的作用；</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;则是<span class="keyword">return</span>的另一种用法，专用于返回值非<span class="keyword">void</span>的函数返回其值。</span><br><span class="line">   ```  </span><br><span class="line">   例如：<span class="keyword">int</span> main()&#123;  f();  <span class="keyword">return</span> <span class="number">0</span>;  &#125;  </span><br><span class="line">   <span class="built_in">exit</span>函数：  </span><br><span class="line">   如果任意一个线程调用了<span class="built_in">exit</span>或_exit，则整个进程的所有线程都终止，由于从main函数<span class="keyword">return</span>也相当于调用<span class="built_in">exit</span></span><br><span class="line"><span class="number">7.</span> 原子操作：该怎么要么不执行，要么就完成   </span><br><span class="line">   比如n++是由好几个指令完成，但是它一次性完成  </span><br><span class="line">   关于这个说法在数据库中也存在  </span><br><span class="line">   互斥锁的使用步骤：</span><br><span class="line">   - 创建一把锁：<span class="keyword">pthread_mutex_t</span> mutex；<span class="comment">//mutex=1; 初始为1表示锁可以用</span></span><br><span class="line">   - 在main函数中初始化互斥锁：pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">   - 锁的作用---在共享资源出现的位置的上下加锁和解锁</span><br><span class="line">      ``pthread_mutex_lock(&amp;mutex);  <span class="comment">//mutex-- 锁为0被占用``   </span></span><br><span class="line">      <span class="comment">//共享资源操作的代码  </span></span><br><span class="line">      ``pthread_mutex_unlock(&amp;mutex);  <span class="comment">//mutex++``</span></span><br><span class="line">   - 在main函数中释放互斥锁</span><br><span class="line">  注意：加锁之后效率变低的本质是：两个线程不能并行了，只能有一个线程执行。  </span><br><span class="line">  异常退出需要解锁</span><br><span class="line"><span class="number">8.</span> umask文件掩码：<span class="number">0002</span>  第一位代表<span class="number">8</span>进制，二三四分别代表文件所属用户，文件所属组，其他人  </span><br><span class="line">   建议多写宏，少写数字，跨系统宏不变  </span><br><span class="line">   写代码时候建议<span class="string">&quot;,&quot;</span>后边跟一个<span class="string">&quot;空格&quot;</span>，比如sigaction(SIGALRM, &amp;act, <span class="literal">NULL</span>);    </span><br><span class="line">   ulimit -a 查看各种数据类型大小  </span><br><span class="line">   ctrl + s 终止屏幕输出  ctrl+q恢复屏幕输出  </span><br><span class="line">   编译的时候太长了 需要写一个脚本编译：</span><br><span class="line">   ```c</span><br><span class="line">   <span class="number">1</span> vi pmak  </span><br><span class="line">   <span class="number">2</span> gcc -o $<span class="number">1</span> $<span class="number">1.</span>c -lpthread 其中$<span class="number">1</span>代表第一个参数</span><br><span class="line">   <span class="comment">//man pthread_create中Compile and link with -pthread，就是gcc -o a.out pthread_create.c -lpthread</span></span><br><span class="line">   需要在链接和编译的时候添加-lpthread库</span><br><span class="line">   <span class="number">3</span> chmod +x pmak   </span><br><span class="line">   <span class="number">4</span> ./pmak  pthread_create_loop 就可以了</span><br></pre></td></tr></table></figure>
<img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B2.png" alt="avatar"></li>
<li>服务就是后台进程<br> bash、shell 也是进程 比如打开4个shell终端，就会有4个bash<br> 但是查看bash时：ps -ef | grep bash 会多出现一个 grep bash命令本身<br> 看进程组的命令 ps -ef | wc -l<br> 查看会话的命令 ps ajx<br> 查看文件中内容显示到终端：tail -f mydemon.log<h2 id="Linux系统编程-线程同步"><a href="#Linux系统编程-线程同步" class="headerlink" title="Linux系统编程-线程同步"></a>Linux系统编程-线程同步</h2></li>
<li>读写锁：读写锁是一把锁<br>总结：写独占 读共享 当读和写一起等待锁的时候，写的优先级高<br>读写锁互斥：线程A持有读锁，线程B请求写锁，会阻塞<br>读写锁使用步骤：<ol>
<li>先定义一把读写锁：<br>pthread_rwlock_t rwlock;</li>
<li>初始化读写锁(主函数中)<br>pthread_rwlock_init(&amp;rwlock，NULL)；</li>
<li>加锁<br>pthread_rwlock_rdlock(&amp;rwlock);——&gt;加读锁<br>pthread_rwlock_wrlock(&amp;rwlock);——&gt;加写锁<br>///<br>共享资源的位置<br>///</li>
<li>解锁<br> pthread_rwlock_unlock(&amp;rwlock);</li>
<li>释放锁<br> pthread_rwlock_destory(&amp;rwlock);</li>
</ol>
</li>
<li>死锁：<br>死锁不是linux提供给开发者的一种机制，而是由于开发者操作不当引起的  <ul>
<li>自己锁自己 注意点：线程在异常退出的时候也需要解锁</li>
<li>A线程占用着A锁，又想去获得B锁，B线程占用着B锁，又想去获得A锁<br>两个线程都不释放自己的锁，又想去获得对方的锁，从而造成了死锁<br>解决办法：<ol>
<li>需要先释放掉自己的锁再去获得其他锁</li>
<li>避免使用嵌套的锁，让线程按照一定的顺序加锁</li>
<li>可以调用pthread_mutex_trylock函数加锁，该函数不阻塞，所以不会产生死锁</li>
</ol>
</li>
</ul>
</li>
<li>条件变量：<ol>
<li>定义条件变量<br><code>pthread_cond_t cond;</code></li>
<li>初始化条件变量<br><code>pthread_cond init(&amp;cond ,NULL);</code></li>
<li>在生产这线程中调用<br><code>pthread_cond_signal(&amp;cond);</code></li>
<li>在消费者线程中调用：<br><code>pthread_cond_wait(&amp;cond, &amp;mutex);</code></li>
<li>释放条件变量<br><code>pthread_cond_destroy(&amp;cond);</code><br>多个生产者和多个消费者程序在运行的时候core掉的原因分析：<br>假如只有一个生产者生产了一个节点，此时会调用pthread_cond_signal通知消费者线程，此时若有多个消费者被唤醒了，则最终只有一个消费者获得锁，此时会将head置为NULL，然后其余的几个消费者线程只会有一个线程获得锁，然后读取head的内容就会core掉。<br>在使用条件变量的线程中，能够引起线程的阻塞的地方有两个：<ol>
<li>在条件变量处引起阻塞—-&gt;这个阻塞会被pthread_cond_signal解除阻塞</li>
<li>互斥锁也会使线程引起阻塞，其他线程先抢到锁—–&gt;其他线程解锁会使该线程解除阻塞  </li>
</ol>
</li>
<li>生产者结束之后 会唤醒很多消费者线程同时抢锁，但是只有一个线程可以抢到。</li>
</ol>
</li>
<li>生产者和消费者模型：<br>消费者中的head是生产者中的pNode<br>pthread_create函数的最后一个参数可以传到子线程中<br>比如：ret=pthread_create(&amp;thread2[i], NULL, consumer, arr[i]);<br>void *consumer(void *arg) 其中arr[i]传给arg;  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B3.png" alt="avatar"></li>
</ul>
</li>
<li>usleep(1000)=sleep(1)<br>信号量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 定义信号量变量</span><br><span class="line"><span class="keyword">sem_t</span> sem1;</span><br><span class="line"><span class="keyword">sem_t</span> sem2;</span><br><span class="line"><span class="number">2.</span> 初始化信号量</span><br><span class="line">sem_init(&amp;sem1,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line">sem_init(&amp;sem2,<span class="number">0</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">3.</span> 加锁</span><br><span class="line">sem_wait(&amp;sem1);</span><br><span class="line"><span class="comment">//共享资源</span></span><br><span class="line">sem_post(&amp;sem2);</span><br><span class="line">sem_wait(&amp;sem2);</span><br><span class="line"><span class="comment">//共享资源</span></span><br><span class="line">sem_post(&amp;sem1);</span><br><span class="line"><span class="number">4.</span> 释放资源</span><br><span class="line">sem_destroy(sem1);</span><br><span class="line">sem_destroy(sem2);</span><br></pre></td></tr></table></figure>
<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B4.png" alt="avatar"><h2 id="网络基本概念"><a href="#网络基本概念" class="headerlink" title="网络基本概念"></a>网络基本概念</h2></li>
</ul>
</li>
<li>网络应用程序常见的两种设计模式：  <ol>
<li>C/S模式：<br>优点：可以安装在本地，可以缓存数据，协议的选择灵活<br>缺点：客户端工具需要有程序员开发，开发周期长工作量大；<br>需要本地安装，对客户的电脑安全有一定影响。</li>
<li>B/S模式<br>浏览器/web服务器模式<br>优点：浏览器不用开发，开发周期短，工作量小<br>缺点：只能选择http协议，协议选择受限制，不能缓存数据，效率受影响</li>
</ol>
</li>
<li>服务说白了就是守护进程<br>xiaobu@ubuntu:/etc$ vim services查看端口号<br>21端口ftp 22端口 ssh 23端口 Telnet<br>127.0.0.1本都回环地址<br>地址重用大概一分钟左右</li>
<li>协议：<br>解释：协议是双方共同指定的一组规则，在网络通讯中表示通讯双方传输数据和解释数据的一组规则。<br>图中：从A上传文件到服务器B，需要在A和B之间制定一个双方都认可的规则，这个规则就称为文件传输协议，该协议是ftp协议的一个初始版本，后经过不断的完善，优化最终形成了一个完成的ftp协议。<br>注意：协议和具体平台无关。<ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B5.png" alt="avatar"></li>
</ul>
</li>
<li>一、网络字节序:<br>大端和小端的概念<br>大端(高端)(网络)：低位地址存放高位数据，高位地址存放低位数据<br>小端(低端)：低位地址存放低位数据，高位地址存放高位数据——这个是正常的<br>网络传输数据的时候用的高端字节序，所以高端字节序也叫网络字节序<br>本机上使用的是小端(低端)字节序  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">   &#123;</span></span><br><span class="line">       <span class="keyword">short</span> s;</span><br><span class="line">       <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">   &#125;un2;<span class="comment">//共用体 两个变量占用同一块内存</span></span><br><span class="line">   ```  </span><br><span class="line">   <span class="comment">//如果用short s赋值 用c显示可以，但是用short赋值，用c再赋值就会覆盖  </span></span><br><span class="line">   二、大小端转换的函数：  </span><br><span class="line">   ```c</span><br><span class="line">   <span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostlong)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostshort)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netlong)</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netshort)</span></span>;</span><br><span class="line">   ```  </span><br><span class="line">   <span class="comment">//函数名的h表示主机host, n表示网络network, s表示short, l表示long  to表示 到大端和小端的使用使用场合???	  </span></span><br><span class="line">   大端和小端只是对数据类型长度是两个及以上的, 如<span class="keyword">int</span>  <span class="keyword">short</span>, 对于单字节	没限制, 在网络中经常需要考虑大端和小端的是IP和端口. 端口就是<span class="keyword">short</span>类型  </span><br><span class="line">   三、IP地址转换函数:</span><br><span class="line">   <span class="number">1.</span> ``<span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>;``  </span><br><span class="line">   函数说明: 将字符串形式的点分十进制IP(低端)转换为大端模式的网络IP(整形<span class="number">4</span>字节数)  </span><br><span class="line">   p-&gt;表示点分十进制的字符串形式  </span><br><span class="line">   to-&gt;到  </span><br><span class="line">   n-&gt;表示network网络  </span><br><span class="line">   参数说明:  </span><br><span class="line">   af: AF_INET  </span><br><span class="line">   src: 字符串形式的点分十进制的IP地址  </span><br><span class="line">   dst: 存放转换后的变量的地址   </span><br><span class="line">   例如: inet_pton(AF_INET, <span class="string">&quot;127.0.0.1&quot;</span>, &amp;serv.sin_addr.s_addr);  </span><br><span class="line">   手工也可以计算: 如<span class="number">192.168</span><span class="number">.232</span><span class="number">.145</span>, 先将<span class="number">4</span>个正数分别转换为<span class="number">16</span>进制数,   </span><br><span class="line">   <span class="number">192</span>---&gt;<span class="number">0xC0</span>  <span class="number">168</span>---&gt;<span class="number">0xA8</span>   <span class="number">232</span>---&gt;<span class="number">0xE8</span>   <span class="number">145</span>---&gt;<span class="number">0x91</span>  </span><br><span class="line">   最后按照大端字节序存放: <span class="number">0x91E8A8C0</span>, 这个就是<span class="number">4</span>字节的整形值.  </span><br><span class="line">   <span class="number">2.</span> ``<span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> size)</span></span>;``  </span><br><span class="line">   函数说明: 网络IP转换为字符串形式的点分十进制的IP  </span><br><span class="line">   参数说明:  </span><br><span class="line">   af: AF_INET  </span><br><span class="line">   src: 网络的整形的IP地址  </span><br><span class="line">   dst: 转换后的IP地址,一般为字符串数组  </span><br><span class="line">   size: dst的长度  </span><br><span class="line">   返回值:   </span><br><span class="line">   成功--返回指向dst的指针  方便链式编程  </span><br><span class="line">   失败--返回<span class="literal">NULL</span>, 并设置errno</span><br><span class="line"><span class="number">5.</span> 服务端开发流程:</span><br><span class="line">	<span class="number">1.</span> 创建socket,返回一个文件描述符lfd---socket()  </span><br><span class="line">      --该文件描述符用于监听客户端连接</span><br><span class="line">	<span class="number">2.</span> 将lfd和IP  PORT进行绑定----bind()</span><br><span class="line">	<span class="number">3.</span> 将lfd由主动变为被动监听----listen()</span><br><span class="line">	<span class="number">4.</span> 接受一个新的连接,得到一个文件描述符cfd----accept()  </span><br><span class="line">   ---该文件描述符是用于和客户端进行通信的</span><br><span class="line">   ```c</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">	  &#123;</span><br><span class="line">	  	接收数据---read或者recv</span><br><span class="line">	  	发送数据---write或者send</span><br><span class="line">	  &#125;<span class="comment">//一般情况下服务端是先接收在发送，</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li>关闭文件描述符—-close(lfd)  close(cfd);  </li>
</ol>
***服务器端获取客户端的ip方便设置黑名单  </li>
<li>客户端的开发流程:<ol>
<li>创建socket, 返回一个文件描述符cfd—socket()  </li>
</ol>
—该文件描述符是用于和服务端通信<ol start="2">
<li>连接服务端—connect() <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//发送数据---write或者send</span></span><br><span class="line"><span class="comment">//接收数据---read或者recv</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>close(cfd)<br>测试过程中可以使用netstat命令查看监听状态和连接状态<br>netstat命令:  netstat -anp | grep 8888<br>a表示显示所有,<br>n表示显示的时候以数字的方式来显<br>p表示显示进程信息(进程名和进程PID)</li>
</ol>
</li>
<li>以太网帧格式：<br>ARP协议：通过对方的IP地址获取MAC地址<br>IP协议：在网络层<br>TCP协议：面向连接的，安全的，可靠的数据流传输协议<br>UDP协议：面向无连接的，不安全的，不可靠的数据报传输。<br>数据报传输就是要传就一下传完，不能像TCP分块拆，因为没序号，无连接<br>RARP协议：逆向地址解析协议，通过MAC地址获取对方的IP地址<br>帧类型有三种：其中数据不够46需要补齐，如果给了一个报文，参照图运用memcpy()函数拷贝字段<br>其中的发送端ip地址指的是大端字节序的整型值  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B6.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B7.png" alt="avatar"></li>
</ul>
</li>
<li>socket编程主要的API函数介绍:<ol>
<li><code>int socket(int domain, int type, int protocol);</code><br>函数描述: 创建socket<br>当调用socket函数以后, 返回一个文件描述符, 内核会提供与该文件描述符相对应的读和写缓冲区, 同时还有两个队列, 分别是请求连接队列和已连接队列(监听文件描述符才会有)  </li>
<li><code>int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>函数描述: 将socket文件描述符和IP,PORT绑定</li>
<li><code>int listen(int sockfd, int backlog);</code><br>函数描述: 将套接字由主动态变为被动态<br>假如backlog=10 ，最多连10个客户端，多了需要等待，10个已经进入连接队列中了，再有连接来只能放在等待连接队列(请求连接队列)中，最大128，不建议填0；</li>
<li><code>int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</code><br>函数说明:获得一个连接(不是新建一个连接), 若当前没有连接则会阻塞等待  </li>
</ol>
***在accept函数调用之前连接就已经建立了，获得连接就是从已连接队列中获得一个连接<br>addr: 传出参数, 保存客户端的地址信息，记录谁连的<br>addrlen: 传入传出参数,  addr变量所占内存空间大小，传入告诉accept这个addr占用内存，传出代表，函数调用完之后被填充了多少<br>accept函数是一个阻塞函数, 若没有新的连接请求, 则一直阻塞<br>内核会负责将请求队列中的连接拿到已连接队列中  <ol start="5">
<li><code>int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</code><br>函数说明: 连接服务器 客户端函数  </li>
<li>接下来就可以使用write和read函数进行读写操作了.<br>读取数据和发送数据:    客户端函数<pre><code class="c">ssize_t read(int fd, void *buf, size_t count);
ssize_t write(int fd, const void *buf, size_t count);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);
ssize_t send(int sockfd, const void *buf, size_t len, int flags);    
//对应recv和send这两个函数flags直接填0就可以了
</code></pre>
个人理解：<br>调用accept之后能拿到一个连接，有了连接可以通信服务端有两种类型文件描述符：  </li>
<li>监听文件描述符：调用socket返回的文件描述符，然后调用listen已近设置为被动监听状态，接收连接，有客户端连过来就接收连接</li>
<li>通信文件描述符：调用accept返回的文件描述符，用来和客户端通信的，收发数据<br>客户端只有一种类型文件描述符(不需要监听)：</li>
<li>通信文件描述符：调用socket返回的文件描述符，用来和客户端通信的，收发数据</li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B8.png" alt="avatar"></li>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B9.png" alt="avatar"></li>
</ol>
</li>
<li>socket编程用到的重要的结构体:struct sockaddr<br> struct sockaddr结构说明:<pre><code class="c">struct sockaddr &#123;
    sa_family_t sa_family;
    char     sa_data[14];
&#125;
</code></pre>
 struct sockaddr_in结构:<pre><code class="c">struct sockaddr_in &#123;
     sa_family_t    sin_family; /* address family: AF_INET */
     in_port_t      sin_port;   /* port in network byte order */
     struct in_addr sin_addr;   /* internet address */
&#125;;
/* Internet address. */
struct in_addr &#123;
     uint32_t  s_addr;     /* address in network byte order */
&#125;;     //网络字节序IP--大端模式
</code></pre>
 通过man 7 ip可以查看相关说明  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B10.png" alt="avatar"></li>
</ul>
</li>
<li>数据通讯过程<br>在发送方是数据层层打包过程<br>在接收方是数据层层解包过程<br>网卡发送的数字信号 通过modemn<br>转换成模拟信号发送到网络中  <ul>
<li><img src="/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B11.png" alt="avatar"></li>
</ul>
</li>
<li>OSI（Open System Interconnection）七层模型：<br>物数网传会表应<br>应用层：主要就是应用程序，ftp ssh email http<br>表示层：进行编解码和翻译工作<br>会话层：建立会话和保持会话 建立信道<br>传输层：定义了端到端的传输，TCP  UDP协议   A端和B端通信中间有很多层，就是很多点(路由器)<br>网络层：定义了点到点的传输，IP协议—–路由器   点到点指的就是路由器到路由器，<br>数据链路层：数据校验（CRC 4个字节），定义了数据格式–帧(从网卡发出去的都叫帧，帧就是有格式的字符串)<br>ARP协议 RARP协议<br>物理层：通讯介质-双绞线，光纤  调制解调器modemn(模数转换和数模转换)<br>TCP四层模型：<br>应用层：对应会话层，表示层和应用层<br>传输层：对应传输层<br>网络层：对应网络层<br>网络接口层：对应物理层和数据链路层<br>知识点：<br>猫的作用：接收信号时，通过高低电频的方法将模拟信号转换为数字信号，其中网线中就是高低电频的模拟信号，<br>外边发的数据最后由网卡接收。<br>路由器：是连接两个不同网段的桥梁</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/" data-id="ckp3bilio00074suegy5rb5cs" data-title="守护进程-线程-网络基本概念" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux系统编程-信号
        
      </div>
    </a>
  
  
    <a href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux系统编程</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-libevent%E6%A1%86%E6%9E%B6%E5%BC%80%E5%8F%91/">Linux网络编程-libevent框架开发</a>
          </li>
        
          <li>
            <a href="/2021/05/18/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-%E9%AB%98%E5%B9%B6%E5%8F%91%E6%9C%8D%E5%8A%A1%E5%99%A8/">Linux网络编程-高并发服务器</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E4%BF%A1%E5%8F%B7/">Linux系统编程-信号</a>
          </li>
        
          <li>
            <a href="/2021/05/17/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5/">守护进程-线程-网络基本概念</a>
          </li>
        
          <li>
            <a href="/2021/05/16/Linux%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B/">Linux系统编程</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>